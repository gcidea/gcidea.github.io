{"meta":{"title":"GCidea's blog","subtitle":"The relentless pursuit of perfection.","description":"The relentless pursuit of perfection.","author":"Gao Chang","url":"http://www.gcidea.info"},"pages":[{"title":"全部文章分类","date":"2017-01-29T07:06:22.572Z","updated":"2017-01-29T07:06:22.572Z","comments":true,"path":"categories/index.html","permalink":"http://www.gcidea.info/categories/index.html","excerpt":"","text":""},{"title":"标签云","date":"2017-01-29T07:14:00.995Z","updated":"2017-01-29T07:14:00.995Z","comments":true,"path":"tag-cloud/index.html","permalink":"http://www.gcidea.info/tag-cloud/index.html","excerpt":"","text":""},{"title":"开源组件","date":"2017-01-15T08:57:25.000Z","updated":"2017-12-31T06:02:01.419Z","comments":true,"path":"projects/index.html","permalink":"http://www.gcidea.info/projects/index.html","excerpt":"","text":"组件列表 二维码生成工具qrcode-generator 简介A tool for generating qrcode. Support to render canvas, display image, download image file and execute callback, upload image file and execute callback, add customized picture to the center of the qrcode and etc. Based on https://www.npmjs.com/package/qrcode API 完整支持https://www.npmjs.com/package/qrcode 的API 基于上述，添加以下API render(id, text, option) 渲染生成二维码及对应Blob对象 @param id Canvas画布id @param text 二维码展示内容 @param option 二维码渲染配置对象（参见https://www.npmjs.com/package/qrcode） @return new Promise 支持回调函数 upload(id, url) 上传二维码图片 @param id Canvas画布id @param url 二维码上传地址（非跨域） @return new Promise 支持回调函数 exportImage(id, filename) 导出二维码图片 @param id Canvas画布id @param filename 二维码文件名 @return new Promise 支持回调函数 getBlobInstance(id) 获取二维码Blob对象实例 @param id Canvas画布id @return blobInstance or {} getCanvasInstance(id) 获取二维码Canvas对象实例 @param id Canvas画布id @return canvasInstance or {} destroy(id) 销毁二维码实例并清空画布 @param id Canvas画布id @returns* 导入csv文件作为数据源 按日期、时间粒度查询 通过百度地图API展现数据分布规律 … 完整组件源码详见github，Github gcidea/qrcode-generator 智慧交通大数据可视化展现Demo 简介该demo基于csv等格式的数据处理结果文件，对数据进行可视化展现，可以： 导入csv文件作为数据源 按日期、时间粒度查询 通过百度地图API展现数据分布规律 … 完整组件源码详见github，Github gcidea/data-visualization 对应简介文章智慧交通大数据可视化展现Demo 可视化HTML5页面拖拽构建工具demo 简介demo，在web端通过拖拽编排的方式快速定制活动H5页面，初步阶段完成。 完整组件源码详见github，Github gcidea/html5-draggable 对应简介文章可视化HTML5页面拖拽构建工具demo 使用AngularJs封装表格内容渲染（含分页）组件 简介该组件是管理系统中很常用的功能，管理系统的典型使用是批量数据的处理，表格展示是最直接的方式。该插件实现： 批量数据的列表展示 每行数据提供操作项（修改，删除等）接口 翻页查询接口 每页显示条数修改 点击表头排序 列表宽度自定义 跳转至某页 … 完整组件源码详见github，Github gcidea/angular-table 对应简介文章使用AngularJs封装表格内容渲染（含分页）组件 使用AngularJs封装Tabs选项卡组件 简介该组件是管理系统中很常用的功能，平台使用者可能会同时使用不同模块的功能，这时候需要打开多个模块，Tabs组件是一种类似浏览器多标签页的效果。可以： 可以在多个模块的页面间进行切换 在某个页面上右键关闭 附带收起侧边栏功能 … 完整组件源码详见github，Github gcidea/angular-tabs 对应简介文章使用AngularJs封装表格内容渲染（含分页）组件"},{"title":"全部文章标签","date":"2017-01-29T07:08:21.880Z","updated":"2017-01-29T07:08:21.880Z","comments":true,"path":"tags/index.html","permalink":"http://www.gcidea.info/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2016-03-15T08:57:25.000Z","updated":"2017-12-31T06:05:25.555Z","comments":true,"path":"about/index.html","permalink":"http://www.gcidea.info/about/index.html","excerpt":"","text":"教育经历硕士：北京邮电大学 网络技术研究院 网络与交换技术国家重点实验室 网络智能研究中心 Network Intelligence Research Center, State Key Laboratory of Networking And Switching Technology, Institute of Network Technology, BUPT本科：北京邮电大学 电子工程学院 School of Electronic Engineering, BUPT 联系方式email: gaochang@gcidea.infoWeChat: gaochang932372QQ: 374187712"}],"posts":[{"title":"PWA-渐进式Web应用探究","slug":"pwa","date":"2017-05-01T13:52:04.000Z","updated":"2018-12-12T16:09:34.311Z","comments":true,"path":"2017/05/01/pwa/","link":"","permalink":"http://www.gcidea.info/2017/05/01/pwa/","excerpt":"","text":"定义 Progressive Web Apps are experiences that combine the best of the web and the best of apps.They are useful to users from the very first visit in a browser tab, no install required.As the user progressively builds a relationship with the app over time, it becomes more and more powerful. 融合了web和app的最佳使用体验 首次访问通过浏览器tab页，无需安装 随着用户多次使用，与应用建立了更明确的关系，体验逐步增强 特点Progressive渐进增强-优雅降级。eq: 离线存储，Cache API  Local Storage Responsive适配PC、移动端多种设备 Connectivity Independent通过service worker实现在低质量网络或者离线条件下使用 App-like建立在app shell模型基础上，就像在使用原生app Fresh通过service worker来保持资源更新 SafePWA服务的提供建立在 https 基础上 Discoverable搜索引擎可抓取，得益于W3C manifest和service worker注册作用域 Re-engageable通过类似推送通知的方式实现应用再次唤起 Installable可让用户不通过app store等应用商店“安装”应用（至桌面） Linkable可简单地通过URl对应用进行分享 历史Google，首次出现于2015.06 Googler Alex Russell的博客文章《Progressive Web Apps: Escaping Tabs Without Losing Our Soul》 主要观点是： Web的发展方向应该是“在保留open web灵魂的基础上渐进增强” 。 环境要求 chrome 52及以上、opera https 但因渐进式设计，所有设备都可以访问（包括iOS） 核心概念application shell与content application shell 类似于原生app开发中发布上线的“the bundle of code”包括支持用户界面所需的最基础的 HTML、CSS 和 JavaScript如果离线缓存，可确保用户重复访问时即时、可靠的良好性能这意味着并不是每次用户访问时都要从网络加载 App Shell 只需要从网络中加载必要的内容 content 动态获取的数据 关键技术service worker的角色service-worker为浏览器启动单独后台运行线程，可以搭配Cache API做缓存、可以拦截所有HTTP请求并使用Fetch API进行response，是一个完备的Proxy service worker的生命周期 消息推送 一句话概述：Service Worker 的后台计算能力—Push API 推送—Notification API 通知 推送（ Push API ） Push API 让推送服务具备了向 web 应用推送消息的能力；它定义了 web 应用如何向推送服务发起订阅、如何响应推送消息、web 应用和服务器与推送服务之间的鉴权与加密机制；由于 Push API 并不依赖 web 应用与浏览器 UI 存活，所以即使是在 web 应用与浏览器未被用户打开的时候，也可以通过后台进程接受推送消息并调用 Notification API 向用户发出通知 通知（ Notification API ） 负责所有与通知本身相关的机制，如通知权限管理、向操作系统发起通知、通知类型与音效，以及提供通知被点击或关闭时的回调等；最早在 2010 年由 Chromium 提出，以 webkitNotifications 前缀方式实现；2011 年进入标准化；2012 年在 Safari 6（Mac OSX 10.8+）上获得支持；2015 年 Notification API 成为 W3C Recommendation；2016 年 Edge 的支持 示例： 案例体验设计App Shell—由设计稿划分component组件 创建app shell对应的模版文件 完成相应逻辑-刷新天气，增加城市等 实现首次快速加载使用localStorage实现对用户已选城市列表的存储（实际使用场景中应该使用 IndexedDB 等快速存储机制） 使用service worker实现对app shell的预缓存（功能的离线使用）注册service workera. 创建一个包含service worker的js文件：service-worker.js (注意该文件位置在项目根目录，因为service worker的作用域由路径决定)b. 通知浏览器注册该service worker 缓存网页资源当service worker注册完成，用户首次访问该应用时触发“install”事件，在回调函数中我们可以对应用所需要的静态资源进行缓存。 caches.open() 打开指定的缓存 cache.addAll() 接收一个URL列表，从服务端获取数据并添加到缓存 此时，在控制台可以看到已经注册的service worker 然后，再在service-worker.js中添加“active”事件绑定 此时，在控制台可以看到已经注册的service worker处于active状态 继续丰富“active”回调函数的内容：确保任何app shell所需的任何静态文件有变化时，service worker都能及时更新 通过缓存提供app shell的内容service worker提供了拦截http请求并进行处理的能力，这意味着可以在service worker内部使用缓存进行响应 测试离线情况首先，点击选择“offline”，network出现黄色叹号标志标明已经处于离线状态 此时，查看已缓存的文件： 使用service worker对data预缓存 核心：静态资源离线优先；动态资源网络优先 通过manifest.json支持在设备home screen添加icon 注：提示添加的条件： 注册了service worker 有manifest文件 5min内访问2次以上（不同浏览器实现不同） 预览 扩展话题对Android/iOS平台原生能力的调用支持https://whatwebcando.today/ http://stackoverflow.com/questions/35504194/what-features-do-progressive-web-apps-have-vs-native-apps-and-vice-versa-on-an 页面质量检测Lighthouse—灯塔，PWA官方提供检测工具 与前端框架的结合（Twitter React PWA）https://twitter.com/necolas/status/829128165314306048 参考资料PWA官方文档（https://developers.google.com/web/progressive-web-apps/） App Shell 模型（https://developers.google.com/web/fundamentals/architecture/app-shell） 服务工作线程Service Worker（https://developers.google.com/web/fundamentals/getting-started/primers/service-workers） PWA 在饿了么的实践经验（https://zhuanlan.zhihu.com/p/25800461） PWA 案例网站（https://weatherpwa.baidu.com/）（https://www.flipkart.com/）","categories":[{"name":"FE综合","slug":"FE综合","permalink":"http://www.gcidea.info/categories/FE综合/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"http://www.gcidea.info/tags/前端工程化/"},{"name":"PWA","slug":"PWA","permalink":"http://www.gcidea.info/tags/PWA/"},{"name":"渐进式web应用","slug":"渐进式web应用","permalink":"http://www.gcidea.info/tags/渐进式web应用/"}]},{"title":"移动端HTML5响应式布局适配解决方案","slug":"mobile-flexible-solution","date":"2017-01-25T05:22:04.000Z","updated":"2018-12-12T16:07:50.003Z","comments":true,"path":"2017/01/25/mobile-flexible-solution/","link":"","permalink":"http://www.gcidea.info/2017/01/25/mobile-flexible-solution/","excerpt":"","text":"前言 移动端适配是一个十分重要的问题。在移动端页面中，其布局和交互方式可能相比于PC端少一些，但是由于设备的多样化，其适配问题就必须多加关注。设备情况种类繁多复杂，从网上的几张图中足以看出： 基本概念物理像素(physical pixel)一个物理像素是显示器(手机屏幕)上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值。 设备独立像素(density-independent pixel)设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，然后由相关系统转换为物理像素。可以理解为就是下面要说的逻辑像素。所以说，物理像素和设备独立像素之间存在着一定的对应关系，这就是接下来要说的设备像素比。 设备像素比(device pixel ratio，即简称dpr)设备像素比(简称dpr)定义了物理像素和设备独立像素的对应关系，它的值可以按如下的公式的得到：设备像素比 = 物理像素 / 设备独立像素 在javascript中，可以通过window.devicePixelRatio获取到当前设备的dpr。 在css中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。 viewport通俗来讲，移动端的viewport就是我们所能看到的手机端浏览器的可视窗口大小，但viewport又不仅仅局限于可视窗口的大小，一般情况下，它是比默认窗口大小要大的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动端正常显示为桌面浏览器而设计的网页，移动端的浏览器都会默认把自己的默认的viewport设为980px到1024px不等，但其后果就是会出现横向滚动条，因为移动端浏览器可视区域的大小是比默认的viewport宽度要小的。1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1,user-scalable=no\"&gt; 该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。 PPI(Pixels Per Inch)像素密度，这项指标是连接数字世界与物理世界的桥梁。Pixels per inch，准确的说是每英寸的长度上排列的像素点数量。1英寸是一个固定长度，等于2.54厘米，大约是食指最末端那根指节的长度。像素密度越高，代表屏幕显示效果越精细。Retina屏比普通屏清晰很多，就是因为它的像素密度翻了一倍。 DPI(Dots Per Inch)每英寸所打印的点数，是打印机、鼠标等设备分辨率的单位。这是衡量打印机打印精度的主要参数之一，一般来说，该值越大，表明打印机的打印精度越高。dpi是指每英寸的像素，也就是扫描精度。国际上都是计算一平方英寸面积内像素的多少。 倍率与逻辑像素 我们在css中声明的是逻辑像素值，而不同设备具体用多少物理像素进行显示有所不同。Retina屏幕把2x2个像素当1个像素使用。比如原本44像素高的顶部导航栏，在Retina屏上用了88个像素的高度来显示。导致界面元素都变成2倍大小，画质更清晰。iOS应用的资源图片中，同一张图通常有多个尺寸。你会看到文件名有的带@2x、@3x字样，有的不带。其中不带@2x、@3x的用在普通屏上，带@2x的用在Retina屏上(iPhone6等尺寸)，带@3x的也用在Retina屏上(iPhone6plus等尺寸)。只要图片准备好，iOS会自己判断用哪张，Android道理也一样。而在web app开发中，则需要自己对图片进行选择。苹果以普通屏为基准，给Retina屏定义了一个2倍或3倍的倍率。实际像素除以倍率，就得到逻辑像素尺寸。只要两个屏幕逻辑像素相同，它们的显示效果就是相同的。 依赖库 lib-flexible 使用实践引入1.npm包安装npm install --save-dev lib-flexible2.在基础js文件靠前位置引入包文件(ES6写法)import &#39;lib-flexible&#39;; 对于长度、宽度等“距离”的写法(less文件)123456789@font-size-base: 75;.home &#123; position: fixed; top: 88rem / @font-size-base; bottom: 98rem / @font-size-base; width: 100%; background-color: #ddd;&#125; 对于文字字号大小的写法(less文件)12345678910111213141516@font-size-base: 75;.name &#123; display: flex; font-family: @font-family-base; color: #000000; letter-spacing: 0; font-size: 17px; [data-dpr=&quot;2&quot;] &amp; &#123; font-size: 34px; &#125; [data-dpr=&quot;3&quot;] &amp; &#123; font-size: 51px; &#125; font-weight: bold; padding-bottom: 20rem/@font-size-base&#125; 源码、原理分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116;(function(win, lib) &#123; var doc = win.document; var docEl = doc.documentElement; var metaEl = doc.querySelector('meta[name=\"viewport\"]'); var flexibleEl = doc.querySelector('meta[name=\"flexible\"]'); var dpr = 0; var scale = 0; var tid; var flexible = lib.flexible || (lib.flexible = &#123;&#125;); if (metaEl) &#123; console.warn('将根据已有的meta标签来设置缩放比例'); var match = metaEl.getAttribute('content').match(/initial\\-scale=([\\d\\.]+)/); if (match) &#123; scale = parseFloat(match[1]); dpr = parseInt(1 / scale); &#125; &#125; else if (flexibleEl) &#123; var content = flexibleEl.getAttribute('content'); if (content) &#123; var initialDpr = content.match(/initial\\-dpr=([\\d\\.]+)/); var maximumDpr = content.match(/maximum\\-dpr=([\\d\\.]+)/); if (initialDpr) &#123; dpr = parseFloat(initialDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; if (maximumDpr) &#123; dpr = parseFloat(maximumDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; &#125; &#125; if (!dpr &amp;&amp; !scale) &#123; var isAndroid = win.navigator.appVersion.match(/android/gi); var isIPhone = win.navigator.appVersion.match(/iphone/gi); var devicePixelRatio = win.devicePixelRatio; if (isIPhone) &#123; // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案 if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) &#123; dpr = 3; &#125; else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2))&#123; dpr = 2; &#125; else &#123; dpr = 1; &#125; &#125; else &#123; // 其他设备下，仍旧使用1倍的方案 dpr = 1; &#125; scale = 1 / dpr; &#125; docEl.setAttribute('data-dpr', dpr); if (!metaEl) &#123; metaEl = doc.createElement('meta'); metaEl.setAttribute('name', 'viewport'); metaEl.setAttribute('content', 'initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no'); if (docEl.firstElementChild) &#123; docEl.firstElementChild.appendChild(metaEl); &#125; else &#123; var wrap = doc.createElement('div'); wrap.appendChild(metaEl); doc.write(wrap.innerHTML); &#125; &#125; function refreshRem()&#123; var width = docEl.getBoundingClientRect().width; if (width / dpr &gt; 540) &#123; width = 540 * dpr; &#125; var rem = width / 10; docEl.style.fontSize = rem + 'px'; flexible.rem = win.rem = rem; &#125; win.addEventListener('resize', function() &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125;, false); win.addEventListener('pageshow', function(e) &#123; if (e.persisted) &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125; &#125;, false); if (doc.readyState === 'complete') &#123; doc.body.style.fontSize = 12 * dpr + 'px'; &#125; else &#123; doc.addEventListener('DOMContentLoaded', function(e) &#123; doc.body.style.fontSize = 12 * dpr + 'px'; &#125;, false); &#125; refreshRem(); flexible.dpr = win.dpr = dpr; flexible.refreshRem = refreshRem; flexible.rem2px = function(d) &#123; var val = parseFloat(d) * this.rem; if (typeof d === 'string' &amp;&amp; d.match(/rem$/)) &#123; val += 'px'; &#125; return val; &#125; flexible.px2rem = function(d) &#123; var val = parseFloat(d) / this.rem; if (typeof d === 'string' &amp;&amp; d.match(/px$/)) &#123; val += 'rem'; &#125; return val; &#125;&#125;)(window, window['lib'] || (window['lib'] = &#123;&#125;)); 手淘团队相关文献参考使用Flexible实现手淘H5页面的终端适配","categories":[{"name":"FE综合","slug":"FE综合","permalink":"http://www.gcidea.info/categories/FE综合/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"前端工程化","slug":"前端工程化","permalink":"http://www.gcidea.info/tags/前端工程化/"},{"name":"HTML/HTML5","slug":"HTML-HTML5","permalink":"http://www.gcidea.info/tags/HTML-HTML5/"},{"name":"CSS/CSS3","slug":"CSS-CSS3","permalink":"http://www.gcidea.info/tags/CSS-CSS3/"},{"name":"Less","slug":"Less","permalink":"http://www.gcidea.info/tags/Less/"},{"name":"响应式","slug":"响应式","permalink":"http://www.gcidea.info/tags/响应式/"}]},{"title":"使用SwitchyOmega和Charles配置统一的开发和生产环境","slug":"uniform-development-product-env-switchyomega-charles","date":"2017-01-23T06:13:51.000Z","updated":"2018-12-12T16:07:42.103Z","comments":true,"path":"2017/01/23/uniform-development-product-env-switchyomega-charles/","link":"","permalink":"http://www.gcidea.info/2017/01/23/uniform-development-product-env-switchyomega-charles/","excerpt":"","text":"本文是客户端代理配置的几种常见方式的一部分内容，主要针对SwitchyOmega和Charles两种工具。 前言 代理服务器是开发过程中的常用工具。通过配置代理，可以统一线上线下环境，在开发阶段也访问线上地址，只不过将请求流量代理到本地服务器，这样便于调试。 Chrome插件SwitchyOmega 该插件可以通过Chrome应用商店进行下载，典型的配置过程如下：1.新建情景模式，选择“代理服务器”2.填写内容如下，也就是想要代理到的服务器地址和端口3.新建情景模式，选择“自动切换模式”4.根据项目需要配置响应的路由规则 这样，在Chrome中调试时候选择“auto switch”，对于相应地址的请求就会根据规则进行转发 Charles Web Debugging Proxy 有了SwitchyOmega，可以应对大部分使用场景。但是，考虑如下情况，SwitchyOmega就不能进行良好的配置了： 线上地址不是根路径，也就是说除了域名、端口号外还有其他服务器上的相对路径。此时，SwitchyOmega会默认把相对路径拼接在代理到的本地服务器后面，然而，本地并不存在这个相对路径，因为本地就是启动在根路径下的，线上是因为一台服务器上可能并存多个项目部署时才具有项目的相对路径。 面对这种情况，使用charles，因为它支持路径映射，也就是map remote功能，典型配置过程如下：1.选择“proxy — proxy settings”做如下配置，这是charles服务器自身运行所在端口2.选择“tools — map remote settings”做如下配置，下面是概览，也就是根据业务需要进行的路由匹配3.第一条：解释：对于线上地址xxx.cn的/admin/ueditor资源的所有访问请求，不代理到本地，直接连接。因为这些是第三方库的资源，不会有修改。4.第二条：解释：对于线上地址xxx.cn的/admin/static资源的所有访问请求，同理，不代理到本地，直接连接。因为这些是一些静态资源，不会有修改。5.第三条：解释：对于线上地址xxx.cn的/admin的所有访问请求，是对于管理系统本身进行访问的，我们在开发过程中要随时查看修改情况，因此代理到本地。6.第四条：解释：对于线上地址xxx.cn的/index.php的所有访问请求，是对于后台接口数据的请求，不是前端项目本身的内容，直接连接。7.第五条：解释：对于线上地址xxx.cn的/的所有访问请求，也是对于所开发系统本身进行访问的（/admin是后台，/是客户端），我们在开发过程中要随时查看修改情况，因此代理到本地。8.效果查看：可以看到，针对远程线上的css文件的请求，已经被成功代理到本地服务器运行所在端口（9989） 注：要注意以上匹配规则的先后顺序，后面的不要被前面的覆盖。","categories":[{"name":"搭建部署","slug":"搭建部署","permalink":"http://www.gcidea.info/categories/搭建部署/"},{"name":"环境统一","slug":"搭建部署/环境统一","permalink":"http://www.gcidea.info/categories/搭建部署/环境统一/"}],"tags":[{"name":"搭建部署","slug":"搭建部署","permalink":"http://www.gcidea.info/tags/搭建部署/"},{"name":"前端工程化","slug":"前端工程化","permalink":"http://www.gcidea.info/tags/前端工程化/"},{"name":"SwitchyOmega","slug":"SwitchyOmega","permalink":"http://www.gcidea.info/tags/SwitchyOmega/"},{"name":"Charles","slug":"Charles","permalink":"http://www.gcidea.info/tags/Charles/"}]},{"title":"React开发框架Dva.js项目结构简单小结","slug":"react-dva-structure","date":"2017-01-20T05:54:23.000Z","updated":"2018-12-12T16:07:47.590Z","comments":true,"path":"2017/01/20/react-dva-structure/","link":"","permalink":"http://www.gcidea.info/2017/01/20/react-dva-structure/","excerpt":"","text":"前言 本篇简单对Dva.js项目的工程结构进行说明，具体的概念，设计，文档，详见Dva.js官网 项目结构 mock属于前后端分离的一种实践，在后端接口未完全实现时，前端可通过mock数据的方式自测。 node_modules项目依赖采用npm管理，所以来包均在此目录。 srcassets项目静态资源目录（图片等） components无状态组件目录。根据react组件化的要求，该目录下的组件是根据具体业务逻辑进行合理划分，细粒度的无状态组件，业务相关的state交付上层容器组件管理。（当然，在具体实践中，该目录下的组件也可以维护少量的仅组件内部使用的状态，不涉及与后端的业务逻辑交互） configs配置文件目录。项目中可能会有一些配置项，统一写在这里方便管理。 models状态model目录。项目所有状态管理均在此目录。对应是redux概念中的store。 routes路由配置目录。路由是单页应用中的重要概念。这里统一配置整个项目的所有路由状态。 servicesservices层目录。这里就是一个“服务”层，负责对后端接口数据的请求和处理。在这里主要可以做两件事：1.发出异步请求（此处不是直接发出，而是调用了下面的utils层的工具，为的是便于管理http全局状态）2.对该接口返回的数据做数据适配adaptor，因为后端接口的数据格式、字段名等往往不一定与前端对应，便可以在这里对其做数据适配。 utils工具函数层。主要是异步请求，全局http状态管理等全局公用的函数工具。 index.html单页应用的入口html。整个工程仅这一个html文件。 index.js单页应用入口js。在这里进行dva项目的初始化。可配置全局使用的history类型，接入日志等中间件，做好全局错误状态的拦截，引入上述routes的路由文件，引入项目所有model状态文件，最后启动整个应用。 index.less全局通用样式配置。典型的有，对body html等元素的margin padding 做统一处理（设置为0，由于这些元素有默认margin padding，防止对后续样式设计产生影响）。 router.js全局路由状态管理目录。在这里对整个应用的跳转关系进行设置。可以在某个路由上设置进入、离开等钩子函数，做出相应逻辑。 .editorconfig编辑器统一设置，比如缩进方式等。 .eslintignore.eslintignore ,如同 .gitignore 一样忽略对于某些文件，文件夹的检查。 .eslintrc代码风格检查文件。 .gitignoregit版本管理忽略文件，对这里设置的目录不作为代码库的管理内容，推荐使用github上的gitignore项目的统一配置，比较全面。 .gitlab-ci.yml项目CI持续集成配置文件 npm-debug.lognpm日志 package.jsonnpm包管理文件 proxy.config.js项目开发测试服务器dora配置文件 webpack.config.jswebpack打包工具配置文件","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"http://www.gcidea.info/categories/前端工程化/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://www.gcidea.info/tags/前端框架/"},{"name":"实现/应用","slug":"实现-应用","permalink":"http://www.gcidea.info/tags/实现-应用/"},{"name":"前端工程化","slug":"前端工程化","permalink":"http://www.gcidea.info/tags/前端工程化/"},{"name":"React","slug":"React","permalink":"http://www.gcidea.info/tags/React/"}]},{"title":"git merge 与 git rebase 的对比分析","slug":"git-merge-git-rebase","date":"2017-01-17T13:45:08.000Z","updated":"2018-12-12T16:08:45.982Z","comments":true,"path":"2017/01/17/git-merge-git-rebase/","link":"","permalink":"http://www.gcidea.info/2017/01/17/git-merge-git-rebase/","excerpt":"","text":"相关概念 以下概念和示例参考http://blog.csdn.net/wh_19910525/article/details/7554489 背景假设现在基于远程分支”origin”，创建一个叫”mywork”的分支。$ git checkout -b mywork origin假设远程分支”origin”已经有了2个提交，那么新创建的mywork分支在现在未修改的状态下是和origin具有相同指向的。如图现在我们在这个分支做一些修改，然后生成两个提交(commit)：12345$ vi file.txt$ git commit$ vi otherfile.txt$ git commit... 但是与此同时，有些人也在”origin”分支上做了一些修改并且做了提交了. 这就意味着”origin”和”mywork”这两个分支各自”前进”了，它们之间”分叉”了。在这里，你可以用”pull”命令把”origin”分支上的修改拉下来并且和你的修改合并； 结果看起来就像一个新的”合并的提交”(merge commit)。而具体合并的方式，则有以下要说的git merge 与 git rebase两种。 git merge12# 将b分支合并到当前分支git merge b git merge有很多参数，可通过git merge --help查看其命令。关于其详细使用，可参考http://blog.csdn.net/hudashi/article/details/7664382 经过merge合并的分支示意如下： git rebase如果想让”mywork”分支历史看起来像没有经过任何合并一样（没有上边的“diamond shape”），也许可以用 git rebase:12# 将b分支合并到当前分支git rebase b 12$ git checkout mywork$ git rebase origin 这些命令会把你的”mywork”分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到”.git/rebase”目录中),然后把”mywork”分支更新 为最新的”origin”分支，最后把保存的这些补丁应用到”mywork”分支上。当’mywork’分支更新之后，它会指向这些新创建的提交(commit),而那些老的提交会被丢弃。 如果运行垃圾收集命令(pruning garbage collection), 这些被丢弃的提交就会删除.在rebase的过程中，也许会出现冲突(conflict)。在这种情况，Git会停止rebase并会让你去解决冲突；在解决完冲突后，用”git-add”命令去更新这些内容的索引(index), 然后，你无需执行 git-commit,只要执行:$ git rebase --continuegit会继续应用(apply)余下的补丁。在任何时候，你可以用–abort参数来终止rebase的行动，并且”mywork” 分支会回到rebase开始前的状态。$ git rebase --abort git merge 与 git rebase的区别和适用场景 区别 当我们使用Git log来参看commit时，其commit的顺序也有所不同。假设C3提交于9:00AM,C5提交于10:00AM,C4提交于11:00AM，C6提交于12:00AM,对于使用git merge来合并所看到的commit的顺序（从新到旧）是：C7 ,C6,C4,C5,C3,C2,C1对于使用git rebase来合并所看到的commit的顺序（从新到旧）是：C7 ,C6‘,C5’,C4,C3,C2,C1 因为C6’提交只是C6提交的克隆，C5’提交只是C5提交的克隆，从用户的角度看使用git rebase来合并后所看到的commit的顺序（从新到旧）是：C7 ,C6,C5,C4,C3,C2,C1 对于两个分支而言，rebase和merge没有区别，但是rebase更干净，因为log hisitory是线性的，但commit不一定按日期先后排，而是local commit总在后面,merge之后history变得比较复杂，但是commit按日期排序 更多地，stackoverflow上对两者的区别有很好的回答：What’s the difference between ‘git merge’ and ‘git rebase’? 适用场景可参考http://blog.csdn.net/rryqsh/article/details/8230560 实际测试git merge的过程 根据以上概念和示例，做如下测试：1.新建文件夹并初始化为git仓库 2.默认是master分支，先在这个分支上做一次修改并commit，否则git不会真正创建master分支（git branch -a命令结果为空）使用git log查看历史，只有一次提交，符合预期。 3.切换分支dev，在dev分支上对同一个文件进行修改（制造冲突的地方，观察合并效果）后commit使用git log查看历史，有2次提交，一次是master分支的，一次是dev分支自己的，符合预期。 4.切换回master分支，在master分支上对同一个文件进行第二次修改后commit。使用git log查看历史，有2次master上的提交，符合预期。 5.在master分支上合并（git merge）dev的内容，会出现冲突，如下所示 6.解决冲突后，在master上再次commit 7.使用git log观察历史版本情况 可以看出，将dev分支合并过来以后，dev分支上的历史记录也是被合并过来了的。并且，所有commit记录的顺序严格遵守时间先后。 git rebase的过程1-4地步骤与git merge中的相同，都是为了构造两个分支并模拟冲突情况，不再重复（但是是创建的全新文件夹，内容上与上面没有重复），下面从第五步合并使用git rebase开始。 5..在master分支上合并（git rebase）dev的内容，会出现冲突，如下所示可以看到提示我们由于冲突rebase过程暂时停止，并且patch文件保存在.git\\rebase-apply，查看其内容如下：1234567diff --git a/test.txt b/test.txtindex 3dd79bb0b2a0e259cfac50c354f16a537c8217b9..d9180eaac8dd0a81ba9cad1e08a69a0ebd0d6646 100644--- a/test.txt+++ b/test.txt@@ -1 +1 @@-master:edit-1+master:edit-1///master:edit-2 根据提示在冲突解决完成后使用git rebase –continue继续合并过程 6.手动解决冲突后使用git rebase –continue继续合并 发现提示我们在解决完成后要使用git add命令将其标记为解决。 7.git add后继续git rebase –continue 8.使用git log查看历史 可以看到，在文件操作完全相同的情况下，与git merge的历史相比，所合并的dev分支只保留了一次在dev分支上最新的提交记录（将其合并进master分支，由于本例在dev上只commit了一次，没有明显看出）。这样，提交记录就是线性的了。并且，我们可以明显看到，使用git rebase进行合并的时候不会产生新的commit（对应git merge中的那次“resolve conflict”）","categories":[{"name":"FE综合","slug":"FE综合","permalink":"http://www.gcidea.info/categories/FE综合/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"版本控制","slug":"版本控制","permalink":"http://www.gcidea.info/tags/版本控制/"}]},{"title":"JavaScript中比较运算的详细总结","slug":"js-compare","date":"2017-01-12T14:11:06.000Z","updated":"2018-12-12T16:08:35.583Z","comments":true,"path":"2017/01/12/js-compare/","link":"","permalink":"http://www.gcidea.info/2017/01/12/js-compare/","excerpt":"","text":"前言 在javascript开发中，比较操作是十分常见的。由于显式/隐式强制类型转换机制的存在，我们在使用比较运算时显得过于随意，也许表面上看并没有什么错误（比如在if()语句中判断两值相等时顺手就写成 == ），但是这可能会埋下很多不易发现的隐患。对于比较操作（相等关系和不等关系），在javascript中其实是有一套完善的机制的。本文依据ES5规范《ECMAScript Language Specification ECMA-2625.1 Edition / June 2011》的11.8节和11.9节： 对javascript中比较操作相关内容进行系统总结。 相等比较严格相等 严格相等指“===”，它不允许比较双方进行强制类型转换。因此，问题考虑变得简单，对于x === y，javascript引擎在进行判断时所遵循的算法如下： 如果x和y的数据类型不同，返回false。 如果x是undefined，返回true。 如果x是null，返回true。 如果x是number类型： 4.1 如果x是NaN，返回false。 4.2 如果y是NaN，返回false。 4.3 如果x和y的值相等，返回true。 4.4 如果x是+0，y是-0，返回true。 4.5 如果x是-0，y是+0，返回true。 4.6 否则，返回false。 如果x是string类型，如果x和y是长度相等且对应位置上字符相同的序列，返回true；否则返回false。 如果x是Boolean类型，如果x和y均为true或者x和y均为false，返回true；否则，返回false。 如果x是对象（普通对象，函数，数组等），那么如果x和y指向同一个对象（是内存中同一个对象的引用），返回true；否则，返回false。 宽松相等 宽松相等指“==”，它会对比较双方进行隐式强制类型转换。下面先根据ES5规范进行系统说明： 如果x和y的数据类型相同： 1.1 如果x的类型是undefined，返回true。 1.2 如果x的类型是null，返回true。 1.3 如果x的类型是number： 1.3.1 如果x是NaN，返回false。 1.3.2 如果y是NaN，返回false。 1.3.3 如果x和y的值相同，返回true。 1.3.4 如果x是+0，y是-0，返回true。 1.3.5 如果x是-0，y是+0，返回true。 1.3.6 否则，返回false。 1.4 如果x是string类型，如果x和y是长度相等且对应位置上字符相同的序列，返回true；否则返回false。 1.5 如果x是Boolean类型，如果x和y均为true或者x和y均为false，返回true；否则，返回false。 1.6 如果x是对象（普通对象，函数，数组等），那么如果x和y指向同一个对象（是内存中同一个对象的引用），返回true；否则，返回false。 如果x是null，y是undefined，返回true。 如果x是undefined，y是null，返回true。 如果x是number类型，y是string类型，则对y进行类型转换，转换为number类型，返回 x == ToNumber(y) 的结果（参见上述1.3）。 如果x是string类型，y是number类型，则对x进行类型转换，转换为number类型，返回 ToNumber(x) == y 的结果（参见上述1.3）。 如果x是Boolean类型，则对x进行类型转换，转换为number类型，返回 ToNumber(x) == y 的结果（此时y的类型还是不确定的，应将其转换为number类型后进行比较）。 如果y是Boolean类型，则对y进行类型转换，转换为number类型，返回 x == ToNumber(y) 的结果（此时x的类型还是不确定的，应将其转换为number类型后进行比较）。 如果x是string类型或者number类型，y是一个对象（普通对象，函数，数组等），则对y进行类型转换—使用内置的[[ToPrimitive]]方法转换（该方法简单来说，就是先调用该对象上的valueOf()方法，如果有该方法且返回基本类型值，就使用该值进行强制类型转换；如果不存在，就调用该对象上的toString()方法，如果有该方法，就使用其返回值来进行强制类型转换；如果这两个方法都不存在，就产生TypeError错误。），返回 x == ToPrimitive(y) 的结果。 如果x是一个对象（普通对象，函数，数组等），y是string类型或者number类型，则对x进行类型转换—使用内置的[[ToPrimitive]]，返回 ToPrimitive(x) == y 的结果。 否则（非上述所有情况），返回false。 注：针对以上10条有几点注意事项：1.对a,b强制按字符串string类型进行比较，可采用如下方法：&quot;&quot; + a == &quot;&quot; + b 2.对a,b强制按数字number类型进行比较，可采用如下方法：+a == +b 3.对a,b强制按布尔值boolean类型进行比较，可采用如下方法：!!a == !!b 4.相等比较操作有以下恒等性： A != B 等价于 !(A == B) A == B 等价于 B == A (除非A B有顺序上的互相计算关系) 5.相等操作并不是总具有传递性。new String(“a”) == “a” 和 “a” == new String(“a”) 结果都返回true；new String(“a”) == new String(“a”) 却返回false。因为new String(“a”)是一个对象，按照上述规则会被转换为”a”，因此相等；而new String(“a”) == new String(“a”)，==左右两边是两个不同的对象，在内存中位于不同地址，因此结果返回false。 由于强制类型转换的存在，宽松相等的情况变得复杂，比较容易出现问题的有以下几种： 更改内置原生原型后的相等比较12345Number.prototype.valueOf = function()&#123; return 3;&#125;new Number(2) == 3; // true 这只是为了说明这种情况的存在，应该不会有人这么去改原型上的方法。 假值的相等比较这部分应该是比较复杂的：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152\"0\" == null; //false\"0\" == undefined; //false\"0\" == false; //true\"0\" == NaN; //false\"0\" == 0; //true\"0\" == \"\"; //falsefalse == null; //falsefalse == undefined; //falsefalse == NaN; //falsefalse == 0; //truefalse == \"\"; //truefalse == []; //truefalse == &#123;&#125;; //false\"\" == null; //false\"\" == undefined; //false\"\" == NaN; //false\"\" == 0; //true\"\" == []; //true\"\" == &#123;&#125;; //false0 == null; //false0 == undefined; //false0 == NaN; //false0 == []; //true0 == &#123;&#125;; //false 解释如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051\"0\" == null; //false：null转换为\"null\"\"0\" == undefined; //false：undefined转换为\"undefined\"\"0\" == false; //true：false转换为0；\"0\"转换为0\"0\" == NaN; //false：NaN转换为\"NaN\"\"0\" == 0; //true：\"0\"转换为0\"0\" == \"\"; //false：都是字符串，值不同false == null; //false：false转换为0；null转换为\"null\"，进而转换为数字，得到NaNfalse == undefined; //false：false转换为0；undefined转换为\"undefined\"，进而转换为数字，得到NaNfalse == NaN; //false：false转换为0；与NaN不同false == 0; //true：false转换为0false == \"\"; //true：false转换为0；\"\"转换为0false == []; //true：false转换为0；[]转换为0false == &#123;&#125;; //false：false转换为0；&#123;&#125;转换为NaN\"\" == null; //false：\"\"转换为0；null转换为\"null\"，进而转换为数字，得到NaN\"\" == undefined; //false：\"\"转换为0；undefined转换为\"undefined\"，进而转换为数字，得到NaN\"\" == NaN; //false：\"\"转换为0；与NaN不同\"\" == 0; //true：\"\"转换为0\"\" == []; //true：\"\"转换为0；[]转换为0\"\" == &#123;&#125;; //false：\"\"转换为0；&#123;&#125;转换为NaN0 == null; //false：null转换为\"null\"，进而转换为数字，得到NaN0 == undefined; //false：undefined转换为\"undefined\"，进而转换为数字，得到NaN0 == NaN; //false：0与NaN不同0 == []; //true：[]转换为00 == &#123;&#125;; //false：&#123;&#125;转换为NaN 一些极端情况a. [] == ![]; //true []被转换为0，![]被转换为false，进而被转换为0。b. 2 == [2]; //true [2]调用数组的valueOf()方法，返回”2”，进而被转换为2。c. “” == [null]; //true [null]调用数组的valueOf()方法，进而调用toString()方法，返回””。 一些选用的原则 如果==两边有true或者false（指本身，不是经过类型转换以后的），绝对不使用==。 如果==两边有[]，””，0，尽量不使用==。 ==和===选取哪一个取决于是否允许比较双方进行强制类型转换。 不应该一味地使用===来避免考虑这些可能的问题，因为有时候隐式类型转换可以让代码更加简洁，只要用的对。‘ typeof x == &quot;function&quot;、typeof x ！= &quot;undefined&quot;这样的用法是完全正确且安全的，开发中也常用。 经典的相等比较关系图GitHub上有一个经典的比较关系图，http://dorey.github.io/JavaScript-Equality-Table/，以表格的形式系统总结了宽松相等==，严格相等===，if()条件语句中使用不同数据类型对应的结果，很有意义： 不等比较!= 和 !== 只要搞清楚上面详细描述的==和===，对应取反即可。 &gt; &lt; &gt;= &lt;= 这些比较的基础是 x &lt; y: x &lt; y会返回true或者false或者undefined。如果返回undefined，说明x,y两者至少有一个是NaN。比较算法中需要使用一个布尔值的标记LeftFirst作为参数。这个参数的作用是控制可能具有副作用的操作作用于x和y的顺序。这个标志是有必要的，因为在ECMAScript指定了从左到右的运算顺序，LeftFirst的默认值是true，表示x的表达式是在y的表达式左边的。如果LeftFirst值为false，情况相反，表明关于y的操作必须先于x进行。据此，比较操作规则如下： 如果LeftFirst值为true： 1.1 ToPrimitive(x, hint Number)的结果记为px 1.2 ToPrimitive(y, hint Number)的结果记为py 否则，运算顺序改为从右向左： 2.1 ToPrimitive(y, hint Number)的结果记为py 2.2 ToPrimitive(x, hint Number)的结果记为px 经过如上转换，如果px和py至少有一个的类型不为string： 3.1 ToNumber(px)的结果记为nx 3.2 ToNumber(py)的结果记为ny 3.3 如果nx是NaN，返回undefined 3.4 如果ny是NaN，返回undefined 3.5 如果nx和ny的值相同，返回false 3.6 如果nx是+0，ny是-0，返回false 3.7 如果nx是-0，ny是+0，返回false 3.8 如果nx是+Infinity，返回false 3.9 如果ny是+Infinity，返回true 3.10 如果ny是-Infinity，返回false 3.11 如果nx是-Infinity，返回true 3.12 如果nx的值小于ny，返回true；否则，返回false 如果px和py都是string： 4.1 如果py是px的前缀，返回false 4.2 如果px是py的前缀，返回true 4.3 设置变量k，k表示px和py对应位上出现不同值时，位置的索引。 4.4 记px的位置k上的字母对应的字符编码值为m 4.5 记py的位置k上的字母对应的字符编码值为n 4.6 如果m &lt; n，返回true；否则返回false 因此，&gt; &lt; &gt;= &lt;=就有如下的规则： RelationalExpression &gt; ShiftExpression 记lref为RelationalExpression的运算结果值。 记lval为lref类型转换后获取的value值。 记rref为ShiftExpression的运算结果值。 记rval为rref类型转换后获取的value值。 设LeftFirst为false，将rval &lt; lval按照上述规则进行运算，结果为r。 如果r是undefined返回false，否则返回r。 RelationalExpression &lt; ShiftExpression 记lref为RelationalExpression的运算结果值。 记lval为lref类型转换后获取的value值。 记rref为ShiftExpression的运算结果值。 记rval为rref类型转换后获取的value值。 将lval &lt; rval按照上述规则进行运算，结果为r。 如果r是undefined返回false，否则返回r。 RelationalExpression &gt;= ShiftExpression 记lref为RelationalExpression的运算结果值。 记lval为lref类型转换后获取的value值。 记rref为ShiftExpression的运算结果值。 记rval为rref类型转换后获取的value值。 设LeftFirst为false，将rval &lt; lval按照上述规则进行运算，结果为r。 如果r是true或者undefined返回false，否则返回true。 RelationalExpression &lt;= ShiftExpression 记lref为RelationalExpression的运算结果值。 记lval为lref类型转换后获取的value值。 记rref为ShiftExpression的运算结果值。 记rval为rref类型转换后获取的value值。 将lval &lt; rval按照上述规则进行运算，结果为r。 如果r是true或者undefined返回false，否则返回true。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"JavaScript中对象属性存在性及相关检测方法总结","slug":"js-obj-attr-exist-or-not-and-related-detect-function","date":"2017-01-11T03:14:54.000Z","updated":"2018-12-12T16:08:31.371Z","comments":true,"path":"2017/01/11/js-obj-attr-exist-or-not-and-related-detect-function/","link":"","permalink":"http://www.gcidea.info/2017/01/11/js-obj-attr-exist-or-not-and-related-detect-function/","excerpt":"","text":"前言 访问一个对象中的某个属性时，返回的结果可能是undefined，这有可能是本身该属性存储的值就是undefined，也有可能是该属性在对象中不存在。对此，就产生了判断属性存在性的相关问题和解决方法。 in操作符语法格式1234567var obj = &#123; name : \"Bob\", age : 24&#125;;(\"name\" in obj); //true(\"sex\" in obj); //false 是否查找原型链是该操作会检查属性在对象本身及其[[prototype]]原型链中是否存在。123456789101112var obj = &#123; name : \"Bob\", age : 24&#125;;var pro = &#123; sex : \"m\"&#125;;obj.__proto__ = pro;\"sex\" in obj; //true 所查找的属性是否必须满足可枚举（enumerable:true）否该操作会检查对象本身及其[[prototype]]原型链上的所有属性，无论其是否可枚举。1234567891011var obj = &#123; name : \"Bob\", age : 24&#125;;Object.defineProperty(obj, \"own\", &#123; enumerable : false, value : 5&#125;);(\"own\" in obj); //true 其他说明in检查的是属性名，而非属性值。 obj.hasOwnProperty(attr)语法格式1234567var obj = &#123; name : \"Bob\", age : 24&#125;;obj.hasOwnProperty(\"name\"); //trueobj.hasOwnProperty(\"sex\"); //false 是否查找原型链否该操作仅会检查属性在对象本身是否存在，不会检查其[[prototype]]原型链。123456789101112var obj = &#123; name : \"Bob\", age : 24&#125;;var pro = &#123; sex : \"m\"&#125;;obj.__proto__ = pro;obj.hasOwnProperty(\"sex\"); //false 所查找的属性是否必须满足可枚举（enumerable:true）否该操作会检查属对象本身上的所有属性，无论其是否可枚举。1234567891011var obj = &#123; name : \"Bob\", age : 24&#125;;Object.defineProperty(obj, \"own\", &#123; enumerable : false, value : 5&#125;);obj.hasOwnProperty(\"own\"); //true 其他说明一般来讲，所有普通对象都可以通过对Object.prototype的委托来访问hasOwnProperty()，但是，对于有些特殊情况，比如通过Object.create(null)来创建的对象，它就没有连接到Object.prototype，因此就无法使用该方法：123var a = Object.create(null);a.name = \"bob\";a.hasOwnProperty(\"name\"); //VM2137:1 Uncaught TypeError: a.hasOwnProperty is not a function(…) 这时可通过显式绑定来达到效果：123var a = Object.create(null);a.name = \"bob\";Object.prototype.hasOwnProperty.call(a, \"name\"); //true for(var k in obj)循环语法格式12345678910var obj = &#123; name : \"Bob\", age : 24&#125;;for(var k in obj)&#123; console.log(k, obj[k]);&#125;//name Bob//age 24 是否查找原型链是该操作会检查属性在对象本身及其[[prototype]]原型链中是否存在。123456789101112131415var obj = &#123; name : \"Bob\", age : 24&#125;;var pro = &#123; sex : \"m\"&#125;;obj.__proto__ = pro;//name Bob//age 24//sex m 所查找的属性是否必须满足可枚举（enumerable:true）是该操作仅会检查对象本身及其[[prototype]]原型链上的所有可枚举属性123456789101112131415var obj = &#123; name : \"Bob\", age : 24&#125;;Object.defineProperty(obj, \"own\", &#123; enumerable : false, value : 5&#125;);for(var k in obj)&#123; console.log(k, obj[k]);&#125;//name Bob//age 24 其他说明不要在数组上运用这种for(var k in obj)循环，因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性，可能会产生一些问题。对于数组遍历，采用普通for循环或者forEach()方法就好。 obj.propertyIsEnumerable语法格式123456var obj = &#123; name : \"Bob\", age : 24&#125;;obj.propertyIsEnumerable(\"name\"); //true 是否查找原型链否该操作仅会检查属性在对象本身是否存在，不会检查其[[prototype]]原型链。123456789101112var obj = &#123; name : \"Bob\", age : 24&#125;;var pro = &#123; sex : \"m\"&#125;;obj.__proto__ = pro;obj.propertyIsEnumerable(\"sex\"); //false 所查找的属性是否必须满足可枚举（enumerable:true）是从名字容易看出，属性必须满足enumerable:true1234567891011var obj = &#123; name : \"Bob\", age : 24&#125;;Object.defineProperty(obj, \"own\", &#123; enumerable : false, value : 5&#125;);obj.propertyIsEnumerable(\"own\"); //false Object.getOwnPropertyNames(obj)语法格式123456var obj = &#123; name : \"Bob\", age : 24&#125;;Object.getOwnPropertyNames(obj); //[\"name\", \"age\"] 是否查找原型链否该操作仅会检查属性在对象本身是否存在，不会检查其[[prototype]]原型链。123456789101112var obj = &#123; name : \"Bob\", age : 24&#125;;var pro = &#123; sex : \"m\"&#125;;obj.__proto__ = pro;Object.getOwnPropertyNames(obj); //[\"name\", \"age\"] 所查找的属性是否必须满足可枚举（enumerable:true）否该操作会检查属对象本身上的所有属性，无论其是否可枚举。1234567891011var obj = &#123; name : \"Bob\", age : 24&#125;;Object.defineProperty(obj, \"own\", &#123; enumerable : false, value : 5&#125;);Object.getOwnPropertyNames(obj); //[\"name\", \"age\", \"own\"] Object.keys(obj)语法格式123456var obj = &#123; name : \"Bob\", age : 24&#125;;Object.keys(obj); //[\"name\", \"age\"] 是否查找原型链否该操作仅会检查属性在对象本身是否存在，不会检查其[[prototype]]原型链。123456789101112var obj = &#123; name : \"Bob\", age : 24&#125;;var pro = &#123; sex : \"m\"&#125;;obj.__proto__ = pro;Object.keys(obj); //[\"name\", \"age\"] 所查找的属性是否必须满足可枚举（enumerable:true）是该操作仅会检查对象本身上的所有可枚举属性1234567891011var obj = &#123; name : \"Bob\", age : 24&#125;;Object.defineProperty(obj, \"own\", &#123; enumerable : false, value : 5&#125;);Object.keys(obj); //[\"name\", \"age\"]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"【探究】当页面关闭时，不同浏览器对尚未完成的异步请求如何处理？","slug":"ajax-status-when-browser-window-close","date":"2017-01-09T09:23:24.000Z","updated":"2018-12-12T16:09:05.341Z","comments":true,"path":"2017/01/09/ajax-status-when-browser-window-close/","link":"","permalink":"http://www.gcidea.info/2017/01/09/ajax-status-when-browser-window-close/","excerpt":"","text":"前言 以使用$.ajax()方法发出一个异步请求为例，探究当执行完发出异步请求的同步代码但尚未执行异步回调的函数的时候，关闭浏览器，不同浏览器对此有何处理。并且，这个问题是因为看到了一种不规范写法而发现的—场景是，执行完相关保存任务（异步请求）后关闭当前页面。这种写法把window.close()相关代码却写在了$ajax()的外面（后面）。违背了在成功保存的回调内关闭页面的做法。 Chrome 现有逻辑下（window.close写在外面）这个ajax请求会被丢弃，用fiddler抓包，没有”../mktools/customized-template-page!save.action?random=”+ new Date().getTime(),这个请求。 Firefox 同chrome 。但是如果在$.ajax上打个断点，是可以看到请求发出去了的，也好理解，因为还没执行到window.close，未完成的请求不会被抛弃。 IE IE 即便不打断点，现有逻辑下（window.close写在外面），请求依然会发出去。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"常见数据格式的正则表达式验证","slug":"js-common-dataformat-regexp","date":"2017-01-07T03:27:52.000Z","updated":"2018-12-12T16:08:36.023Z","comments":true,"path":"2017/01/07/js-common-dataformat-regexp/","link":"","permalink":"http://www.gcidea.info/2017/01/07/js-common-dataformat-regexp/","excerpt":"","text":"前言 正则表达式是一种强大的工具，可以在很多场景下对我们需要的内容进行快速匹配过滤。比如，在前端提交表单时，就可以通过编写合理的正则表达式对用户输入进行首次过滤（当然服务端程序在接收到数据后一样要进行严格的数据检查，保证程序正常运行，防止通过postman等工具绕过前端验证进行恶意攻击。） 正则表达式的学习 网上有很多系统学习正则表达式的资源，掌握基本的语法和相关机制是实现常见数据格式验证的基础。快速了解正则表达式的内容，推荐廖雪峰JavaScript教程中的正则RegExp部分。 需要单独说明的是，以下提到的各种数据格式的验证，都采用JavaScript中的如下写法： 1234var reg = /正则表达式/;var strToTest = \"待测试内容\";reg.test(strToTest); //返回true或者false表明正则验证通过或失败strToTest.match(reg); //以数组形式返回匹配正确的部分，若没有返回null 验证输入是否为空表达式1var reg = /^$/; 解释^匹配开始，$匹配结束，上述表达式的意思是匹配的字符串开始结束之间没有内容。test()方法返回true则表示输入内容为空（输入空格等并不为空）。 验证输入是否为英文字母(大小写)+数字表达式1var reg = /^[a-zA-Z0-9]+$/; 解释分别列出小写a-z，大写A-Z，数字0-9即可。 验证输入是否为英文字母(大小写)+数字+下划线表达式1var reg = /^\\w+$/; 解释正则表达式中\\w就表示匹配一个数字或者字母，也包含了下划线。 验证输入是否为汉字表达式1var reg = /^[\\u4e00-\\u9fa5]&#123;0,&#125;$/; 解释\\u4e00是汉字“一”，\\u9fa5是汉字“龥”，该范围包含了汉字的Unicode编码。 验证输入是否为整数表达式1var reg = /^\\-?[1-9]\\d*$/; 解释 这个表达式可以用来匹配除0以外的任意正负整数。 开始是一个负号“-”，用来匹配负数的负号，?表示非贪婪匹配模式（也就是说匹配尽量少的内容，一旦匹配上就不再考虑后面的字符串）。并且?表示匹配其前面的内容0次或者1次，这样就包括了正数和负数都可以。注意这里的-号后面不能接*或者+，必须只能至多有一个。 [1-9]则表示匹配一个1-9的数字，作为整个这个整数的开头。注意这里必须将第一位这样处理，因为不能为0，无法和后面的\\d*合并。 \\d*则表示后续接的0个或多个数字，和前面的部分共同构成整数。 验证输入是否为正整数表达式1var reg = /^\\+?[1-9]\\d*$/; 解释 开始可以有一个正号（最多一个），当然也可以没有。并且由于+在正则表达式中有特殊含义，因此必须转义。 [1-9]则表示匹配一个1-9的数字，作为整个这个整数的开头。注意这里必须将第一位这样处理，因为不能为0，无法和后面的\\d*合并。 \\d*则表示后续接的0个或多个数字，和前面的部分共同构成整数。 验证输入是否为负整数表达式1var reg = /^\\-[1-9]\\d*$/; 解释 一开始必须有一个负号，并且由于-在正则表达式中有特殊含义，因此转义。 [1-9]则表示匹配一个1-9的数字，作为整个这个整数的开头。注意这里必须将第一位这样处理，因为不能为0，无法和后面的\\d*合并。 \\d*则表示后续接的0个或多个数字，和前面的部分共同构成整数。 验证输入是否为非负整数（正整数 + 0）表达式1var reg = /^((\\+?[1-9]\\d*)|(0))$/; 解释 正数前面可能会有正号，\\+?限制有0个或者1个正号。 随后是一位1-9的数字[1-9]，再随后是任意多位0-9的数字\\d*，排除掉“+02”这样无意义的写法。 对于0，直接匹配(0)。 上述情况，居其一，用或|区分，整体上必须还用括号()包起来，否则无法正确过滤”-0”这种情况。 验证输入是否为非正整数（负整数 + 0）表达式1var reg = /^((\\-[1-9]\\d*)|(0))$/; 解释 对于0，直接匹配(0)。 对于小于零的负整数，开头是负号-，随后是一位1-9的数字[1-9]，再随后是任意多位0-9的数字\\d*。 上述两种情况，居其一，用或|区分，整体上必须还用括号()包起来，否则无法正确过滤”-0”这种情况。 验证输入是否为n位的数字表达式1var reg = /^\\d&#123;n&#125;$/; //具体使用时n取某个特定数字 解释{n}表示\\d数字的个数。 验证输入是否为至少n位的数字表达式1var reg = /^\\d&#123;n,&#125;$/; 解释{n,}表示\\d数字的个数范围。 验证输入是否为m~n位的数字表达式1var reg = /^\\d&#123;m,n&#125;$/; 解释{n,m}表示\\d数字的个数范围。 验证输入是否为浮点数表达式1var reg = /^(\\-?\\d+)(\\.\\d+)?$/; 解释 开始是一个负号“-”，用来匹配负数的负号，?表示非贪婪匹配模式（也就是说匹配尽量少的内容，一旦匹配上就不再考虑后面的字符串）。并且?表示匹配其前面的内容0次或者1次，这样就包括了正数和负数都可以。注意这里的-号后面不能接*或者+，必须只能至多有一个。 随后\\d+表示1位或者多位数字，代表该浮点数的整数部分。 \\.转义表示小数点。 \\d+表示1位或者多位数字，代表该浮点数的小数部分。 验证输入是否为正浮点数表达式1var reg = /^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$/; 解释 开始一位1-9的数字[1-9]，再随后是任意多位0-9的数字\\d*，表示正浮点数整数部分（且是大于等于1的浮点数）。 \\.转义表示小数点。 \\d*表示0位或者多位数字，代表该浮点数的小数部分。 再考虑0-1之间的浮点数，\\d*[1-9]\\d*的写法是为了防止0.000这种情况。 验证输入是否为负浮点数表达式1var reg = /^\\-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$/; 解释 开头匹配负号’-‘ 考虑小于等于-1的浮点数，一位1-9的数字[1-9]，再随后是任意多位0-9的数字\\d*，表示负浮点数整数部分。 \\.转义表示小数点。 \\d*表示0位或者多位数字，代表该浮点数的小数部分。 再考虑-1~0之间的浮点数，0直接匹配0。 \\.转义表示小数点。 \\d*[1-9]\\d*的写法是为了防止0.000这种情况。 验证输入是否为非负浮点数表达式1var reg = /^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$/; 解释 前半部分[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*与正浮点数一样，不再赘述。 0?表示0个或1个‘0’，这是允许的，针对的是“.666”这种写法的浮点数。 最后一部分直接匹配“0”，也是可以的。 验证输入是否为非正浮点数表达式1var reg = /^(\\-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$/; 解释 前半部分\\-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)与负浮点数一样，不再赘述。 0?表示0个或1个‘0’，这是允许的，针对的是“.666”这种写法的浮点数。 最后一部分直接匹配“0”，也是可以的。 验证输入是否为有两位小数的正实数表达式1var reg = /^([1-9]\\d*(\\.[0-9]&#123;2&#125;)?)|(0\\.[1-9][0-9])|(0\\.[0-9][1-9])$/; 解释 ([1-9]\\d*(.[0-9]{2})?)匹配大于等于1的两位小数实数 (0.[1-9][0-9])匹配0.10~0.99的两位小数实数 (0.[0-9][1-9])匹配0.01~0.99（但不含0.10 0.20 0.30 … 0.90这些数） 2,3中的处理是为了排除0.00这个数（非正） 验证输入是否为有1~3位小数的正数或负数表达式1var reg = /^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)?$/; 解释 (-)?匹配0或1个负号 \\d+表示该数的整数部分 (.\\d{1,3})?匹配小数点和1~3位小数 验证输入是否为email地址表达式1var reg = /^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$/; 解释 \\w+表明必须以字母数字下划线开头。 随后可接任意个([-+.]\\w+)的组合。组合的内容是：一个’-‘或’+’或’.’加上至少一个字母数字下划线。 @直接匹配地址符@。 @后面必须接至少一个字母数字下划线。 随后可接任意个([-.]\\w+)的组合。组合的内容是：一个’-‘或’.’加上至少一个字母数字下划线。 随后单独匹配一个\\.，表明@后面至少是二级域名。 随后仍可接任意个([-.]\\w+)的组合。注意必须以字母数字下划线结尾。 验证输入是否为中国邮政编码表达式1var reg = /^\\d&#123;6&#125;$/; 解释邮编为6位数字。另外有些地方关于邮编的正则验证是[1-9]\\d{5}(?!\\d)。我认为有两个问题： 邮编第一位可以为零，比如027200：内蒙古自治区 锡林郭勒盟 正蓝旗 最后加一个零宽负向先行断言(?!\\d)是没有必要的，想限制第六位后面没有数字，直接$即可。 验证输入是否为URL表达式1var reg = /^$/; 解释URL的灵活性很强，因此不好找到一种能包罗万象的匹配方式，上述提供的只能说可以应对大部分，但使用时要注意，如果加上了这个限制反而导致用户本来正确合理的输入无法通过验证进而提交表单，那么不如不用。 验证输入是否为身份证号码表达式1var reg = /^(\\d&#123;15&#125;$|^\\d&#123;18&#125;$|^\\d&#123;17&#125;(x|X))$/; 解释 早期身份证号码为15位，均为数字；后来增加为18位编码，最后一位是校验位，可能出现“10”，对应地采用罗马字母X表示。 分别验证了15位数字、18位数字、17位数字+字母x/X三种情况。要注意的是每种情况必须都写结束符$，否则只要大于等于15位都会匹配成功。 以上正则验证只能说是对数字位数和是否有字母做出了限定，但并不能详细校验是否符合规则-比如地区编号，性别等，这些超出了正则的验证范围（或者说正则解决起来反而会变得麻烦），这时候，想进一步验证输入，要采取更详细的办法，详见JavaScript 18位身份证验证及身份证号码规则。 验证输入是否为一年的12个月表达式1var reg = /^(0?[1-9]|1[0-2])$/; 解释 0?这种写法保证了比如9、09都可以被接受，而不是非得两位。 10，11，12月单独处理。 验证输入是否为一月的31天表达式1var reg = /^(0?[1-9]|(1|2)[0-9]|3[0-1])$/; 解释0?这种写法保证了比如9、09都可以被接受，而不是非得两位。 验证输入是否为YYYY-MM-DD格式的日期表达式1var reg = /^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/; 解释 考虑了平年闰年。 (?:(?!0000)[0-9]{4}匹配年份。2.1 ?:表明这是非捕获分组，后面括号匹配到的内容不会被存入内存中，这样是为了提高匹配效率和性能（后面大量出现?:，都是这个作用）。2.2 ?!表明这是零宽负向先行断言，表明在此位置后面的不是“0000”才会匹配，结合[0-9]{4}来看，这是为了去掉年份为“0000”的。 后面分多种情况匹配了月和日： 3.1 “(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)” 3.1.1 “?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])” 3.1.1.1 “?:(?:0[1-9]|1[0-2])” 匹配01-09月，以及10-12月。 3.1.1.2 “(?:0[1-9]|1[0-9]|2[0-8])” 匹配01-09日，10-19日，20-28日。这些是任何一年的任何一个月都会有的日期。 3.1.2 “(?:0[13-9]|1[0-2])-(?:29|30)” 3.1.2.1 “(?:0[13-9]|1[0-2])” 匹配01月、03-09月，以及10-12月。也就是除去02月，考虑到02月只有28/29天。 3.1.2.2 “(?:29|30)” 当月份匹配01月、03-09月，以及10-12月时，对应的日就可以有29、30日。 3.1.3 “(?:0[13578]|1[02])-31)” 3.1.3.1 “(?:0[13578]|1[02])” 匹配01,03,05,07,08,10,12月，这些月份会有31号。 3.1.3.2 “-31” 匹配31日。 3.2 “(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29” 3.2.1 “(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)” 3.2.1.1 “(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])” 从3.2开始是匹配一些特殊的年份-闰年。即年份“能被400整除”或者“能被4整除且不能被100整除”的。先考虑“能被4整除且不能被100整除”：前两位0-9皆可。后两位只要不是“00”，就能保证不被100整除，因此只需要考虑后两位被4整除的情况，也就是考虑01-99之中能被4整除的有哪些，即(?:0[48]|[2468][048]|[13579][26])。 3.2.1.2 “(?:0[48]|[2468][048]|[13579][26])00” 再考虑“能被400整除”的，后两位肯定是00，考虑前两位。只要前两位能被4整除即可，也即(?:0[48]|[2468][048]|[13579][26])。 3.2.2 “-02-29” 处理完年份后，即得到所有的闰年后，月日就是固定的02-29。 验证输入是否为YYYY-MM-DD hh:mm:ss格式的日期表达式1var reg = /^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29) (([0-1][0-9])|(2[0-3]))\\:[0-5][0-9]\\:[0-5][0-9]$/; 解释 YYYY-MM-DD部分与上面相同，不再赘述。 (([0-1][0-9])|(2[0-3]))整体是一个分组，要加括号，匹配时：00-23 [0-5][0-9]，匹配分：00-59 [0-5][0-9]，匹配秒：00-59 验证输入是否为hh:mm:ss格式的时间表达式1var reg = /^(([0-1][0-9])|(2[0-3]))\\:[0-5][0-9]\\:[0-5][0-9]$/; 解释与上面的hh:mm:ss相同，不再赘述。 验证输入是否为手机号码表达式1var reg = /^1[3|4|5|7|8]\\d&#123;9&#125;$/; 解释 号段分布中国移动号段：134 135 136 137 138 139 147 150 151 152 157 158 159 178 182 183 184 187 188中国联通号段：130 131 132 145 155 156 171 175 176 185 186中国电信号段：133 149 153 173 177 180 181 189虚拟运营商:170 第一位匹配1即可。 第二位从上面的分布看有3,4,5,7,8。 后面的9位可以是任意9位数字。 该正则基于以上号段，号段可能会更新，因此相应正则表达式也需要调整。 验证输入是否为中国座机号码表达式1var reg = /^\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;$/; 解释 考虑区号3位，电话号8位的情况，格式示例010-62281100 考虑区号4位，电话号7位的情况，格式示例0532-1111111 考虑区号4位，电话号8位的情况，格式示例0571-88856088 验证输入是否为IPV4地址表达式1var reg = /^\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b$/; 解释 \\b代表着单词的开头或结尾，也就是单词的分界处。此处使用的意思是IP地址前后要是“分开的”，没有和其他任何内容连在一起 “(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}”IPV4格式为“xxx.xxx.xxx.xxx”,这部分匹配前三个，还带上了点号”.”。一共考虑了这几种情况： 2.1 [01]?[0-9][0-9]?: 可能只有一位，如0.0.0.0；可能两位：如10.3.8.211；可能三位，如121.43.160.59 2.2 2[0-4][0-9]: 考虑200~249的情况 2.3 25[0-5]: 考虑250-255的情况 验证输入是否为IPV6地址表达式1var reg = /^(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9]))$/; 解释验证输入是否为密码要求的格式表达式1var reg = /^[a-zA-Z]\\w&#123;5,19&#125;$/; 解释密码格式要求不是固定的，上述只是其中一种：以字母开头，只能包含大小写字母、数字、下划线。长度在6~20位。 验证输入密码安全强度表达式1var reg = /^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;15,20&#125;$/; 解释1.”.”在正则中表示“元字符”，它可以匹配除”\\n”以外的任何字符。2.”?=pattern”是一个零宽正向先行断言，紧接该位置之后的字符序列能够匹配pattern。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。3.”(?=.\\d)(?=.[a-z])(?=.*[A-Z])”这段表示在有任意个除”\\n”以外的任何字符的同时，密码中必须包括数字，大小写字母。4.多长的密码算“高强度”，视需求而定，这里取15位以上为高强度。 匹配首尾空白字符表达式1var reg = /^\\s*|\\s*$/; 解释\\s匹配任何空白字符，包括空格、制表符、换页符、回车符、换行符等等。等价于 [\\f\\n\\r\\t\\v]。 匹配中文标点符号表达式1var reg = /^[\\u3002|\\uff1f|\\uff01|\\uff0c|\\u3001|\\uff1b|\\uff1a|\\u201c|\\u201d|\\u2018|\\u2019|\\uff08|\\uff09|\\u300a|\\u300b|\\u3008|\\u3009|\\u3010|\\u3011|\\u300e|\\u300f|\\u300c|\\u300d|\\ufe43|\\ufe44|\\u3014|\\u3015|\\u2026|\\u2014|\\uff5e|\\ufe4f|\\uffe5]+$/; 解释上述表达式匹配了如下常见的中文标点符号：。 ？ ！ ， 、 ； ： “ ” ‘ ‘ （ ） 《 》 〈 〉 【 】 『 』 「 」 ﹃ ﹄ 〔 〕 … — ～ ﹏ ￥ 匹配邮箱地址表达式123var reg = /^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$/;var reg = /^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/ 解释前一种显式写明构成email地址的字符为字母大小写，数字和下划线；后一种使用‘\\w’，简洁地表示了字符匹配，并且，考虑到了邮箱名有“.”连接的情况，比如：gaochang.gcidea@gmail.com","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www.gcidea.info/categories/正则表达式/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"正则","slug":"正则","permalink":"http://www.gcidea.info/tags/正则/"}]},{"title":"前端优化：[dns-prefetch] DNS预解析","slug":"fe-dns-prefetch","date":"2017-01-04T08:27:56.000Z","updated":"2018-12-12T16:08:46.740Z","comments":true,"path":"2017/01/04/fe-dns-prefetch/","link":"","permalink":"http://www.gcidea.info/2017/01/04/fe-dns-prefetch/","excerpt":"","text":"背景 对提升网页性能，提高加载速度和用户体验的不断重视。 定义与优势 DNS Prefetch，即DNS预获取，是前端优化的一部分。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。一般来说，在前端优化中与 DNS 有关的有两点： 减少DNS的请求次数 进行DNS预获取 现在大多数新浏览器已经针对DNS解析进行了优化，典型的一次DNS解析需要耗费20-120毫秒，减少DNS解析时间和次数是个很好的优化方式。DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能 减少用户的等待时间，提升用户体验 。 默认情况下浏览器会对页面中和当前域名（正在浏览网页的域名）不在同一个域的域名进行预获取，并且缓存结果，这就是隐式的 DNS Prefetch。如果想对页面中没有出现的域进行预获取，那么就要使用显示的 DNS Prefetch 了。 实践写法 DNS Prefetch 应该尽量的放在html文档的前面。具体使用方法如下：12345&lt;meta http-equiv=\"x-dns-prefetch-control\" content=\"on\"&gt;&lt;link rel=\"dns-prefetch\" href=\"xxxxx\"&gt;&lt;link rel=\"dns-prefetch\" href=\"xxxxx\"&gt;&lt;link rel=\"dns-prefetch\" href=\"xxxxx\"&gt;... ... 在Chrome中进行观察 在Chrome浏览器地址栏输入”about:dns”可查看当前浏览器的预解析数据。举例如下：1.今日头条 2.Github 3.新浪微博 4.阿里云","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://www.gcidea.info/categories/HTTP/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"前端工程化","slug":"前端工程化","permalink":"http://www.gcidea.info/tags/前端工程化/"},{"name":"HTTP","slug":"HTTP","permalink":"http://www.gcidea.info/tags/HTTP/"}]},{"title":"React的state初始化及其在dva框架中的具体表现","slug":"react-state-initialize","date":"2017-01-02T05:54:23.000Z","updated":"2018-12-12T16:07:45.954Z","comments":true,"path":"2017/01/02/react-state-initialize/","link":"","permalink":"http://www.gcidea.info/2017/01/02/react-state-initialize/","excerpt":"","text":"前言 本篇结合在使用dva框架进行React应用开发过程中遇到的问题，简要分析React中state的机制和Redux对state的状态管理。 使用dva框架开发时遇到的一个问题 关于dva框架的基本结构和开发模式，在之前的文章中已经有所提及，见React开发框架Dva.js项目结构简单小结。下面的描述直接基于框架中的概念。 问题现象描述确定接口所需数据结构 在进行一个应用模块的开发，与后端确立的数据接口返回数据项格式如下：123456789101112131415161718192021222324252627282930313233343536373839404142&#123; \"status\": 200, \"message\": \"查询成功\", \"data\": &#123; \"advertisement_index_top\":[ &#123; \"id\": \"99\", \"name\": \"xxx\", \"path\": \"xxx\", \"url\": \"xxx\" &#125; ], \"article_index_top\":[ &#123; \"id\": \"68\", \"content\": \"xxx\", \"title\": \"xxx\", &#125; ], \"advertisement_index_middle\":&#123; \"id\": \"99\", \"name\": \"xxx\", \"subtitle\":\"xxx\", \"path\": \"xxx\", \"url\": \"xxx\", \"count_down\": \"xxx\", &#125; , \"live_index_bottom\":[ &#123; \"id\": \"1\", \"abstract\": \"xxx\", \"dispatch_time\": \"xxx\", \"tag\": \"xxx\", \"color\": \"xxx\", \"path\":\"xxx\", \"nickname\":\"xxx\", \"avatar\":\"xxx\", &#125; ] &#125;&#125; model的定义 根据如上的数据接口，进行了模块数据model层的设计，可以看出返回的数据项结构是比较复杂的，整体有4项，其中三项是数组，每个数组中是若干个对象；另一个是一个单独的对象。在model设计的时候，对于store中的state，最开始只声明了最外层的4个变量，见如下第4行开始的state声明：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152export default &#123; namespace: \"homePage\", state: &#123; advertisement_index_top: [], article_index_top: [], advertisement_index_middle: &#123;&#125;, live_index_bottom: [], &#125;, subscriptions: &#123; setup(&#123;dispatch, history&#125;) &#123; history.listen(location =&gt; &#123; if(location.pathname === '/')&#123; dispatch(&#123; type: 'query', payload: &#123;&#125; &#125;) &#125; &#125;) &#125; &#125;, effects: &#123; *query(&#123;payload&#125;, &#123;call, put&#125;) &#123; try &#123; const data = yield call(query, parse(payload)); if(data &amp;&amp; data.status == \"200\") &#123; yield put(&#123; type: \"queryFinished\", payload: &#123; advertisement_index_top: data.data.advertisement_index_top, article_index_top: data.data.article_index_top, advertisement_index_middle: data.data.advertisement_index_middle, live_index_bottom: data.data.live_index_bottom, &#125; &#125;) &#125; else &#123; yield put(&#123; type: 'queryFinished' &#125;); throw data; &#125; &#125; catch(e) &#123; yield put(&#123; type: \"queryFinished\"&#125;); throw new Error(\"查询失败，请重试。\"); &#125; &#125;, &#125;, reducers: &#123; &#125;,&#125;; 容器组件(container component)的定义(代码有省略)1234567891011121314151617181920212223242526272829303132import React, &#123; Component, PropTypes &#125; from 'react';import &#123; connect &#125; from 'dva';import &#123; Link &#125; from 'dva/router';import styles from './HomePage.less';import ... ...function HomePage(&#123; location, dispatch, homePage &#125;) &#123; const &#123; advertisement_index_top, article_index_top, advertisement_index_middle, live_index_bottom, &#125; = homePage; return ( &lt;div&gt; ... ... &lt;/div&gt; );&#125;HomePage.propTypes = &#123; homepage: PropTypes.object, location: PropTypes.object, dispatch: PropTypes.func,&#125;;function mapStateToProps(&#123; homePage &#125;) &#123; return &#123; homePage &#125;;&#125;export default connect(mapStateToProps)(HomePage); 异步请求模块上面涉及到的dispatch的effects异步请求，与一般结构一致，不再描述。 进行测试，出现问题按如上步骤进行测试，报错如下: 问题分析 上面所报错误并不是错误的直接原因，而是由真正错误所引发的后续的初始化和渲染错误。那么具体过程是怎样的，需要通过断点单步调试：1.组件路由成功注册后，订阅的路由监听事件检测到路由匹配，dispatch出查询事件action。 这一步没有问题，是框架执行的正常环节。 2.上一步dispatch出查询action交付异步effects中的query函数，将调用真正的查询接口。 这一步没有问题，是框架执行的正常环节。 3.请求到达request函数，由fetch将请求发出。 这一步没有问题，是框架执行的正常环节。 4.以上3步，是model中的执行流程，按照dva框架的规定，接下来将按照router进行组件路由匹配，此处匹配到了HomePage组件。 问题就出在这里。 可以看到，变量homePage中有4个字段没错，但是内容却都是空数组或者空对象，这样后续的子组件会由于拿不到正常数据（是undefined）而报出各种错误。然而通过查看网络请求，我们可以看到数据是成功请求了的： 为什么请求返回的数据没有能够正常更新到state中去？ 按一般想法，上面model中定义的更新事件：1234567891011if(data &amp;&amp; data.status == \"200\") &#123; yield put(&#123; type: \"queryFinished\", payload: &#123; advertisement_index_top: data.data.advertisement_index_top, article_index_top: data.data.article_index_top, advertisement_index_middle: data.data.advertisement_index_middle, live_index_bottom: data.data.live_index_bottom, &#125; &#125;)&#125; 不就会将data.data中取出的四个变量赋值给state中的4个变量吗？那这样的话，像上面写的那样，state初始化时候直接给4个变量赋值为[]或者{}好像没什么问题（反正4个变量内部的字段会完整赋值过去）。但是问题就产生在这里，这是由于对react redux对状态管理的机制不够了解造成的。一句话来概括，“state不是立即更新的，而是通过一个队列机制实现异步更新”。 为了更好说明这一点，我们看一下dva框架的入口文件index.js，了解执行过程：1234567891011121314151617181920212223242526272829303132import './index.html';import 'lib-flexible';import './index.less';import dva from 'dva';import &#123; message &#125; from 'antd';import &#123; hashHistory &#125; from 'dva/router';// 1. Initializeconst app = dva(&#123; history: hashHistory, //全局错误处理配置 onError(e) &#123; message.config(&#123; top: 8, duration: 3, &#125;); message.error(e.message, 3); &#125;,&#125;);// 2. Plugins//app.use(&#123;&#125;);// 3. Modelapp.model(require('./models/homePage'));// 4. Routerapp.router(require('./router'));// 5. Startapp.start('#root'); 如前面大篇幅描述的，第三步引入model执行完成后，在当前调用栈中将立即进入第四步去执行react-router相关的匹配。此时第三步model相关逻辑虽然执行完成了，但是由其发出的异步操作并没有执行完成。因此，进入第四步去执行，并且路由成功找到HomePage组件的时候，这时候HomePage组件拿到的homePage变量并不是真正向后端请求回来的数据，而是model中的state初始值，也就是那些空对象或者空数组。错误就在这里。 为了证明这一点，我们修改一下model中的state初始值：12345678910111213state: &#123; advertisement_index_top: [ &#123; id: \"1\", name: \"12\", path: \"123\", url: \"1234\", &#125; ], article_index_top: [], advertisement_index_middle: &#123;&#125;, live_index_bottom: [],&#125;, 再次调试可以看到HomePage组件拿到的homePage变量如下： 问题解决 由上述过程了解了问题所在，下面就要进行修改—将state中所有将要从后台取到的变量全部进行初始化，而不只是最外层。12345678910111213141516171819202122232425262728293031323334353637state: &#123; advertisement_index_top: [ &#123; id: \"\", name: \"\", path: \"\", url: \"\", &#125; ], article_index_top: [ &#123; id: \"\", content: \"\", title: \"\", &#125; ], advertisement_index_middle: &#123; id: \"\", name: \"\", subtitle:\"\", path: \"\", url: \"\", count_down: \"\", &#125;, live_index_bottom: [ &#123; id: \"\", abstract: \"\", dispatch_time: \"\", tag: \"\", color: \"#666FFF\", path:\"\", nickname:\"\", avatar:\"\", &#125; ],&#125;, 这样的话，当程序执行到HomePage组件内部的时候，就不会因为空值而报错： 并且由进一步的调试可以知道，实际上是在上图这个断点之后，请求数据才返回回来的（这个先后过程不好通过文字表述，但经过实际调试是这样。）： 数据返回后，再分发一个更新state的action：reducers中的queryFinished： 可以看到payload中的数据长度已经不是最初的“1”了，而是“4”、“5”、“10”等，也就是真正从服务器取回的数据。通过这个reducer去更新state，就相当于原生react写法中的setState()函数，因此state更新后react框架会自动进行UI的更新，把真实数据渲染在页面上。 该问题的另一个规范化解决方案-在service层做好数据adaptor转换 详见React开发框架Dva.js项目结构简单小结#2.3.6. services","categories":[{"name":"React","slug":"React","permalink":"http://www.gcidea.info/categories/React/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://www.gcidea.info/tags/前端框架/"},{"name":"前端工程化","slug":"前端工程化","permalink":"http://www.gcidea.info/tags/前端工程化/"},{"name":"React","slug":"React","permalink":"http://www.gcidea.info/tags/React/"}]},{"title":"JavaScript中的对象、constructor属性、prototype属性对比分析","slug":"js-constructor-prototype","date":"2016-12-31T15:13:37.000Z","updated":"2018-12-12T16:08:35.114Z","comments":true,"path":"2016/12/31/js-constructor-prototype/","link":"","permalink":"http://www.gcidea.info/2016/12/31/js-constructor-prototype/","excerpt":"","text":"前言 首先想说的是，这篇文章的题目准确怎么定我就考虑了不少时间。想过“JavaScript中的对象及其constructor属性和prototype属性”，想过“JavaScript中的对象、构造函数对象(constructor)和原型对象(prototype)”等等，但总觉得不够清楚。说实话现有的这个题目也不一定是很好的，只是相比较之下，选择一个“三者相对独立”的说法，这样就不会有先入为主的感觉。因为三者的关系并不是简单的“constructor和prototype是对象的两个属性”，并且“到底把constructor看作属性还是构造函数对象”，“到底把prototype看作属性还是原型对象”，这些问题并没有一个固定答案，它们有着互相渗透的关系。更多地我们应该关注这些名词到底想要描述怎样的问题。本文我就结合《JavaScript权威指南》和《JavaScript高级程序设计》两书进行总结和分析，可能有一些还不正确的理解，需要进一步探究。 另外，要说明的是，不可能只是干巴巴地描述这3个概念，因为它们本质上涉及的是JavaScript面向对象编程中的“类与对象”、“类的继承”等问题，因此本文是从这些方面进行组织的，constructor属性、prototype属性的分析包含其中。 JavaScript对象简述 定义 在之前关于null和undefined的讨论中提到过，JavaScript中的数据类型分为两类：原始类型和对象类型。本篇主要要总结的就是对象类型。对象是JavaScript中十分重要且常用的概念。 对象是一种复合值：是多个属性的集合，每个属性都以键/值对的形式体现。其中对于属性值为函数的属性，一般将其称作方法。函数、数组等数据组织形式都是对象的一种特殊表现形式。 属性类型 既然对象是属性的集合，那么有必要对属性进行分类。具体如下：1.数据属性 示例1234var student = &#123; name: \"gaochang\", university: \"BUPT\" &#125; 以上对象中的name和university两个属性就是数据属性，对它们可以进行数据的读取和写入。对于这类属性而言，它们又具备4个“特性”： configurable：可配置性。 是指：能否通过delete删除属性，能否对该属性的这些特性进行修改，能否把数据属性修改成访问器属性（访问器属性稍候会提到）。默认true。 enumerable：可枚举性。 是指：该数据属性能否通过for-in循环遍历到。默认为true。 writable：可写性。 是指：是否能够修改该属性的属性值。默认为true。 value：值。 是指： 该属性的具体属性值，比如name属性的value：”gaochang”。 2.访问器属性 示例12345678910111213var book = &#123; name: \"Professional JavaScript for Web Developers\", _isbn: \"978-7-115-27579-0\" &#125;Object.defineProperty(book, \"isbn\", &#123; get: function() &#123; return this._isbn; &#125; set: function(str) &#123; this._isbn = str; &#125;&#125;) 以上对象中的_isbn属性就是访问器属性（前缀下划线表示是内部属性）。特别地，访问器属性不能直接定义，必须借助Object.defineProperty()方法。对于这类属性而言，它们又具备4个“特性”： configurable：可配置性。 是指：能否通过delete删除属性，能否对该属性的这些特性进行修改，能否把数据属性修改成访问器属性（访问器属性稍候会提到）。默认true。 enumerable：可枚举性。 是指：该数据属性能否通过for-in循环遍历到。默认为true。 get：取值。 是指：读取属性时调用。 set：赋值。 是指：赋值时调用。 对象共有的“特性” 除了属性之外，每个对象还具有3个“特性”： 原型（prototype）：可以理解成一个指针，指向另一个对象-原型对象，后面将做详细讨论。 类（class）：是一个标识对象类型的字符串。 扩展标记（extensible flag）：ES5新增，表明是否可以向该对象添加新属性。 JavaScript对象创建方式 了解了对象的基本概念后，就可以进一步分析对象的创建方式。在《JavaScript高级程序设计》中具体分为7种： 工厂模式 构造函数模式 原型模式 组合模式（构造函数+原型） 动态原型模式 寄生构造函数模式 稳妥构造模式 而在《JavaScript权威指南》中，对象创建方式分为3种： 对象字面量创建（var obj = {}） 关键字new构造函数创建 Object.create()基于原型创建 分为这3类，虽说内容和上面的基本一致，但考虑问题的角度不同，个人感觉没有层层递进（《JavaScript权威指南》的分类标准是从本质上区分了创建对象的3种方式，但不利于初次理解）。因此建议理解的过程按照《JavaScript高级程序设计》进行，之后可以再看《JavaScript权威指南》补缺。本文也是按照《JavaScript高级程序设计》进行总结。 对于7种分类的方式而言，其基础还是“构造函数模式”和“原型模式”两种，其他的都是因为解决之前的某种缺陷而逐步演进得来的，因此下面重点分析这两个。 创建对象-构造函数模式（constructor属性相关）工厂模式与构造函数模式的对比 在看构造函数模式之前，先看一个工厂模式的例子，从而和构造函数模式进行对比。 使用工厂模式创建对象123456789101112function createNews(title, subtitle)&#123; var o = new Object(); o.title = title; o.subtitle = subtitle; o.release = function() &#123; alert(o.title + \"--\" + o.subtitle); &#125; return o;&#125;var firstNews = createNews(\"important news\", \"strategy\");var secondNews = createNews(\"interesting news\", \"strategy\"); 接下来看看用构造函数模式如何重构上述代码： 使用构造函数模式创建对象12345678910function News(title, subtitle)&#123; this.title = title; this.subtitle = subtitle; this.release = function() &#123; alert(this.title + \"--\" + this.subtitle); &#125;&#125;var firstNews = new News(\"important news\", \"strategy\");var secondNews = new News(\"interesting news\", \"strategy\"); 对比可得构造函数模式的特点： 函数名一般首字母大写，代表这是一类特殊的函数-构造函数； 构造函数内并不直接新建对象，所以自然也不会返回初始化好的对象； 使用构造函数时明确要用new关键字，具体的调用经历了如下四个步骤： new创建一个新对象 将构造函数的作用域赋给这个新对象 执行构造函数中的代码，添加属性 得到初始化好的新对象 对象的constructor属性 以上构造函数模式代码中的firstNews和secondNews两个对象分别保存着News的一个实例（是不同的）。这里就要提到constructor了。firstNews和secondNews两个对象各自有一个constructor属性-构造函数属性。如下所示： 换句话说，由构造函数创建的对象，它有一个constructor属性，属性值为构造函数本身（指向构造函数），如下所示： 而对于使用工厂模式创建的对象，也具有constructor属性，只不过直接指向“最高层”的对象Object，如下所示： 对于字面量直接创建的对象，也具有constructor属性，也是直接指向“最高层”的对象Object，如下所示： 对于Object.create()方法创建的对象，也具有constructor属性，也是直接指向“最高层”的对象Object，如下所示： 以上内容可总结如下： 任何对象都具有constructor属性。 注意，这里顺便说一下，即便是原始类型的数据，也可以调用constructor属性，原因应该是，JavaScript自动将其转换为对应的包装类型（对象），再调用相应包装类型的constructor属性（对象），如下图所示：（当然，null和undefined没有属性和方法，也就不用讨论了） 使用构造函数模式创建的对象，其constructor指向创建该对象的构造函数 其他各类对象，其constructor指向Object()函数 构造函数模式存在的缺陷 相比于工厂模式，构造函数模式有其优点—它可以准确识别创建的对象的类型。但是，它本身也存在问题：构造函数中的方法，在每个新创建的对象上都要重新实例化一次，也就是说每个对象的该方法都不是同一个实例，然而它们的作用却是相同的，这就增大了开销。 为了解决这个问题，可以采取的方法是：把构造函数中的方法单独剥离出来，提出全局作用域上的函数，而在构造函数内部仅保留对这个全局函数的引用。这样，通过构造函数创建的所有实例都是共享了同一个函数。但是，这又产生了新的问题：如果构造函数中需要很多方法，全部都提到全局作用域中，就破坏了封装性，结构很不好。对于此问题，则需要采用下面提到的原型模式了。 创建对象-原型模式（prototype属性相关）原型模式的案例 使用原型模式模式创建对象12345678910111213141516function News()&#123;&#125;News.prototype.title = \"important news\";News.prototype.subtitle = \"strategy\";News.prototype.release = function() &#123; alert(this.title + \"--\" + this.subtitle);&#125;var firstNews = new News();firstNews.title; //\"important news\"var secondNews = new News();secondNews.subtitle; //\"strategy\"firstNews.title = \"interesting news\";firstNews.title; //\"interesting news\" 每个函数其实都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象-原型对象，而这个对象的作用是包含好可以由特定类型的实例所共享的属性和方法。因此，如上所示，构造函数是空的也可以（但必须有这个构造函数），需要共享的内容写在prototype对象上就好了。 理解原型对象（prototype属性） 到底什么是原型对象呢？ 首先，我们看看上述例子中通过原型模式创建的对象实例firstNews的原型对象是什么： 这里发现显示的结果是undefined？原型对象没有定义吗？不是这样的。是因为在JavaScript中，prototype是一个内部属性，没有提供标准的直接访问方式，但是在各个主流浏览器的实现中，为我们提供了__proto__属性，可以帮我们“窥探”一个对象的原型对象。如下所示： 从上图我们能清楚地看到firstNews的原型对象的结构，并且和constructor联系起来了： 原型对象有一个constructor属性，它反过来指向了创建该实例的构造函数 原型对象本身有我们自定义的两个属性title、subtitle和一个方法release() 从另一个角度（“继承”的角度），原型对象自己可以看做是一个实例对象，它自己也有prototype属性（指向它的原型对象），并且通过__proto__表现出来。 其次，上述是创建了函数对象，那么对于其他几种方式创建的对象呢？我们来看看： 通过字面量直接创建对象 可以看出，对象的prototype属性时存在的，并且由于没有构造函数，它的constructor属性直接指向了Object,也就是说字面量对象是由Object()直接创建的。 通过Object.create()创建对象 可以看出，实例对象o的原型对象是{x:1, y:2}，并且不带任何诸如constructor之类的属性。原因是，根据APIObject.create((proto [, propertiesObject ]))，传入的参数就是要创建的对象的原型proto。传入的是{x:1, y:2}，因此__proto__的结果自然也就是{x:1, y:2}。 通过以上分析，可作总结：1.任何时候，只要创建一个对象，就会有prototype属性，并且大多数情况通过__proto__进行展现2.在此基础上，通过构造函数创建对象稍有特殊（因为constructor不会直接指向Object）。只要创建了一个新的函数对象，就会根据一组特定规则为函数创建一个prototype属性，这个属性指向函数的原型对象。并且，默认的这个原型对象又会自动获取一个constructor属性，反过来指向prototype属性所在的函数（也就是构造函数）。通过以下实验可以很好理解这一点： 值得说明的是，根据之前提到的，prototype是内部属性不能直接访问（否则会报错），用__proto__可以间接访问，所以上图是通过firstNews.__proto__.constructor来测试的。但实际上我们要讨论的是firstNews.prototype.constructor，即prototype和constructor的关系，要特别注意这一点。 3.但是，要特别注意,以上所说的prototype是内部属性无法访问，是针对创建的实例对象。而对于函数对象，是可以直接访问prototype属性的，如下所示： prototype和__proto__还有更多区别，详见这篇文章JavaScript中__proto__和prototype的对比分析 4.可以通过下图更好地理解prototype和constructor的关系。 原型链操作 每次执行对象属性的读取操作时，其实就是执行了一次搜索。搜索会从实例对象本身开始，如果找到了该属性，则返回该属性的值；如果没有找到，则会根据实例对象的prototype指针找到该实例对象的原型对象，在原型对象上执行搜索。如果找到了，则返回该属性的值；如果没找到，则继续向上，根据原型对象的prototype指针向上查找… …，这样就形成了“链式结构”，也就是原型链。 关于原型链操作必须明确的是：只有在查询属性值的操作中才会感觉到原型链的存在，在修改属性值的过程中是没有原型链的概念的，也就是说修改属性值只会在实例对象中对原有属性进行覆盖，但并不会影响原型链上上层对象中的属性。通过如下过程可以理解： 某个属性属于谁？（实例 or 原型？） 根据原型链操作的分析，对象属性在实例中和原型中的表现可能是不一样的，但自然就产生了这样的需求：某个属性是属于实例还是原型？ JavaScript主要提供了以下几种方式来解决这个问题： 单独使用in操作符 格式：&quot;title&quot; in firstNews; in操作符能筛选出一个属性，无论它是在实例中还是原型中。 使用for-in循环 格式：for(var prop in firstNews){} for-in循环会返回所有可枚举的属性，无论它是在实例中还是原型中。 使用Object.keys() 格式：Object.keys(obj) Object.keys()会返回所有可枚举的属性，仅来自实例对象。 使用Object.getOwnPropertyNames() 格式：Object.getOwnPropertyNames(obj) Object.keys()会返回所有属性（无论是否可枚举），仅来自实例对象。 原型对象的重写 写法如下：123456789101112function News()&#123;&#125;News.prototype = &#123; title: \"important news\", subtitle: \"strategy\", release: function() &#123; alert(this.title + \"--\" + this.subtitle); &#125;&#125;var firstNews = new News(); 这样的写法不是另一种模式，只是为了说明一个问题。根据之前的分析，我们知道firstNews.constructor会指向构造函数本身，也就是function News(){}。那么在现在这样的写法中，firstNews.constructor还是指向function News(){}吗？答案是否定的，如下： 可以发现现在指向了function Object()，为什么呢？ 原因是，在这种写法中，直接将一个”{}”对象赋给了News.prototype，本质上是完全重写了News.prototype，而不是像之前只是给News.prototype添加属性，比如News.prototype.title。因此，News.prototype的constructor属性也就发生了变化，变成了新的”{}”对象的constructor属性，而新对象”{}”是字面量直接对象，根据之前的分析知道它的constructor属性指向function Object()，所以现在的firstNews.constructor指向了function Object()。 如果想恢复到原来的状态，可以显式声明prototype对象的constructor属性： 原型对象的动态性 根据原型链操作的分析，每一次属性获取都是一次查询，因此可以动态向原型中添加属性，并且可以立即反映出来。 但是，如果是重写整个原型对象，情况就不同了： 原生对象的原型 原生对象是指String()、Number()、Boolean()等包装类型产生的对象，它们的原型对象也是可以自定义的。但是，并不应该直接去修改这些内置类型的原型，因为可能会产生命名空间冲突，移植性差。 总结 通过上述过程，详细分析了JavaScript中对象创建的相关方法和极其重要的两个属性constructor和prototype。关于JavaScript中的“类的继承”将会在后续单独讨论（以此篇为基础）。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"JavaScript中值传递和引用传递的典例探究","slug":"js-value-copy-reference-copy","date":"2016-12-27T03:18:20.000Z","updated":"2018-12-12T16:08:29.412Z","comments":true,"path":"2016/12/27/js-value-copy-reference-copy/","link":"","permalink":"http://www.gcidea.info/2016/12/27/js-value-copy-reference-copy/","excerpt":"","text":"概述 在Javascript中，基本类型（null, undefined, number, string, boolean, symbol）是通过值传递方式进行，而复合类型（object, array, function）则是通过引用传递方式进行。 但是，由于Javascript工作机制所决定，在js中，引用指向的其实是值，而无法指向其他引用，这和其他语言中的指针并不相同。 其实，两者都可以算是“值”传递，只不过“值传递”传递的是基本类型本来的值，而“引用传递”传递的则是复合对象的地址值。 值传递案例一：12345var a = 2;var b = a;b++;b; //3a; //2 上例说明基本类型的a的值在赋值给b时，是将2这个值赋给了b，此后b++不会改变a的值。 案例二：12345var a = [1,2,3];var b = a;b.push(4);b; //[1,2,3,4]a; //[1,2,3,4] 上例说明复合类型的a在赋值给b时，是将2内存中[1,2,3,4]这个对象的引用赋给了b，因此a,b实际上操作的是一个地址中的内容。 引用传递1234567891011121314function foo(x)&#123; x.push(4); x; //[1,2,3,4] x = [4,5,6]; x.push(7); x;&#125;var a = [1,2,3];foo(a);a; //[1,2,3,4] 该例中函数foo()接收一个复合类型对象作为参数。按照引用传递的规则，可以理解为变量a所引用的对象[1,2,3]在内存中的地址被赋给了x，在foo()内部所做的操作，会直接影响到a所代表的值。但是，x = [4,5,6];相当于以字面量的形式将x所指向的内存中的地址进行了改变（一个新对象，其值为[4,5,6]），因此这部分不会体现在a中。 两者的“互相转换”1.对于符合类型的，即对象，如果想按照值传递来实现某些功能（即不影响传入的实参本身），那么就要创建一个副本。比如对于数组，使用foo(a.slice())，通过slice()方法对a进行一次浅复制。 2.对于基本类型的，如果想按照引用传递的效果实现某些功能（即能够改变传入函数并将其本身进行修改），那么就要将该值封装到一个复合类型（数组，对象等）中，然后通过引用传递的方式进行传递。如：12345678function foo(obj)&#123; obj.a = \"new value\";&#125;var bar = &#123; a : \"old value\"&#125;foo(bar);bar.a; // new value 但是，这并不是说将基本类型装箱为对应的包装类型再传入函数就可以达到这种效果：12345678function foo(x)&#123; x = x + 1;&#125;var a = 2;var b = new Number(a);foo(b);a; // 2b; // 2 原因是foo()内部在进行加法操作时候对x进行了自动拆箱。x变成了基本类型值，但是外部的b仍然指向有Number()构造出的对象，因此是2，不是加1后的3。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"JavaScript中创建对象的7种模式和实现继承的6种方式","slug":"js-7-create-object-solutions-6-inherit-solutions","date":"2016-12-20T14:40:47.000Z","updated":"2018-12-12T16:08:40.616Z","comments":true,"path":"2016/12/20/js-7-create-object-solutions-6-inherit-solutions/","link":"","permalink":"http://www.gcidea.info/2016/12/20/js-7-create-object-solutions-6-inherit-solutions/","excerpt":"","text":"前言 JavaScript是一种面向对象（OO）的语言，但由于ECMAScript没有类的概念（ES6引入关键字class），所以在js中创建对象的方法也与其他基于类的语言有所不同。本篇总结在JavaScript中创建对象的7种方法；并在此基础上，总结实现继承的6种方式。 JavaScript中对象的基本概念创建对象的2种基本方法 创建一个Object实例123456var person = new Object();person.name = \"Bob\";person.age = 24;person.greet = function()&#123; alert(this.name);&#125; 通过上述方法，创建了一个对象，并为其添加了3个属性，属性值有字符串，数字，函数。 对象字面量1234567var person = &#123; name: \"Bob\", age: 24, greet: function()&#123; alert(this.name); &#125;&#125; 创建的对象与上述相同，只不过使用{}的字面量方式创建。 属性与特性 关于属性和特性的细节，可以参考JavaScript中attribute(特性)和property(属性)的对比分析。对象就是由众多的属性(property)构成的，而每个属性(property)又具有多个特性(attribute)。这些特性(attribute)是为了实现JavaScript引擎使用的，在JavaScript语言使用中不能直接访问它们。为了表示是内部值，将各个特性(attribute)放在两对方括号[[]]中表示。 数据属性的特性1.[[Configurable]] 名称：可配置性。 默认值：true 含义：能否通过delete删除属性并重新定义；能否修改属性的这几个特性；能否把数据属性修改为访问器属性。 2.[[Enumerable]] 名称：可枚举性。 默认值：true 含义：能否通过通过for-in循环返回当前属性。 3.[[Writable]] 名称：可写性。 默认值：true 含义：能否修改当前属性的值。 4.[[Value]] 名称：值。 默认值：undefined 含义：读属性值，从这个位置读；写入属性时，保存在这个位置。 访问器属性的特性1.[[Configurable]] 名称：可配置性。 默认值：true 含义：能否通过delete删除属性并重新定义；能否修改属性的这几个特性；能否把访问器属性修改为数据属性。 2.[[Enumerable]] 名称：可枚举性。 默认值：true 含义：能否通过通过for-in循环返回当前属性。 3.[[Get]] 名称：值。 默认值：undefined 含义：读属性值时调用该函数。 4.[[Set]] 名称：值。 默认值：undefined 含义：写属性值时调用该函数。 ES5新增的关于Object的几个实用方法1.Object.defineProperty()使用示例：12345var person = &#123;&#125;;Object.defineProperty(person, \"name\",&#123; configurable: false, value: \"Bob\"&#125;) 2.Object.defineProperties()使用示例：1234567891011var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; writable: true, value: 2016 &#125;, edition: &#123; writable: true, value: 1 &#125;&#125;) 3.Object.getOwnPropertyDescriptor()使用示例：1234567891011121314var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; writable: true, value: 2016 &#125;, edition: &#123; writable: true, value: 1 &#125;&#125;)var desc = Object.getOwnPropertyDescriptor(book, \"_year\");console.log(desc.value); //2016 4.Object.getOwnPropertyNames()5.Object.isPrototypeOf()6.Object.create()7.Object.keys()8.XXX.getPrototypeOf()9.XXX.hasOwnProperty() 创建对象的7种模式工厂模式示例：12345678910111213function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson(\"A\", 25, \"teacher\");var person2 = createPerson(\"B\", 26, \"engineer\"); 说明：1.函数createPerson()就是一个工厂，该工厂内部封装了生成对象的细节（新建对象实例并初始化等） 2.正如名字表示的，通过该函数可以批量创建多个同类型对象，而不必书写大量重复代码 3.工厂模式缺点：未解决对象识别问题—无法知道对象的类型 构造函数模式示例：1234567891011function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;;&#125;var person1 = new Person(\"A\", 25, \"teacher\");var person2 = new Person(\"B\", 26, \"engineer\"); 说明：1.函数Person()未显式创建对象，且无返回值 2.使用new关键字调用构造函数 3.约定构造函数首字母大写 4.关于对象类型：12345alert(person1.constructor == Person); //truealert(person2.constructor == Person); //truealert(person1 instanceof Person); //truealert(person2 instanceof Person); //true 5.如果构造函数不像1var person1 = new Person(\"A\", 25, \"teacher\"); 这样通过new关键字来调用，而是直接1Person(\"A\", 25, \"teacher\"); 也是可以使用的，只不过生成的对象会直接添加到宿主对象上，在浏览器中就是window对象上。 6.构造函数模式缺点：由于将函数绑定到了特定的对象实例上面，每个方法都要在每个实例上重新创建一遍，浪费空间且并没有什么用处。以下可以证明这一点：1alert(person1.sayName == person2.sayName); //false 为此，我们可以让构造函数创建的对象中的方法共享函数，也就是在方法属性处不显式声明函数，而只是写明一个函数引用，将这个函数移至构造函数外部。12345678910111213function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName;&#125;function sayName()&#123; alert(this.name);&#125;;var person1 = new Person(\"A\", 25, \"teacher\");var person2 = new Person(\"B\", 26, \"engineer\"); 可是这种方法又会有新的缺点： 身在全局作用于中的函数sayName()却只能用于让构造函数调用，让全局作用域名不副实 如果构造函数有很多方法属性，那么就要在全局作用于中写很多函数，代码结构松散，毫无封装性可言 在这种情况下，考虑使用原型模式来解决。 原型模式1234567891011121314151617181920function Person()&#123;&#125;Person.prototype.name = \"Nicholas\";Person.prototype.age = 29;Person.prototype.job = \"Software Engineer\";Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); //\"Nicholas\"var person2 = new Person();person2.sayName(); //\"Nicholas\"alert(person1.sayName == person2.sayName); //truealert(Person.prototype.isPrototypeOf(person1)); //truealert(Person.prototype.isPrototypeOf(person2)); //true 原型模式的缺点：1.所有实例在默认情况下都将取得相同的值。2.由于共享属性，一旦一个对象修改，可能引发其他变量意外地受到影响。如下所示：12345678910111213141516171819202122function Person()&#123;&#125;Person.prototype = &#123; constructor: Person, name : \"Nicholas\", age : 29, job : \"Software Engineer\", friends : [\"Shelby\", \"Court\"], sayName : function () &#123; alert(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.friends.push(\"Van\");alert(person1.friends); //\"Shelby,Court,Van\"alert(person2.friends); //\"Shelby,Court,Van\"alert(person1.friends === person2.friends); //true 组合使用构造函数模式和原型模式核心：构造函数模式用于定义实例属性，原型模式用于定义方法和共享属性。12345678910111213function Person(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var friend = new Person(\"Nicholas\", 29, \"Software Engineer\");friend.sayName(); //\"Nicholas\" 以上方式是目前应用最广泛、认可度最高的方式。 动态原型模式该种方式将所有信息封装在构造函数中，通过在构造函数中“有选择”地初始化原型，来保持构造函数模式+原型模式的有点。所谓的“有选择的”，是指针对工厂模式中多次创建实例上功能相同的函数的问题，在构造函数内部通过判断实例方法的类型（即是否存在）来保证实例方法只创建一次。12345678910111213141516171819function Person(name, age, job)&#123; //properties this.name = name; this.age = age; this.job = job; //methods if (typeof this.sayName != \"function\")&#123; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; &#125;&#125;var friend = new Person(\"Nicholas\", 29, \"Software Engineer\");friend.sayName(); 寄生构造函数模式这是一种和工厂模式非常类似的方法，只不过使用时要加上关键字new，要说明的是，在构造函数内部创建的对象与构造函数的原型没有什么关系，因此不能通过instanceof操作来判断由此创建的对象的类型。123456789101112131415161718192021function SpecialArray()&#123; //create the array var values = new Array(); //add the values values.push.apply(values, arguments); //assign the method values.toPipedString = function()&#123; return this.join(\"|\"); &#125;; //return it return values; &#125;var colors = new SpecialArray(\"red\", \"blue\", \"green\");alert(colors.toPipedString()); //\"red|blue|green\"alert(colors instanceof SpecialArray); 稳妥构造函数模式与寄生模式相比，这种模式的实例方法不引用this，不用new操作符。在这种模式下，除了调用相应属性的get方法，无法访问内部变量，保证了安全性。1234567891011function Person()&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(name); &#125;; return o;&#125; 实现继承的6种方式原型链1234567891011121314151617181920212223242526272829function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty = false;&#125;//inherit from SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function ()&#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperValue()); //truealert(instance instanceof Object); //truealert(instance instanceof SuperType); //truealert(instance instanceof SubType); //truealert(Object.prototype.isPrototypeOf(instance)); //truealert(SuperType.prototype.isPrototypeOf(instance)); //truealert(SubType.prototype.isPrototypeOf(instance)); //true 原型链继承主要有以下两个问题：1.当原型包含引用类型值，一个实例对变量的修改会影响到其他变量：12345678910111213141516function SuperType()&#123; this.colors = [\"red\", \"blue\", \"green\"];&#125;function SubType()&#123; &#125;//inherit from SuperTypeSubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push(\"black\");alert(instance1.colors); //\"red,blue,green,black\"var instance2 = new SubType();alert(instance2.colors); //\"red,blue,green,black\" 2.在创建子类型的实例时，没有办法在不影响所有实例的情况下向超类构造函数传递参数。 借用构造函数核心：在子类型内部调用超类型构造函数。123456789101112131415function SuperType()&#123; this.colors = [\"red\", \"blue\", \"green\"];&#125;function SubType()&#123; //inherit from SuperType SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push(\"black\");alert(instance1.colors); //\"red,blue,green,black\"var instance2 = new SubType();alert(instance2.colors); //\"red,blue,green\" 存在的问题：1.方法都在构造函数中定义，函数复用无从谈起。2.超类型的原型中定义的方法，对子类型不可见。 组合继承核心：原型继承+借用构造函数。使用原型链实现对原型属性和方法的继承，使用借用构造函数模式实现对实例属性的继承。1234567891011121314151617181920212223242526272829303132function SuperType(name)&#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;SubType.prototype = new SuperType();SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;;var instance1 = new SubType(\"Nicholas\", 29);instance1.colors.push(\"black\");alert(instance1.colors); //\"red,blue,green,black\"instance1.sayName(); //\"Nicholas\";instance1.sayAge(); //29var instance2 = new SubType(\"Greg\", 27);alert(instance2.colors); //\"red,blue,green\"instance2.sayName(); //\"Greg\";instance2.sayAge(); //27 原型式继承在给出一个想要作为基础的（即被继承）的对象的条件下，可以使用这种方式实现继承。但其问题和原型链继承类似，不同实例会共享属性。1234567891011121314151617181920function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;var person = &#123; name: \"Nicholas\", friends: [\"Shelby\", \"Court\", \"Van\"]&#125;;var anotherPerson = object(person);anotherPerson.name = \"Greg\";anotherPerson.friends.push(\"Rob\");var yetAnotherPerson = object(person);yetAnotherPerson.name = \"Linda\";yetAnotherPerson.friends.push(\"Barbie\");alert(person.friends); //\"Shelby,Court,Van,Rob,Barbie\" ES5的Object.create(obj)方法对此做出了规范：1234567891011121314var person = &#123; name: \"Nicholas\", friends: [\"Shelby\", \"Court\", \"Van\"]&#125;;var anotherPerson = Object.create(person);anotherPerson.name = \"Greg\";anotherPerson.friends.push(\"Rob\");var yetAnotherPerson = Object.create(person);yetAnotherPerson.name = \"Linda\";yetAnotherPerson.friends.push(\"Barbie\");alert(person.friends); //\"Shelby,Court,Van,Rob,Barbie\" 寄生式继承该种方式和原型式继承紧密相关，思路与寄生构造函数和工厂模式类似。1234567function createAnother(original) &#123; var clone = object(original); clone.sayHi = function() &#123; alert(\"hi\"); &#125; return clone;&#125; 和构造函数模式类似，函数无法复用会降低效率。 寄生组合式继承组合继承的问题在于，会调用两次超类型的构造函数：1.创建声明子类型原型的时候，这时候会在子类型原型上具有一组超类型的实例变量。2.调用子类型构造函数的时候，这时候会在子类型实例上具有一组超类型的实例变量，他们会屏蔽掉超类上的实例变量（原型链查找机制）下面的寄生组合式继承可以避免这个问题： 12345function inheritPrototype(subType, superType ) &#123; var prototype = object(superType.prototype); prototype.constructor = subType; subType.prototype = prototype;&#125; 解释：1.创建超类型的一个副本2.添加constructor属性，从而弥补因为重写原型而失去的默认的prototype属性3.将新创建的超类副本赋值给子类原型 好处：只在var prototype = object(superType.prototype);时获取了超类型的属性，避免了在子类实例化时候重写这些不必要的属性。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"关于JavaScript生成器generator和yield的一些理解","slug":"js-yield","date":"2016-12-19T13:07:31.000Z","updated":"2018-12-12T16:08:29.039Z","comments":true,"path":"2016/12/19/js-yield/","link":"","permalink":"http://www.gcidea.info/2016/12/19/js-yield/","excerpt":"","text":"综述 Generator（生成器）函数是ES6提供的一种异步编程解决方案，而yield则是配合生成器函数使用的。 Generator函数定义 function* 声明（function关键字后跟一个星号）定义一个generator（生成器）函数，返回一个Generator对象。 语法function* name([param[, param[, ... param]]]) { statements }其中： name函数名 param传入函数的参数名，一个函数至多可有255个参数。 statements函数的主体 注：ES6没有规定，function关键字与函数名之间的星号必须写在哪个位置，因此下面的写法都正确，但是还是推荐上述写法。123function * name([param[, param[, ... param]]]) &#123; statements &#125;function *name([param[, param[, ... param]]]) &#123; statements &#125;function*name([param[, param[, ... param]]]) &#123; statements &#125; 描述 生成器是一种可以从中退出并在之后重新进入的函数。生成器的环境（绑定的变量）会在每次执行后被保存，下次进入时可继续使用。调用一个生成器函数并不马上执行它的主体，而是返回一个这个生成器函数的迭代器（iterator）对象。当这个迭代器的next()方法被调用时： 生成器函数的主体会被执行直至第一个yield表达式，该表达式定义了迭代器返回的值； 或者，被 yield*委派至另一个生成器函数。 next()方法返回一个对象，该对象有一个value属性，表示产出的值，和一个done属性，表示生成器是否已经产出了它最后的值。 示例12345678910111213function* idMaker()&#123; var index = 0; while(index&lt;3) yield index++;&#125;var gen = idMaker();console.log(gen.next().value); // 0console.log(gen.next().value); // 1console.log(gen.next().value); // 2console.log(gen.next().value); // undefined// ... yield定义 yield 关键字用来暂停和继续一个生成器函数。 语法yield [[expression]]; expression用作返回值. 如果忽略, 将返回 undefined . 描述 yield关键字使生成器函数暂停执行，并返回跟在它后面的表达式的当前值。可以把它想成是return关键字的一个基于生成器的版本。yield 关键字实际返回一个对象，包含两个属性value和done。value属性为yield expression的值,done是一个布尔值用来指示生成器函数是否已经全部完成。一旦在yield expression处暂停, 除非外部调用生成器的next()方法，否则生成器的代码将不能继续执行。这使得可以对生成器的执行以及渐进式的返回值进行直接控制。 示例同上示例。 yield*定义 在生成器中，yield* 可以把需要yield的值委托给另外一个生成器或者其他任意的可迭代对象。 语法yield* [[expression]]; expression任意的可迭代对象。 描述 yield* 一个可迭代对象，就相当于把这个可迭代对象的所有迭代值分次yield出去。yield* 表达式本身的值就是当前可迭代对象迭代完毕（当done为true时）时的返回值。 示例1234567891011121314151617181920function* g1() &#123; yield 2; yield 3; yield 4;&#125;function* g2() &#123; yield 1; yield* g1(); yield 5;&#125;var iterator = g2();console.log(iterator.next()); // &#123; value: 1, done: false &#125;console.log(iterator.next()); // &#123; value: 2, done: false &#125;console.log(iterator.next()); // &#123; value: 3, done: false &#125;console.log(iterator.next()); // &#123; value: 4, done: false &#125;console.log(iterator.next()); // &#123; value: 5, done: false &#125;console.log(iterator.next()); // &#123; value: undefined, done: true &#125; 注意事项 yield语句不能用在普通函数（即不带有*的function）中，否则会报错。 Generator函数可以不用yield语句，这时就变成了一个单纯的暂缓执行函数。 Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。 参考文档：阮一峰 ECMAScript6入门、MDN官方文档。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"Base64编码探究","slug":"base64","date":"2016-12-17T03:20:30.000Z","updated":"2018-12-12T16:08:55.129Z","comments":true,"path":"2016/12/17/base64/","link":"","permalink":"http://www.gcidea.info/2016/12/17/base64/","excerpt":"","text":"概念 Base64编码是网络传输中的一种常见编码方式。可用于传输任意的8bit(字节Byte)数据，经过编码后的数据不是直接可读的，但也由此保证了一定的安全性和很好的可移植性。这种编解码的算法十分简单，编码后的数据大小仅增加三分之一左右(原因后续讲到)，因而不会对传输造成过大压力。 我们需要明确的概念是，Base64编码本质上是将二进制数据编码为文本字符。而这些二进制数据的来源则可能有很多，比如： 本来就是二进制数据 本来是英文字母或数字，则有对应的ASCII编码，ASCII表一般会表示为十进制和十六进制的值，自然也有对应的二进制值 本来是汉字，可能是多种编码得到的，比如采用UTF-8编码得到，则该汉字的UTF-8编码的值可以用二进制表示 … 上述各种类型的文本转换为二进制后，就可以使用Base64进行编码了。 官方规范 Base64编码是作为MIME多用途互联网邮件扩展标准的一部分进行开发的。MIME RFC 2045的6.8节详细介绍了这种编码方式，参见http://www.ietf.org/rfc/rfc2045.txt.pdf，这是Base64编码的官方规范。 Base64字母表由名字也可以看出，Base64编码将任意字符转换为用下表64个字符(中的某些)进行表示(具体原理稍候分析)。 图中最后的(pad) =是Base64编码中使用的填充字符，用于补足，在后面的原理分析中会看到。 原理 之前已经提到过Base64编码是对“字节数据”做处理。一个字节是8bit，也就是8个二进制位。假设现在有一个英文字符串，每个字符由1个字节（8bit）构成，则对应了一个字节序列。Base64编码将这些8位的字节序列拆分成多个6位的片段，计算这个6位二进制数对应的十进制值，根据该十进制值查Base64字母表，使用表中的字符指代该片段。（2^6=64,64种符号刚好可以表示6位二进制数的全部情况。）下面展示了一个具体的例子： 通过这样的分析，我们也就可以知道为什么Base64编码字符串比原始字符串扩大约三分之一：原来一个字符用8位表示，现在6位就代表一个字符，所以扩大(8-6)/6=1/3。 还有一个问题需要考虑：8位的字节序列不一定总能分割成整数个6位的片段。这时候，为了正常编码，就要在原序列末尾补足，使得序列长度成为24的倍数（6,8的最小公倍数）： 如果要进行补足的6位片段中包含原序列的位，则使用0补足，构成的6位二进制数按照正常情况进行查表得出对应的编码字符。 如果要进行补足的6位片段中包含原序列的位（即这个片段的6位都是用来补足的，并不含原数据），则这个片段编码为填充字符=如下示例： 应用Base64编码有很广泛的应用： 用户输入文本数据可通过Base64编码打包后作为HTTP首部字段的值发送给服务端 HTML5的FileAPI进行文件读取的示例如下： 1234567// 读取文件:var reader = new FileReader();reader.onload = function(e) &#123; var data = e.target.result; preview.style.backgroundImage = \"url(\" + data + \")\"; preview.style.backgroundSize ='300px 200px';&#125;; 其中变量data保存的是’image/jpeg;base64,/9j/4AAQSk……’这就是典型的Base64编码。编码值作为url()方法的参数去设置background-image。 注：url()方法不仅可以接受文件路径作为参数，也可以传入上述的这种data类型url，主要有以下几种：data:,&lt;文本数据&gt;data:text/plain,&lt;文本数据&gt;data:text/html,data:text/html;base64,data:text/css,data:text/css;base64,data:text/javascript,data:text/javascript;base64,data:image/gif;base64,base64编码的gif图片数据data:image/png;base64,base64编码的png图片数据data:image/jpeg;base64,base64编码的jpeg图片数据data:image/x-icon;base64,base64编码的icon图片数据 3.上面提到过，Base64编码是作为邮件协议进行开发的。电子邮件一般使用SMTP协议将邮件从客户端发往服务端，使用POP3或者IMAP从服务端获取邮件。最初SMTP协议基于纯ASCII文本，对二进制数据（文件）支持不好，为了解决这个问题，有了base64编码，即对二进制数据进行编码得到ASCII串使其能够正常通过SMTP协议进行传输。Content-Transfer-Encoding: base64表示附件文件内容使用base64编码后传输。 4.HTTP请求需要携带参数，比如GET方法是直接在url中进行参数拼接，这些可能需要转换为适合通过HTTP进行传输的数据，这就可以使用Base64编码。但是，经过Base64编码得到的文本中会包含+ /这样的符号，而这些会在URL编码时被转义，因此还有一些变种的Base64编码，比如它不仅在末尾填充’=’号，并将标准Base64中的“+”和“/”分别改成了“-”和“_”，这样就免去了在URL编解码和数据库存储时所要作的转换。 JavaScript实现 使用原生js的实现比较麻烦，这里推荐一个类库js-base64。","categories":[{"name":"FE综合","slug":"FE综合","permalink":"http://www.gcidea.info/categories/FE综合/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"编码","slug":"编码","permalink":"http://www.gcidea.info/tags/编码/"}]},{"title":"使用WebStorm创建webpack工作流的前端项目","slug":"webpack-demos","date":"2016-12-16T15:33:51.000Z","updated":"2018-12-12T16:09:31.002Z","comments":true,"path":"2016/12/16/webpack-demos/","link":"","permalink":"http://www.gcidea.info/2016/12/16/webpack-demos/","excerpt":"","text":"前言 webpack是一款极为灵活的前端模块打包构建工具。其诞生和流行主要是由于以下这几个发展趋势： 为了完成更加复杂的交互逻辑，一个网页中使用的js代码数量越来越多； 即便有了更多代码，却要求使用中有更少的整页面重新加载； 现代浏览器提供了更多的API接口。 基于这样的情况，大量代码就需要能够被良好地管理起来，像webpack这样的模块系统就为我们将代码切分为若干模块提供了很好的选择。本篇在webstorm编辑器中构建了一个最简单的使用webpack管理的前端项目，算是对webpack使用的入门探究。 JS模块化编程相关背景 在前端开发中有很多定义模块依赖的方法： 在html页面中使用&lt;script&gt;标签手动引入（这并没有使用模块管理系统） 在这种方式下，各模块是将接口暴露给了全局对象，比如window。常见问题： 全局对象中的命名变量冲突 各js文件加载顺序十分重要，一旦A依赖B而A又在B之前引入，则会报错 需要开发者自己来维护和解决依赖的问题 在大型项目中可能需要引入数十个js文件，代码冗长，难于管理 编写符合CommonJS规范的代码 这种规范使用同步的require方法加载依赖，并返回一个暴露出的接口，一个模块可以通过给export对象指定属性的方式来指定输出：1234require(\"module\");require(\"../file.js\");exports.doStuff = function() &#123;&#125;;module.exports = someValue; 这种方式主要用在服务端，比如Node.js。 编写符合AMD规范的代码 这种规范使用异步的require方法加载依赖，主要适用于客户端，因为在客户端如果同步加载的话会阻塞页面渲染等其他内容的进行，造成假死。 1234require([\"module\", \"../file\"], function(module, file) &#123; /* ... */ &#125;);define(\"mymodule\", [\"dep1\", \"dep2\"], function(d1, d2) &#123; return someExportedValue;&#125;); 使用ES6标准原生模块 ECMAScript 2015 (6th Edition)给javascript语言增加了新的内容-import关键字，从而构成了另一个模块系统 123import \"jquery\";export function doStuff() &#123;&#125;module \"localModule\" &#123;&#125; 什么是webpack？一句话来概括：webpack能够将相互依赖的模块进行打包，并生成代表着这些模块的静态文件。官网上给出的示意图如下： 市面上已经存在的模块管理和打包工具并不适合大型的项目，尤其单页面Web应用程序。最紧迫的原因是如何在一个大规模的代码库中，维护各种模块资源的分割和存放，维护它们之间的依赖关系，并且无缝的将它们整合到一起生成适合浏览器端请求加载的静态资源。这些已有的模块化工具并不能很好的完成如下的目标： 将依赖树拆分成按需加载的块 初始化加载的耗时尽量少 各种静态资源都可以视作模块 将第三方库整合成模块的能力 可以自定义打包逻辑的能力 适合大项目，无论是单页还是多页的Web应用 webpack有以下明显特点： 代码拆分 Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。 Loader Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。 智能解析 Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 require(“./templates/“ + name + “.jade”)。 插件系统 Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。 快速运行 Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。 webpack的安装1.安装Node.js 关于Node.js的安装有很多参考，在之前的文章【首篇】记录本博客www.gcidea.info的搭建过程也有提及。 2.安装webpack2.1 打开webstorm，创建一个新文件夹webpack-usage作为根目录，后续所有操作都在该项目中完成： 2.2 Node.js安装完成后，会同时安装npm这个Node.js的包管理工具。我们使用这个工具全局安装webpack。打开Terminal窗口输入如下命令：$ npm install webpack -g可以看到安装过程正在进行： 完成后，显示信息如下： 3.在项目中添加webpack 根据最佳实践，最好也在具体的项目中添加webpack。这样的话你可以任意指定在该项目中使用的webpack版本，而不至于局限于使用全局的唯一版本。3.1 为此，通过命令在项目根目录下创建package.json文件，将项目通过npm管理起来：npm init这个过程中需要填写一些信息，最终会写入package.json： 之后，项目根目录下多了一个文件，正是package.json： 3.2 此时，再通过如下命令安装webpack，其中--save-dev表示会将webpack添加到package.json的devDependencies中：npm install webpack --save-dev 并且，该命令会自动检查安装webpack所需的全部依赖，执行该命令后，项目有3处变化：控制台打印出依赖结构树；根目录下生成node_modules文件夹用于存放所有依赖包；package.json中多出一个devDependencies属性。如下图所示： 4.安装webpack-dev-server 这是一个Node.js Express server，可以帮我们在本地建立一个服务器。此处仅安装，具体使用在下文描述。npm install webpack-dev-server --save-dev 可以预想，现在package.json文件的依赖项已经变为：1234\"devDependencies\": &#123; \"webpack\": \"^1.13.2\", \"webpack-dev-server\": \"^1.16.2\" &#125; webpack的使用简单示例1.新建cats.js文件12var cats = ['dave', 'henry', 'martha'];module.exports = cats; 2.新建app.js文件12cats = require('./cats.js');console.log(cats); 3.使用webpack命令进行打包webpack ./app.js app.bundle.js 结果如下： 可以发现webpack已经帮我们将两个文件合并在一起并加入很多其他内容，这个过程在官方上详细描述如下： 现在，假如我们要将项目部署上线，那么只需要打包后的静态文件即可，实验如下： 可以看出，在node环境下执行打包文件，可以正常输出源文件的执行结果。 规范使用 项目结构 现在我们已经具备基本的webpack环境且大致了解了webpack的打包使用。为了规范使用，删除app.bundle.js,app.js,cat.js,重新规定项目目录结构如下： src：存放源码 build: 打包后静态文件目录 node_modules: node模块依赖目录 webpack.config.js：webpack配置目录–使用命令行携带参数的方式不便于扩展，统一用此文件管理 index.html: 项目入口页面 修改后的项目结构如下： 文件配置配置webpack.config.js1234567module.exports = &#123; entry: './src/app.js', output: &#123; path: './build', filename: 'app.bundle.js' &#125;&#125;; 以上简单的配置表示指定webpack打包入口为./src/app.js文件，打包结果为app.bundle.js，在./build目录下。 该文件还有很多配置项，详见：http://webpack.github.io/docs/configuration.html 现在，只需要简单的命令webpack而不需要参数，就可以执行打包。 使用loaders webpack只能对原生javascript文件打包，但是通过各种强大的loaders，我们可以处理各种类型的文件。Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 require 来加载任何类型的模块或文件，比如 CoffeeScript、 JSX、 LESS 或图片。 loaders具备以下特性： Loader 可以通过管道方式链式调用，每个 loader 可以把资源转换成任意格式并传递给下一个loader ，但是最后一个 loader 必须返回 JavaScript。 Loader 可以同步或异步执行。 Loader 运行在 node.js 环境中，所以可以做任何可能的事情。 Loader 可以接受参数，以此来传递配置项给 loader。 Loader 可以通过文件扩展名（或正则表达式）绑定给不同类型的文件。 Loader 可以通过 npm 发布和安装。 为了使浏览器能够解析，使用ES6语法编写的代码需要使用babel进行转码，为此我们安装babel-loader。1.安装Babel 和 presetsnpm install --save-dev babel-core babel-preset-es20152.安装babel-loadernpm install --save-dev babel-loader3.在根目录创建Babel配置文件—.babelrc内容为： { &quot;presets&quot;: [ &quot;es2015&quot; ] }4.修改webpack.config.js如下：1234567891011121314module.exports = &#123; entry: './src/app.js', output: &#123; path: './build', filename: 'app.bundle.js', &#125;, module: &#123; loaders: [&#123; test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader' &#125;] &#125;&#125; 安装其他可能需要的库 npm install --save jquery babel-polyfill --save而非--save-dev表示库将会在运行环境使用--save-dev的内容将会放在package.json 的devDependencies而--save会放在dependencies里面产品模式用dependencies，开发模式用devDependencies因此将会实际运行在用户端浏览器环境中的库就要采用--save安装通过使用babel-polyfill可以让老版本浏览器能够使用ES6新提供的API 修改app.js文件（ES6语法+jquery库） 123456789import 'babel-polyfill';import cats from './cats';import $ from 'jquery';$('&lt;h1&gt;Cats&lt;/h1&gt;').appendTo('body');const ul = $('&lt;ul&gt;&lt;/ul&gt;').appendTo('body');for (const cat of cats) &#123; $('&lt;li&gt;&lt;/li&gt;').text(cat).appendTo(ul);&#125; 将以上代码写入后，编辑器会报错： 原因是编辑器未能识别ES6语法，在webstorm的settings中做如下配置即可： 编辑index.html文件 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"build/app.bundle.js\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 重新打包 webpack 访问index.html可以看到正确结果 使用plugins 在打包的工作流中可能还会有一些其他的操作，会使用到不同的插件plugins，比较典型的就是uglify plugin这个压缩工具。为此，在webpack.config.js中增加配置项plugins：1234567891011121314151617181920212223242526const webpack = require('webpack');module.exports = &#123; entry: './src/app.js', output: &#123; path: './build', filename: 'app.bundle.js', &#125;, module: &#123; loaders: [&#123; test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader' &#125;] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, &#125;, output: &#123; comments: false, &#125;, &#125;), ]&#125; 在执行命令webpack重新打包之前，我们先看看app.bundle.js的文件大小,为523KB： 现在执行命令webpack重新打包，再看app.bundle.js的文件大小,为171KB： 可以看到，压缩工具去掉了无用的空字符等： webpack中的重要工具：webpack-dev-server webpack-dev-server本质上是一个小型的Node.js的Express服务器，使用webpack-dev-middleware作为中间件来支持webpack打包。 安装webpack-dev-servernpm install webpack-dev-serverpackage.json变为如下形式：12345678910111213141516171819202122&#123; \"name\": \"webpack-usage\", \"version\": \"1.0.0\", \"description\": \"webpack-usage-demo\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"gaochang\", \"license\": \"ISC\", \"devDependencies\": &#123; \"babel-core\": \"^6.17.0\", \"babel-loader\": \"^6.2.5\", \"babel-preset-es2015\": \"^6.16.0\", \"webpack\": \"^1.13.2\", \"webpack-dev-server\": \"^1.16.2\" &#125;, \"dependencies\": &#123; \"babel-polyfill\": \"^6.16.0\", \"jquery\": \"^3.1.1\" &#125;&#125; 启动webpack-dev-server 安装完成后，在不指定任何参数的情况下，可以直接通过命令webpack-dev-server在本地8080端口运行一个服务器，访问http://localhost:8080可以看到效果： 访问http://localhost:8080/webpack-dev-server/ 可以显示webpack服务器状态条 指定content basewebpack-dev-server默认监控的是当前目录的文件，除非声明一个特殊的基本路径：webpack-dev-server --content-base build/这样的话，webpack就会只监控build文件夹下的静态文件。当你的文件在任何时候发生变化时，都会触发重新编译打包。验证如下：1.使用上述命令启动server： 控制台会显示打包过程日志，并最终提示打包完成已经可用： 2.此时，访问http://localhost:8080/webpack-dev-server/可看到： 即显示了build目录下的文件列表，此时只有app.bundle.js，点开内容如下： 红色框中是我们app.js中的部分源码。 3.现在修改上述部分源码，观察控制台日志和http://localhost:8080/webpack-dev-server/目录下文件变化。修改&lt;h1&gt;内容后，发现控制台日志在之前“bundle is now VALID”的基础上，自动开始重新编译，进入“bundle is now INVALID”的状态： 同时，看到页面状态条变为： 等待重编译完成后，发现页面文件内容确实变为我们修改后的内容： 但是，值得注意的是，这个修改的内容是保存在内存中的，并没有写入我们在webpack.config.js的output中指定的文件： 发现文件还是修改之前的内容。也就是说，当相同URL下已经有一个打包的文件时，默认情况下内存中的文件享有优先权。而如果想要让build目录下的输出文件的内容也跟随发生变化，则要使用webpack命令重新打包。 除了以上分析，还有一点要注意，通过给webpack.config.js的output指定publicPath，可以定制浏览器中的项目访问路径。12345output: &#123; path: './build', publicPath: \"/assets/\", filename: 'app.bundle.js',&#125; 重新打包，可以在如下路径访问相应文件： 由于之前content-base指定了监控build目录，我们在该目录下创建一个index.html文件，用来加载并使用我们打包好的js文件，而原先在项目根目录webpack-usage下创建的index.html文件就不起作用了：1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;在build目录下创建的index.html文件&lt;/p&gt; &lt;script src=\"assets/app.bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 访问http://localhost:8080/： 访问http://localhost:8080/webpack-dev-server: 其中，第一个是打包文件app.bundle.js本身：注意路径为http://localhost:8080/assets/app.bundle.js，符合publicPath的配置。 第二个是根据打包文件生成的html文件，注意路径为http://localhost:8080/assets/app.bundle，符合publicPath的配置点击“app.bundle”: 点击“webpack-dev-server”:（该html文件仅针对app.bundle.js，和直接访问http://localhost:8080/对应的index.html并不相同，以上两图中没有“在build目录下创建的index.html文件”这句话就说明了这一点。） 关于js文件引入的路径，经测试发现以下几种情况，应该与webpack的文件查找算法有关，具体待进一步探究： 1.src=&quot;assets/app.bundle.js&quot; 由于publicPath指定了”/assets/“，因此这种方式肯定能找到app.bundle.js文件； 2.src=&quot;app.bundle.js&quot; 默认在build目录下找该文件，能找到 3.src=&quot;/app.bundle.js&quot; 默认在build目录下找该文件，能找到 4.src=&quot;./app.bundle.js&quot; 默认在build目录下找该文件，能找到 5.src=&quot;../app.bundle.js&quot; 默认在build目录下找该文件，能找到 自动刷新 webpack-dev-server支持两种自动刷新页面的方式。并且两种方式都支持模块热替换。 iframe模式 在这种方式下，页面实际上是被嵌入了一个iframe，使用这种方式不需要额外配置，只要js文件以改变，就会自动”recompiling”。直接访问http://«host»:«port»/webpack-dev-server/«path»，在我们的配置中就是访问http://localhost:8080/webpack-dev-server/index.html。该方式的特点是： 无需改变配置 编译信息通过页面顶部信息条体现 浏览器地址栏不会体现出地址的变化 inline模式 在这种方式下，我们需要额外的配置，使用以下两种方式之一： 在启动命令上加参数”–inline”:webpack-dev-server --content-base build/ --inline 在webpack.config.js加上devServer: { inline: true } 使用这种方式不需要给URL加上/webpack-dev-server/，直接访问http://«host»:«port»/«path»，在我们的配置中就是访问http://localhost:8080/index.html 该方式的特点是： 需要改变配置 编译信息通过浏览器的console体现： 浏览器地址栏会体现出地址的变化 模块热替换 Hot Module Replacement 的应用 在webpack-dev-server中使用模块热替换 Hot Module Replacement最简单的办法就是在inline模式中使用。我们只需要在参数中加上”–hot”即可。webpack-dev-server --content-base build/ --inline --hot 这样，就进入了监听状态，当文件发生修改，看到console打出如下日志： 发现提示错误，热替换失败，整个页面进行了重载：1234567[HMR] Cannot apply update. Need to do a full reload![HMR] Error: Aborted because 77 is not accepted at l (http://localhost:8080/assets/app.bundle.js:1:4169) at f (http://localhost:8080/assets/app.bundle.js:1:3117) at u (http://localhost:8080/assets/app.bundle.js:1:3017) at webpackHotUpdate (http://localhost:8080/assets/app.bundle.js:1:5790) at http://localhost:8080/assets/0.ae586ae503d4fe64ca9a.hot-update.js:1:1 查阅了很多资料，如https://github.com/webpack/webpack-dev-server/issues/395，但并没有找到准确原因，暂时搁置。","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"http://www.gcidea.info/categories/前端工程化/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"http://www.gcidea.info/tags/前端工程化/"},{"name":"webpack","slug":"webpack","permalink":"http://www.gcidea.info/tags/webpack/"}]},{"title":"JavaScript中的__proto__、[[prototype]]和prototype","slug":"js-proto-prototype","date":"2016-12-12T04:52:56.000Z","updated":"2018-12-12T16:08:30.566Z","comments":true,"path":"2016/12/12/js-proto-prototype/","link":"","permalink":"http://www.gcidea.info/2016/12/12/js-proto-prototype/","excerpt":"","text":"前言 proto、[[prototype]]和prototype三个概念及相关内容是javascript比较复杂且容易混淆的内容。本文尝试进行总结和分析。 prototype相关介绍 待续。 __proto__与[[prototype]]相关介绍 待续。 一张图分析三者的关系 一系列案例分析12345function Foo()&#123; console.log(1);&#125;var a = new Foo();console.log(a.prototype === Foo.prototype); //false 12345function Foo()&#123; console.log(1);&#125;var a = new Foo();console.log(a.__proto__ === Foo.prototype); //true 12345function Foo()&#123; console.log(1);&#125;var a = new Foo();console.log(a.prototype); //undefined 12345function Foo()&#123; console.log(1);&#125;var a = new Foo();console.log(a.__proto__); //object&#123;&#125; 123456function Foo()&#123; console.log(1);&#125;Foo.prototype = &#123; &#125;;var a = new Foo();console.log(a.constructor === Foo); //false 123456function Foo()&#123; console.log(1);&#125;Foo.prototype = &#123; &#125;;var a = new Foo();console.log(a.constructor === Object); //true 123456function Foo()&#123; console.log(1);&#125;Foo.prototype = &#123; &#125;;var a = new Foo();console.log(a.constructor); 123456function Foo()&#123; console.log(1);&#125;Foo.prototype = &#123; &#125;;var a = new Foo();console.log(a.__proto__); //function Object() &#123; [native code] &#125; 123456function Foo()&#123; console.log(1);&#125;Foo.prototype = &#123; &#125;;var a = new Foo();console.log(a.__proto__.__proto__ === Object.prototype); //true 12345function Foo()&#123; console.log(1);&#125;var a = new Foo();console.log(a.__proto__ === a.prototype); //false 12var a = new Function();console.log(a.__proto__ === Function.prototype); //true 12345function Foo()&#123; console.log(1);&#125;var a = new Foo();console.log(a.constructor.prototype === a.__proto__); //true 12345function Foo()&#123; console.log(1);&#125;var a = new Foo();console.log(a.constructor.prototype === Foo.prototype); //true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"CSS居中问题总结","slug":"css-center","date":"2016-12-09T05:21:44.000Z","updated":"2018-12-12T16:08:49.993Z","comments":true,"path":"2016/12/09/css-center/","link":"","permalink":"http://www.gcidea.info/2016/12/09/css-center/","excerpt":"","text":"前言 本篇集中对CSS中的各种居中问题进行总结。整体上需要居中的元素可以分为两大类-内联元素和块级元素，而居中方式又要考虑水平和垂直两个方向。 内联元素居中水平居中 使用”text-align:center”根据以下W3C的官方文档： 属性“text-align”用于描述块级元素中的行内内容如何布局。我们知道，块级元素的显示占据一整行，而行内元素可以在一行内并列显示，常用的行内元素有&lt;img&gt;、&lt;input&gt;、&lt;label&gt;等。默认地，块级元素中的行内元素是左对齐显示的，比如：123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;span&gt;CSS行内元素居中测试&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下图所示： 这种情况下我们想对行内元素标签中的内容进行居中显示，则可以使用“text-align: center”。要注意的是，这个属性是用来决定行内元素的位置的，没错，但是该属性并不是写在行内元素上，而是要写在行内元素的父级元素，即块级元素这个“container”上，以此来决定内部文本的对齐方式。代码如下：1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #block-center &#123; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"block-center\"&gt; &lt;span&gt;CSS行内元素居中测试&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下图所示： 使用CSS3的flexbox”justify-content:center” 和text-align一样的是，justify-content也适用于父类容器上，用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。当属性值为“center”时，弹性盒子元素将向行中间位置对齐。该行的子元素将相互对齐并在行中居中对齐，同时第一个元素与行的主起始位置的边距等同于最后一个元素与行的主结束位置的边距（如果剩余空间是负数，则保持两端相等长度的溢出）。代码如下：123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #block-center &#123; display: flex; /*注意此处要指明flex布局*/ justify-content: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"block-center\"&gt; &lt;span&gt;CSS行内元素居中测试(此处使用justify-content)&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下图所示： 使用”display: table-cell” display: table的CSS声明能够让一个HTML元素和它的子节点像table元素一样。使用基于表格的CSS布局，使我们能够轻松定义一个单元格的边界、背景等样式，而不会产生因为使用了table标签所导致的语义化问题。代码如下：1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #block &#123; display: table; width: 100%; border: 1px solid black; &#125; #block-center &#123; display: table-cell; text-align: center; border: 1px solid orangered; &#125; #inline-1 &#123; height: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"block\"&gt; &lt;div id=\"block-center\"&gt; &lt;img src=\"2.jpg\" id=\"inline-1\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下图所示： 垂直居中 默认情况 对于上述已经水平居中的文本来说，相对于父级元素的垂直居中是默认的，不需要特殊声明，比如下面两张图，修改文本字号，它们始终处于父级div的垂直方向的中间（为了看得清楚，给父级元素加上了边框）。 行内元素互相之间的垂直居中 如果一个父级元素中有多个行内元素，那么默认它们是在父元素的基线上进行对齐排列，也就是vertical-align: baseline;，以行内元素-图片为例，代码为：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #block-center &#123; text-align: center; border: 1px solid orangered; &#125; #inline-1 &#123; height: 40px; &#125; #inline-2 &#123; height: 60px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"block-center\"&gt; &lt;img src=\"2.jpg\" id=\"inline-1\"&gt; &lt;img src=\"3.jpg\" id=\"inline-2\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 此时如果不想让这些行内元素“底部对齐”呢，而是想让它们互相居中对齐，也就是图片的中线在同一条水平线上呢？那就要对行内元素本身使用vertical-align: middle;，代码为：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #block-center &#123; text-align: center; border: 1px solid orangered; &#125; #inline-1 &#123; vertical-align: middle; height: 40px; &#125; #inline-2 &#123; vertical-align: middle; height: 60px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"block-center\"&gt; &lt;img src=\"2.jpg\" id=\"inline-1\"&gt; &lt;img src=\"3.jpg\" id=\"inline-2\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下图所示： 块级元素居中水平居中 使用”margin: 0 auto” 我们以最常见的块级元素-div为例，看一下居中的过程。首先创建一个div，代码如下：123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #block &#123; width: 100px; height: 100px; background-color: orangered; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"block\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下图所示： 对块级元素本身添加margin: 0 auto可使其水平居中，即左右的外边距margin是auto的，会根据实际屏幕大小进行自动适配。修改上述style部分：12345678&lt;style&gt; #block &#123; width: 100px; height: 100px; background-color: orangered; margin: 0 auto; &#125;&lt;/style&gt; 效果如下图所示： 使用CSS3的flexbox”justify-content:center” justify-content:center不仅可以用来处理行内元素，也可以处理块级元素，为达到与上述方法相同的效果，代码为：1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #block &#123; display: flex; justify-content: center; &#125; #block-core &#123; width: 100px; height: 100px; background-color: orangered; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"block\"&gt; &lt;div id=\"block-core\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图与上面的相同。 使用浮动配合相对定位为了描述这种方法，我们通过下面的过程逐步深入分析：1.考虑最简单的场景：父级div包含了子级div，代码如下：1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; html,body &#123; width: 100%; height: 100%; margin: 0; padding: 0; &#125; #wrapper &#123; border: 2px solid black; &#125; #block &#123; width: 100px; height: 100px; background-color: orangered; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"wrapper\"&gt; &lt;div id=\"block\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 易于理解，效果如下图所示： 2.上图黑色边框div是一个包裹元素，我们现在把它水平移动50%，也就是设置left属性。我们知道其默认的position属性为“static”，这种情况下left属性不起作用，因此将position改为relative，代码如下：12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; html,body &#123; width: 100%; height: 100%; margin: 0; padding: 0; &#125; #wrapper &#123; position: relative; left: 50%; border: 2px solid black; &#125; #block &#123; width: 100px; height: 100px; background-color: orangered; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"wrapper\"&gt; &lt;div id=\"block\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下图所示： 我们发现，此时&lt;div id=&quot;wrapper&quot;&gt;的左边界位于正中间，左右都是610px，也就是说，这个”left: 50%”是相对于wrapper的父级元素即body进行确定的，而body的宽度就是浏览器窗口宽度。同时发现，窗口出现了水平方向滚动条，这是由于wrapper向右进行偏移，但本身宽度又没变导致的水平方向溢出。溢出了多少呢？通过下面的操作容易看出溢出正好是浏览器宽度的一半，也就是wrapper向右偏移的距离： 3.为了防止出现滚动条，我们可以将wrapper这个div向左浮动，即加上一句“float: left;”，效果如下： 4.现在，想让橙色方块水平居中，只要加50%的left就好了，代码如下：12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; html,body &#123; width: 100%; height: 100%; margin: 0; padding: 0; &#125; #wrapper &#123; position: relative; float: left; left: 50%; border: 2px solid black; &#125; #block &#123; width: 100px; height: 100px; background-color: orangered; position: relative; left: -50%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"wrapper\"&gt; &lt;div id=\"block\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 使用”display:table-cell” 这种方法我们将在下文中块级元素垂直居中统一介绍-使用”display:table-cell”同时达到水平和垂直居中的效果。 垂直居中 使用“top”属性和“margin-top”属性的结合分析：a. 由水平居中部分的分析我们可以知道，当元素水平居中后，在垂直方向还是“密铺”的，也就是从上到下排列，不会向下移动之类的。那么为了把元素“向下拽”，就考虑设置该元素的top属性为某个值，从而相对于父级元素在顶端有一定的空白，经过合理调整后可位于正中间。b. 首先，我们要知道，css中position属性的默认值是static；其次，要知道top属性对于position值为“static”的元素不会产生任何效果。因此，想修改一个元素的top值，必须将元素的position修改为不是static的，这里我们改为“position: relative”。c. 将top属性设置为一个百分比，这个百分比是相对于谁来说的呢？—是逐级向上寻找的，直到找到一个可以确定高度的父级元素，按照这个父级元素的高度结合百分比来设置top的具体值。这里橙色div的父级元素是&lt;body&gt;，再向上的父级元素是&lt;html&gt;。而浏览器在默认状态下，是没有给html和body一个高度的，为了使之成为刚才所说的“可以确定高度的父级元素”，将&lt;body&gt;和&lt;html&gt;的高度均设置为100%。d. 既然是居中，也就是一半，我们考虑先将元素的top属性设置为50%，看看效果，代码为：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; html,body &#123; width: 100%; height: 100%; margin: 0; padding: 0; &#125; #block &#123; position: relative; width: 100px; height: 100px; background-color: orangered; margin: 0 auto; top: 50%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"block\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下图所示： e.从上图可以看出，橙色正方形的定边到浏览器窗口上方和下方的距离是一样的，都是298px，也就是说top: 50%;不是将元素居中，而是整体下移了父级元素高度的一半，这也是很好理解的。但是我们已经有了一个基础，在此基础上，通过再设置元素的margin-top,可以进行修正，margin-top是指元素的顶外边距，正值表明元素会继续下移，那么取负值即可向上，橙色正方形的高度为100px，那么margin-top取为-50px，css代码修改如下：1234567891011121314151617&lt;style&gt; html,body &#123; width: 100%; height: 100%; margin: 0; padding: 0; &#125; #block &#123; position: relative; width: 100px; height: 100px; background-color: orangered; margin: 0 auto; top: 50%; margin-top: -50px; &#125;&lt;/style&gt; 效果如下图所示： 我们能够看出现在已经完全居中了。 使用CSS3“translateY”属性 在上面方法的基础上，将下移50%的元素向上修正时，可以采取更简单的办法：translateY(-50%)。translateY()方法通过给定一个值，将元素沿Y轴进行移动，并且，给定的是是相对于元素自身的，因此50%就表示元素自身Y方向长度的一半。负号表示沿Y轴反方向移动（Y轴正向向下）。这种方法还有一个明显的好处，就是和margin-top相比，给定的是一个比例，而不像margin-top这样写死，这样后面的可维护性也会好一些。CSS代码如下：1234567891011121314151617&lt;style&gt; html,body &#123; width: 100%; height: 100%; margin: 0; padding: 0; &#125; #block &#123; position: relative; width: 100px; height: 100px; background-color: orangered; margin: 0 auto; top: 50%; transform: translateY(-50%); &#125;&lt;/style&gt; 使用CSS3的flexbox”align-items: center” 弹性盒模型在处理居中问题上真是简单明了。上面说了两种使用flexbox进行水平居中的方法，垂直居中一样可以使用flexbox搞定，align-items 属性定义flex子项在flex容器的纵轴方向上的对齐方式;justify-content属性定义flex子项在flex容器的横轴方向上的对齐方式。代码如下：1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; html,body &#123; width: 100%; height: 100%; margin: 0; padding: 0; &#125; body &#123; display: flex; align-items: center; justify-content: center; &#125; #block &#123; width: 100px; height: 100px; background-color: orangered; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"block\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用”display:table-cell” 我们曾在内联元素的水平居中使用过这种办法，它也可以用于块级元素的水平和垂直居中。核心是使用”text-align: center; vertical-align: middle;”这两个属性。另外特别要注意的是，为了让这两个属性对于想要居中显示的块级元素生效，必须指定该块级元素为”display: inline-block;”。”display:inline-block”将对象呈递为内联对象，但是对象的内容作为块对象呈递。换句话说就是与”display: block”相比，它可以让设置了同类display属性的元素显示在同一行；与”display: inline”相比，可以对设置了该属性的元素设置高度。代码如下：1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; html,body &#123; width: 100%; height: 100%; margin: 0; padding: 0; &#125; #parent &#123; display: table; width: 100%; height: 100%; &#125; #wrapper &#123; display: table-cell; text-align: center; vertical-align: middle; &#125; #block &#123; width: 100px; height: 100px; background-color: orangered; display: inline-block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"parent\"&gt; &lt;div id=\"wrapper\"&gt; &lt;div id=\"block\"&gt;display: table-cell实现块级元素水平和垂直居中&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下图所示： 使用CSS :before 选择器 关于:before 选择器本身这里不做介绍，使用:before，在想要居中显示的元素前面追加了一个内联元素来占据相应的位置，从而达到垂直居中的效果，代码如下：12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; html,body &#123; width: 100%; height: 100%; margin: 0; padding: 0; &#125; body:before &#123; content:''; display:inline-block; vertical-align:middle; height:50%; &#125; #block &#123; width: 100px; height: 100px; background-color: orangered; position: relative; top: -50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"block\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下图所示： Bootstrap中关于居中的处理 Bootstrap中关于排版的居中提供了两个class： class=”text-center”源码为： 123.text-center &#123; text-align: center;&#125; class=”center-block”源码为： 12345.center-block &#123; display: block; margin-right: auto; margin-left: auto;&#125; 这两个类中使用到的方法在上文中都有提及。结合Bootstrap提供的其他强大的样式，容易实现各类排版。 小结 本文总结了很多使用CSS对元素进行居中的办法，CSS是十分灵活且强大的，一定还有其他更好的办法。以上所列举的方法在正常开发中应该是够用了，并且通过实现居中理解了很多相关原理，这对于排错过程中快速定位问题很重要。","categories":[{"name":"CSS/CSS3","slug":"CSS-CSS3","permalink":"http://www.gcidea.info/categories/CSS-CSS3/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"CSS/CSS3","slug":"CSS-CSS3","permalink":"http://www.gcidea.info/tags/CSS-CSS3/"}]},{"title":"【阿里云ECS】GitLab的搭建配置过程和GitLab-CI服务的使用","slug":"gitlab-gitlab-ci","date":"2016-12-05T15:21:14.000Z","updated":"2018-12-12T16:08:45.178Z","comments":true,"path":"2016/12/05/gitlab-gitlab-ci/","link":"","permalink":"http://www.gcidea.info/2016/12/05/gitlab-gitlab-ci/","excerpt":"","text":"前言 GitHub是一个十分著名并相当活跃的社区，每天有世界各地的程序员在这里分享与交流。作为开源项目或者技术分享，我们当然可以将代码维护在这里。但是对于内部项目，我们应该具备私有仓库来进行维护。GitLab就是一个很好的选择。本文主要包括以下几个方面： Git安装与使用 GitLab相关知识介绍 GitLab搭建配置的完整过程 GitLab-CI相关知识介绍 GitLab-CI安装配置的完整过程 GitLab-CI持续集成服务的测试 小结 准备工具 部署环境：阿里云ECS Centos7.0 64bit(已具备完整LAMP环境) 远程连接：Xshell 5 文件传输：Xftp 5 Git安装与使用 Git的安装是必要的，安装后我们可以从服务器clone下来GitLab仓库中的最新代码进行开发维护。Centos7自带Git，但是版本为1.8，考虑到使用新版本减少问题，决定升级至2.7.4。具体过程如下： 卸载Centos7自带的Git1.8# yum remove git 下载Git2.7.4# wget https://github.com/git/git/archive/v2.7.4.tar.gz 解压该文件# tar zxvf v2.7.4.tar.gz 【配置】，configure用来生成Makefile，指定安装到 /usr/local/git，为下一步的编译做准备# ./configure --prefix=/usr/local/git 【编译】，根据makefile的定义，调用源代码、函数库、编译器来编译# make configure 【安装】# make install 将Git添加至环境变量中# echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/bashrc 在当前bash环境下读取并执行/etc/bashrc中的每一条命令，使之立刻生效# source /etc/bashrc 经过以上过程，Git就安装完成了，我们可以查看Git的版本：# git --version 如下所示： 具体git知识的学习与git使用，参见廖雪峰的git教程。 GitLab相关知识介绍 首先，GitLab的官网是https://about.gitlab.com/gitlab-com/，这里有最权威的文档与介绍。其次，GitLab中文社区http://www.gitlab.cc/也比较活跃，可以在上面找找有没有类似的问题。 Gitlab是一个用Ruby on Rails开发的开源项目管理程序，可以通过WEB界面进行访问公开的或者私人项目。它和GitHub有类似的功能，能够浏览源代码，管理缺陷和注释。GitLab拥有Git仓库管理，code reviews(代码审查)，issue tracking(问题跟踪)，wikis等功能，GitLab搭配GitLab CI，能更简单的实现持续集成和自动部署。还可以使用issue，milestones，逐行code reviwe等功能进行团队协作，查看项目动态。GitLab可无缝集成Slack，Hipchat，LDAP，JIRA，Jenkins等其他流行的工具，提供了非常多的webhooks和完善的API。 GitLab社区版是开源的，可以免费下载使用。GitLab由超过1000人的社区维护。GitLab企业版提供深度的LDAP和Active Directory集成，以及Jira和Jenkins集成。 而无论是GitLab还是GitHub，都可以说是一种管理工具，其本质都是要学会Git的思想与使用。推荐廖雪峰的git教程。 Gitlab官方文档对于Gitlab的原理和重要组件有详细的说明，这里就不再展开了，但要推荐一位学长的帖子，他在帖子中讲述了一些对于Gitlab工作流程和重要组件的理解，值得一读。 GitLab搭建配置的完整过程安装 GitLab官网上有详细的安装说明，选择操作系统版本后按步骤操作即可。但是阿里云主机无法连接GitLab Yum源，因此选择rpm包安装方式。 使用curl命令获取相应文件# curl -LJO https://mirror.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-8.5.4-ce.0.el7.x86_64.rpm rpm方式安装# rpm -i gitlab-ce-8.5.4-ce.0.el7.x86_64.rpm结果如图： 配置 我们在上一篇文章的“phpMyAdmin的安装与配置 3.测试”中提到，由于我的网站线上环境、GitLab都是搭建在一台服务器上的，因此在默认情况下会产生端口冲突。于是做出如下处理。 修改Apache端口为4040使用命令：# cd etc/httpd/conf/# vi httpd.conf注释掉Listen 80，改为Listen 4040 配置GitLabGitLab的配置文件默认位于/etc/gitlab/gitlab.rb使用命令：# cd /etc/gitlab# vi gitlab.rb在该文件的一开始就有关于external_url的配置，这里我填的就是我的阿里云ECS主机的ip地址。 这里注意，在配置url时直接指定一个未被占用的端口即可。如果不指定端口（仅填写域名或者IP地址），那么默认的是80端口，此时就必须保证Apache使用的不是80默认端口（修改方法见上述内容），否则冲突。配置完成后，还要使用如下命令使之生效：# gitlab-ctl reconfigure 测试 按照上述过程，GitLab本身的基本配置就可以了。打开浏览器输入external_url地址访问GitLab，却出现了如下界面：原因：查阅了相关资料，引起502的原因多样，比如设置的超时时间过短等。经过排查，我这里遇到这个问题是因为阿里云centos7默认的虚拟内存swap交换分区设置过小导致的。解决方法：增加系统的swap分区： 新建一个分区，创建/home/swap分区文件。文件的大小是1024000个block，1个block为1024，所以这里空间是1G# dd if=/dev/zero of=/home/swap/swap bs=1024 count=1024000 将该分区格式化成swap分区，使其成为有效状态# swapon /home/swap/swap 查看最新的分区情况： 发现swap分区已经创建成功。但这里还有一个问题，当系统重启后，这块分区将会消失。为此，我们需要将新分区设置为开机自动挂载。/etc/fstab文件正是负责配置Linux开机时自动挂载分区的，对其进行修改。使用命令：# cd /etc# vi fstab在最后增加如下一句：1/swap/swap/swap swap swap defaults 0 0 配置完分区后，再次访问external_url的地址，就可以看到正常的GitLab登录页。默认用户名：admin@local.host，密码5iveL!fe，登陆后可修改。GitLab的管理员面板(Admin area)如下，在这里我们可以新增成员，创建项目，新建分组，邀请成员进入项目，项目持续集成配置等等，具体的问题可以进行相应搜索。 至此，我们就成功搭建了GitLab~ GitLab-CI相关知识介绍 目前，我们已经拥有了自己的GitLab仓库，可以进行正常的开发和版本控制了。我们现在需要考虑这样的场景：在团队合作开发中，每天每位成员都要做出很多修改，向GitHub仓库提交大量代码，且时间不定。版本库中代码虽是最新的，可是线上部署的却没有同时更新，如果测试人员需要及时跟进，或者比如APP端的同学需要调用最新的接口进行测试，就需要手动在线上进行部署，为了保证实时性一天可能就要部署很多次，烦。 这种场景，当然被很多人注意到了，CI–持续集成正是说的这样的问题。 持续集成(Continuous integration)是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。 强大的GitLab自然也考虑到了这个问题。GitLab-CE 8.0以上的版本已经将GitLab-CI集成进了GitLab，并且默认开启。所以不需要像以前一样再单独安装GitLab-CI并且为GitLab-CI开启单独的Server。但是GitLab-Runner还是需要我们单独安装的，来配合GitLab-CI使用。为此，这部分我们来详细讨论一下GitLab-CI相关问题。 GitLab官网上提供了详尽的CI文档http://doc.gitlab.com/ce/ci/，可以查阅。 关于GitLab-Runner的介绍，这里我要引用一下那位学长的另一篇帖子中的一部分介绍，如下。 GitLab-Runner是配合GitLab-CI进行使用的。一般地，GitLab里面的每一个工程都会定义一个属于这个工程的软件集成脚本，用来自动化地完成一些软件集成工作。当这个工程的仓库代码发生变动时，比如有人push了代码，GitLab就会将这个变动通知GitLab-CI。这时GitLab-CI会找出与这个工程相关联的Runner，并通知这些Runner把代码更新到本地并执行预定义好的执行脚本。 所以，GitLab-Runner就是一个用来执行软件集成脚本的东西。你可以想象一下：Runner就像一个个的工人，而GitLab-CI就是这些工人的一个管理中心，所有工人都要在GitLab-CI里面登记注册，并且表明自己是为哪个工程服务的。当相应的工程发生变化时，GitLab-CI就会通知相应的工人执行软件集成脚本。如下图所示：Runner类型 GitLab-Runner可以分类两种类型：Shared Runner（共享型）和Specific Runner（指定型）。Shared Runner：这种Runner（工人）是所有工程都能够用的。只有系统管理员能够创建Shared Runner。Specific Runner：这种Runner（工人）只能为指定的工程服务。拥有该工程访问权限的人都能够为该工程创建Shared Runner。 文／tsyeyuanfeng（简书作者）原文链接：http://www.jianshu.com/p/2b43151fb92e著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。 GitLab-CI安装配置的完整过程安装 之前已经说过，GitLab-CE 8.0以上的版本已经将GitLab-CI集成进了GitLab，因此下面安装GitLab-Runner。 官网确实给出了详细的安装方式（针对各种操作系统）https://gitlab.com/gitlab-org/gitlab-ci-multi-runner/blob/master/docs/install/linux-repository.md，但是，我也确实无论如何都无法下载下来文档中提到的yum源。。。为此，我“换了种方式”下载了rpm包，使用Xftp将rpm文件放进了阿里云ECS的centos系统中，再通过rpm命令进行了安装，绕了个大圈，如图： 注册 安装好gitlab-ci-multi-runner后，我们就可以用它向GitLab-CI注册Runner了。 根据官网的介绍，如果我们需要注册Shared Runner，就在管理员面板Admin Area中获取token和url，如下图： 如果我们需要注册Specific Runner，就要在该项目的setting中的runner面板中获取token和url，如下图： 这里，我是新建了一个Specific Runner，使用命令：# gitlab-ci-multi-runner register 操作如下: 注册成功后，我们可以在/etc/gitlab-runner/config.toml中看到runner的配置信息： 但是这个配置信息在runner运行时候并没有起到实质作用，因为在接下来要讲到的运行runner中，命令中必须还要带上这个配置信息中的一些内容，可以说这个配置信息只是起到了一个记录作用。 运行runner注册完成之后还必须让它运行起来，否则无法接收到GitLab-CI的通知或执行脚本。我们使用命令：1# gitlab-ci-multi-runner run-single --url http://***.***.***.***/ci --token ************** --executor shell 运行配置好的runner，其中–url、–token和–executor参数是必须的，具体值与配置文件中的相同。其他参数可根据具体情况设置。 使用如下命令了解更多：# gitlab-ci-multi-runner run-single --help 当具有多个runner，可以使用命令：# gitlab-ci-multi-runner run来批量运行，使用如下命令了解更多：# gitlab-ci-multi-runner run --help 目前还有一个问题，当runner运行后，它是保持在前台的，这时候terminal不能再做其他事情，这当然不行。因此我们要把runner运行这件事做成一个服务。 使用命令： 1# gitlab-ci-multi-runner install --service gitlab-runner --working-directory /home/gitlab-runner --config /etc/gitlab-runner/config.toml --user gitlab-runner 将这个runner做成服务，并启动： # gitlab-ci-multi-runner start --service gitlab-runner 这时候，在terminal中可以继续操作，查看后台进程： # ps -aux | grep gitlab-runner 发现正常运行： 至此，GitLab-CI和GitLab-Runner配置完成。 GitLab-CI持续集成服务的测试 前文完成了GitLab-CI持续集成服务的配置，那么它是如何起作用的呢？ 我们已知，我们针对我们项目的仓库已经建立了一个Specific Runner，并且将它运行起来了，runner就处于一种“监听状态”。当项目成员向仓库提交代码，runner检测到像git push这样的事件后，就会做出一些处理，实现项目的自动部署持续集成。具体的： 我们需要在根目录下建立一个名为.gitlab-ci.yml的文件。当整个项目进行git push的时候，runner会去检查这个文件，去执行里面的脚本。 我们想实现的效果是：每次提交的新代码都可以自动部署到/var/www/html目录下，这样访问网站或者API接口就可以获取最新情况。那么，其实就相当于删除原先该目录下的代码，将新提交的内容放在该目录下。这样就很清楚脚本怎么写了，只需要两句：1234deploy: script: - rm -rf /var/www/html/project_name - cp -r ../project_name /var/www/html/project_name 解释： 使用rm命令加上-rf递归强制删除项目文件/var/www/html/project_name。 使用命令cp加上-r参数递归复制相对于当前.gitlab-ci.yml文件的上一层目录的整个项目文件，复制到/var/www/html/project_name目录。 之所以是复制../project_name目录，是因为runner检测到.gitlab-ci.yml文件时，是处于最新的工程文件夹的根目录下，这样的话../project_name就表示了最新的代码。(更多的，我们可以了解到项目文件其实是位于这个runner的子目录下的：/home/gitlab-runner/builds/runner_name/0/root/project_name) 实践一下，在工程中建立.gitlab-ci.yml文件，并对项目中代码做出一些修改（内容随意，主要是想看到修改效果），检查冲突后git push。这时在GitLab中该项目的控制面板的Builds菜单中监测，发现build失败了： 查看以上日志可以发现是在删除时遇到了权限问题，没有写的权限，于是更改整个项目目录的权限为777，保证删除顺利。 之后再次git push测试，发现build成功： (注：如果考虑直接将权限变为777这种比较暴力的方法的安全性问题，也可以采用更换文件夹所属用户组的方法，改owner为gitlab-runner：) 1# chown -R gitlab-runner /var/www/html/ebfinance 这时，去Apache配置的4040端口去查看网站的效果，发现已经是最新代码对应的效果，说明自动部署成功！ 小结 至此，本文的主要内容就结束了。我们拥有了自己的项目仓库并且可以自动部署持续集成，这大大提高了我们的效率。同时，这套完整的配置过程中也可以学习到很多东西，踩了不少坑，积累了一些经验，明白了一些原理，总之还是收获很大的。","categories":[{"name":"搭建部署","slug":"搭建部署","permalink":"http://www.gcidea.info/categories/搭建部署/"},{"name":"阿里云","slug":"搭建部署/阿里云","permalink":"http://www.gcidea.info/categories/搭建部署/阿里云/"}],"tags":[{"name":"搭建部署","slug":"搭建部署","permalink":"http://www.gcidea.info/tags/搭建部署/"},{"name":"版本控制","slug":"版本控制","permalink":"http://www.gcidea.info/tags/版本控制/"},{"name":"持续集成CI","slug":"持续集成CI","permalink":"http://www.gcidea.info/tags/持续集成CI/"}]},{"title":"【阿里云ECS】LAMP开发环境的完整搭建配置过程","slug":"lamp","date":"2016-12-02T14:15:18.000Z","updated":"2018-12-12T16:08:28.646Z","comments":true,"path":"2016/12/02/lamp/","link":"","permalink":"http://www.gcidea.info/2016/12/02/lamp/","excerpt":"前言 为了顺利进行web开发，一套完整易用的开发环境是十分必要的，这可以大大提高团队的合作和开发效率。这里说的开发环境包括IDE，数据库，开发语言组件，版本控制工具等一系列内容。最近在使用的是比较流行的php开发架构，在windows下，无疑推荐WAMP + MySQL-Front + phpStorm，WAMP集成了Apache、MySQL、PHP，可以免除许多安装配置的问题。这样的环境在具体开发中是没有什么问题的，但是当项目上线并且需要版本维护时，我们还是要在Linux系统上进行部署。 基于这样的需求，最近搭建了一套完整的LAMP环境并测试通过，可以实现代码版本控制，APP端API测试调用，项目自动化部署持续集成(CI)。包括的主要内容有：","text":"前言 为了顺利进行web开发，一套完整易用的开发环境是十分必要的，这可以大大提高团队的合作和开发效率。这里说的开发环境包括IDE，数据库，开发语言组件，版本控制工具等一系列内容。最近在使用的是比较流行的php开发架构，在windows下，无疑推荐WAMP + MySQL-Front + phpStorm，WAMP集成了Apache、MySQL、PHP，可以免除许多安装配置的问题。这样的环境在具体开发中是没有什么问题的，但是当项目上线并且需要版本维护时，我们还是要在Linux系统上进行部署。 基于这样的需求，最近搭建了一套完整的LAMP环境并测试通过，可以实现代码版本控制，APP端API测试调用，项目自动化部署持续集成(CI)。包括的主要内容有： 1.Apache组件； 2.MariaDB组件（Centos7中替换掉了MySQL）； 3.phpMyAdmin数据库管理组件； 4.PHP组件； 5.GitLab搭建； 6.GitLab-CI的配置与使用。 为了完整实现上述过程，自然还需要一些其他组件的安装配置，比如node环境，git环境等等。 本文将详细记录整个LAMP开发环境的搭建过程，这个过程中确实遇到了不少问题，通过官方文档，一些论坛，博客等基本得到了解决或找到了其它的解决方式。 对于版本控制和持续集成部分，即GitLab相关的内容，会在下一篇文章中单独详细讲述。 关键词 LAMP | 部署 | Centos | Apache | MariaDB | PHP 准备工具 部署环境：阿里云ECS Centos7.0 64bit 远程连接：Xshell 5 文件传输：Xftp 5 阿里云ECS（Centos7）基本文件目录结构阿里云上的centos包含了基本的Linux系统的必需目录。具体如下：其中各个目录的主要作用有很多资料可以查阅，参考《鸟哥的Linux私房菜》。 Apache的安装与配置1.Centos7默认已经安装httpd服务，只是没有启动。可以通过如下命令安装# yum install httpd 注：httpd是Apache超文本传输协议(HTTP)服务器的主程序。被设计为一个独立运行的后台进程，它会建立一个处理请求的子进程或线程池。 具体安装过程如下：2.成功安装后，启动apache,并且设置系统让 Apache 开机自动启动。这里本来使用的是这两条命令：12# service httpd start //启动Apache# chkconfig httpd on //设置开机自启 但是系统给出了如下的提示：出现这个提示的原因是CentOS7已经切换到systemd，系统指令也有所变化。之前用于启动、重启、停止各种服务的service作为向后兼容的指令还能使用，但是系统会自动重定向该指令到新的指令/bin/systemctl 来执行，并给出提示。因此，这里也就顺便对常用命令的变化做以对比和总结（以对httpd服务的操作为例）： 【启动服务】旧：# service http start新：# systemctl start httpd 【停止服务】旧：# service http stop新：# systemctl stop httpd 【重启服务】旧：# service http restart新：# systemctl restart httpd 【重新加载】旧：# service http reload新：# systemctl reload httpd 【查看服务状态】旧：# service httpd status新：# systemctl status httpd 【设置开机自启动】旧：# chkconfig httpd on新：# systemctl enable httpd 【设置开机不自启动】旧：# chkconfig httpd off新：# systemctl disable httpd 【检查服务状态】旧：# chkconfig httpd新：# systemctl is-enabled httpd 【列举所有服务】旧：# chkconfig list新：# systemctl list-unit-files --type=service 3.最后，我们进行防火墙设置 注：SELinux(Security-Enhanced Linux) 是美国国家安全局（NSA）对于强制访问控制的实现，在这种访问控制体系的限制下，进程只能访问那些在他的任务中所需要文件。但是由于一般情况下没有对SELinux进行细致研究，不懂其中原理，可能还会对其他服务的使用造成影响，因此这里将其关闭。 3.1 关闭内核防火墙。使用命令：# vi /etc/selinux/config将SELINUX=enforcing 改成SELINUX=disabled3.2 在iptables防火墙策略里设置网站运行的80端口和数据库的3306端口，使用命令：# vi /etc/sysconfig/iptables添加以下2个记录：12-A INPUT -p tcp -m tcp --sport 1024:65534 --dport 3306 -j ACCEPT-A INPUT -p tcp -m tcp --sport 1024:65534 --dport 80 -j ACCEPT 具体过程如下图所示： MariaDB的安装与配置 注：MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。在存储引擎方面，使用XtraDB（英语：XtraDB）来代替MySQL的InnoDB。 MariaDB由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发，他早前曾以10亿美元的价格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，MySQL的所有权也落入Oracle的手中。MariaDB名称来自Michael Widenius的女儿Maria的名字。 Centos6或早期的版本中提供的是MySQL的服务器/客户端安装包，但Centos7已使用了MariaDB替代了默认的MySQL。因此本文后续给出的是MariaDB的安装与配置过程。 使用如下命令安装MariaDB及相关组件：yum install mariadb mariadb-server mariadb-libs具体过程如下： 设置MariaDB开机自启动并重启MariaDB服务# systemctl enable mariadb# systemctl restart mariadb如下图所示： 配置MariaDB服务(主要是设置密码，用户账户等)# mysql_secure_installation如下图所示： PHP的安装与配置 使用如下命令安装PHP及相关组件： 1yum install php php-mysql php-gd libjpeg* php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-bcmath php-mhash 重启之前安装完成的Apache httpd服务和MariaDB服务：# systemctl restart httpd# systemctl restart mariadb Apache默认网站部署目录是/var/www/html，我们在里面创建index.php测试一下环境是否可以正常运行：使用命令12cd /var/www/htmlvi index.php 内容如下：123&lt;?php phpinfo();?&gt; 4.在浏览器地址栏中输入http://阿里云ECS主机ip/index.php可以看到如下页面，说明安装配置成功。 5.【可选】PHP的版本升级 如上图我们可以看到，PHP的版本是5.4.16。我在使用过程中，前期没有遇到什么问题。直到写图片上传服务之类的功能，在本地WAMPServer测试正常的代码部署到ECS后就会报错，错误如下： 网上也查了一些解决方案，问题主要就是缺失curl这个类文件。提供的一些解决方案有单独编译安装这个类，再在php的配置文件中做extension，或者直接源码编译安装其他版本的PHP。感觉步骤较多，比较麻烦。因此选择了更换yum源直接升级高版本php(大于等于php5.5)： 1.配置yum源: 12# yum install epel-release# rpm -ivh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm 2.安装php5.6: 1# yum install --enablerepo=remi --enablerepo=remi-php56 php php-opcache php-devel php-mbstring php-mcrypt php-mysqlnd php-phpunit-PHPUnit php-pecl-xdebug php-pecl-xhprof 3.查看php版本，看是否安装成功： # php -v 结果如下图： 此时再在线上环境进行测试，图片服务已经可以正常使用。 phpMyAdmin的安装与配置 至此，我们已经具备了一套基本的LAMP环境，通过在“L”上进行部署，“A”提供http服务，运行“P”的php后台代码，使用“M”提供数据存储，基本实现一个网站的功能。这里还有一个小问题，使用mariadb的命令行进行数据管理十分不便，我们可以安装phpMyAdmin进行可视化管理。 安装使用命令：# yum install phpmyadmin php-mcrypt 配置使用命令：# vi /etc/httpd/conf.d/phpMyAdmin.conf默认情况下，Centos7上的phpMyAdmin只允许从回环地址(127.0.0.1)访问。为了能远程连接，需要改动它的配置。我们要做的是找出并注释掉带有”Require ip XXXX”字样的4处代码，用”Require all granted”取而代之。内容如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# phpMyAdmin - Web based MySQL browser written in php## Allows only localhost by default## But allowing phpMyAdmin to anyone other than localhost should be considered# dangerous unless properly secured by SSLAlias /phpMyAdmin /usr/share/phpMyAdminAlias /phpmyadmin /usr/share/phpMyAdmin&lt;Directory /usr/share/phpMyAdmin/&gt; AddDefaultCharset UTF-8 &lt;IfModule mod_authz_core.c&gt; # Apache 2.4 &lt;RequireAny&gt;# Require ip 127.0.0.1# Require ip ::1 Require all granted &lt;/RequireAny&gt; &lt;/IfModule&gt; &lt;IfModule !mod_authz_core.c&gt; # Apache 2.2 Order Deny,Allow Deny from All Allow from 127.0.0.1 Allow from ::1 &lt;/IfModule&gt;&lt;/Directory&gt;&lt;Directory /usr/share/phpMyAdmin/setup/&gt; &lt;IfModule mod_authz_core.c&gt; # Apache 2.4 &lt;RequireAny&gt;# Require ip 127.0.0.1# Require ip ::1 Require all granted &lt;/RequireAny&gt; &lt;/IfModule&gt; &lt;IfModule !mod_authz_core.c&gt; # Apache 2.2 Order Deny,Allow Deny from All Allow from 127.0.0.1 Allow from ::1 &lt;/IfModule&gt;&lt;/Directory&gt;# These directories do not require access over HTTP - taken from the original# phpMyAdmin upstream tarball#&lt;Directory /usr/share/phpMyAdmin/libraries/&gt; Order Deny,Allow Deny from All Allow from None&lt;/Directory&gt;&lt;Directory /usr/share/phpMyAdmin/setup/lib/&gt; Order Deny,Allow Deny from All Allow from None&lt;/Directory&gt;&lt;Directory /usr/share/phpMyAdmin/setup/frames/&gt; Order Deny,Allow Deny from All Allow from None&lt;/Directory&gt;# This configuration prevents mod_security at phpMyAdmin directories from# filtering SQL etc. This may break your mod_security implementation.##&lt;IfModule mod_security.c&gt;# &lt;Directory /usr/share/phpMyAdmin/&gt;# SecRuleInheritance Off# &lt;/Directory&gt;#&lt;/IfModule&gt; 测试安装完成后，我们可以通过http://阿里云ECS主机ip/phpmyadmin进行访问（注：这里默认使用的是主机ip默认端口，但当后续搭建了GitLab服务后，会产生端口冲突，需要修改Apache的默认端口，这在下一篇文章中遇到时会详细阐述。）登录界面如下(注：用户名和密码就是上文配置MariaDB时设置的)：主控制面板如下，在这里我们可以方便的新建数据库，数据表，查询，导入导出sql文件等等。 小结 至此，我们就建立了一套完整的LAMP开发环境，并具备了数据库管理工具。 现在我们就可以将新建的项目工程文件夹放在/var/www/html目录下，通过http://主机ip:port/project/index.php进行访问了。 这时可能会遇到一个问题，就是访问后页面报错，在Linux系统下网站根目录权限755;权限不足导致访问失败。这时只要更该相关目录权限即可解决，主要&gt;是Application目录（使用thinkphp框架的工程中的一个目录），如果还不行可以尝试扩大更改权限的范围，但风险随之增大，应注意控制。 这样的LAMP开发环境有以下几个作用和好处： 开发阶段：使用Git进行版本控制，GitLab进行代码跟踪与持续集成 测试阶段：为测试人员提供最新的版本进行问题跟踪与反馈；为APP端提供接口API测试环境 运行阶段：提供给用户进行使用","categories":[{"name":"搭建部署","slug":"搭建部署","permalink":"http://www.gcidea.info/categories/搭建部署/"},{"name":"阿里云","slug":"搭建部署/阿里云","permalink":"http://www.gcidea.info/categories/搭建部署/阿里云/"}],"tags":[{"name":"搭建部署","slug":"搭建部署","permalink":"http://www.gcidea.info/tags/搭建部署/"},{"name":"LAMP","slug":"LAMP","permalink":"http://www.gcidea.info/tags/LAMP/"}]},{"title":"React Router的history探究","slug":"react-router-history","date":"2016-12-01T05:54:23.000Z","updated":"2018-12-12T16:07:46.795Z","comments":true,"path":"2016/12/01/react-router-history/","link":"","permalink":"http://www.gcidea.info/2016/12/01/react-router-history/","excerpt":"","text":"前言 路由是单页应用中十分重要的概念。具体在react中，react-router为我们提供了一套完整的路由机制。 概述 项目history相关文档主页：Histories。文档的讲解十分详细。本文只是通过在实际项目中history的状态变化进行简单小结。以dva应用为例，经过这样的配置后，容器组件可以在props中拿到history对象和相关参数。 表现如上所示，history中包含了一系列方法，这里主要选择两个进行说明： history.listen() 利用这个函数可以对路由变化进行监听，从而触发其他事件：123456789subscriptions: &#123; setup(&#123; dispatch, history &#125;) &#123; history.listen(location =&gt; &#123; if(location.pathname === '/home')&#123; dispatch(&#123;type: 'query'&#125;); &#125; &#125;) &#125; &#125;, 2.history.goBack() 利用此函数可以实现回退，回到上一个路由所匹配的组件，但是无法记录上一个页面的状态：1234567891011121314151617181920212223class LiveDetail extends Component &#123; constructor(props, context) &#123; super(props, context); this.goBack = this.goBack.bind(this); &#125; static contextTypes = &#123; router: React.PropTypes.object.isRequired &#125;; goBack()&#123; this.context.router.goBack(); &#125; componentWillReceiveProps(nextProps) &#123; ... &#125; render() &#123; .... &#125;&#125;","categories":[{"name":"React","slug":"React","permalink":"http://www.gcidea.info/categories/React/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://www.gcidea.info/tags/前端框架/"},{"name":"实现/应用","slug":"实现-应用","permalink":"http://www.gcidea.info/tags/实现-应用/"},{"name":"前端工程化","slug":"前端工程化","permalink":"http://www.gcidea.info/tags/前端工程化/"},{"name":"React","slug":"React","permalink":"http://www.gcidea.info/tags/React/"}]},{"title":"客户端代理配置的几种常见方式","slug":"client-proxy-configurations","date":"2016-11-30T03:27:43.000Z","updated":"2018-12-12T16:08:53.201Z","comments":true,"path":"2016/11/30/client-proxy-configurations/","link":"","permalink":"http://www.gcidea.info/2016/11/30/client-proxy-configurations/","excerpt":"","text":"PAC文件 PAC文件是一些简单的javascript程序，可以在运行过程中计算代理设置，是一种动态方案。配置方案示例如下（以登录内部局域网为例）：在IE浏览器Internet选项做如下配置，填写的地址是目标服务器上的代理配置文件根据已有信息访问代理进行登录后可以使用。 PAC文件结构如下： Chrome插件SwitchyOmegaCharles Web Debugging Proxy注：以上两种方式，详见另一篇使用SwitchyOmega和Charles配置统一的开发和生产环境","categories":[{"name":"搭建部署","slug":"搭建部署","permalink":"http://www.gcidea.info/categories/搭建部署/"},{"name":"代理","slug":"搭建部署/代理","permalink":"http://www.gcidea.info/categories/搭建部署/代理/"}],"tags":[{"name":"搭建部署","slug":"搭建部署","permalink":"http://www.gcidea.info/tags/搭建部署/"},{"name":"前端工程化","slug":"前端工程化","permalink":"http://www.gcidea.info/tags/前端工程化/"},{"name":"代理配置","slug":"代理配置","permalink":"http://www.gcidea.info/tags/代理配置/"}]},{"title":"Bootstrap等前端框架栅格系统的原理","slug":"bootstrap-grid-principle","date":"2016-11-26T16:22:16.000Z","updated":"2018-12-12T16:08:54.728Z","comments":true,"path":"2016/11/27/bootstrap-grid-principle/","link":"","permalink":"http://www.gcidea.info/2016/11/27/bootstrap-grid-principle/","excerpt":"","text":"栅格系统基本使用方法基本原理 Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。它包含了易于使用的预定义类，还有强大的mixin 用于生成更具语义的布局。 栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。下面就介绍一下 Bootstrap 栅格系统的工作原理： “行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。 通过“行（row）”在水平方向创建一组“列（column）”。 你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。 类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局。 通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行（row）”所包含的“列（column）”抵消掉了padding。 负值的 margin就是下面的示例为什么是向外突出的原因。在栅格列中的内容排成一行。 栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个 .col-xs-4 来创建。 如果一“行（row）”中包含了的“列（column）”大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列。 媒体查询 在栅格系统中，使用媒体查询创建关键点分界阈值。1234567891011/* 超小屏幕（手机，小于 768px） *//* 没有任何媒体查询相关的代码，因为这在 Bootstrap 中是默认的（还记得 Bootstrap 是移动设备优先的吗？） *//* 小屏幕（平板，大于等于 768px） */@media (min-width: @screen-sm-min) &#123; ... &#125;/* 中等屏幕（桌面显示器，大于等于 992px） */@media (min-width: @screen-md-min) &#123; ... &#125;/* 大屏幕（大桌面显示器，大于等于 1200px） */@media (min-width: @screen-lg-min) &#123; ... &#125; 实例1234567891011121314151617181920212223242526272829&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-8\"&gt;.col-md-8&lt;/div&gt; &lt;div class=\"col-md-4\"&gt;.col-md-4&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4\"&gt;.col-md-4&lt;/div&gt; &lt;div class=\"col-md-4\"&gt;.col-md-4&lt;/div&gt; &lt;div class=\"col-md-4\"&gt;.col-md-4&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt;.col-md-6&lt;/div&gt; &lt;div class=\"col-md-6\"&gt;.col-md-6&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 效果 源码简要分析 以下以bootstrap-3.3.5-dist中css/boostrap.css的1585行开始为准： 1.包裹容器的样式12345678910111213141516.container &#123; padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto;&#125;.container-fluid &#123; padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto;&#125;.row &#123; margin-right: -15px; margin-left: -15px;&#125; 2.每个列的宽度(以.col-xs-x为例)123456789101112131415161718192021222324252627282930313233343536373839404142434445.col-xs-1, .col-sm-1, .col-md-1, .col-lg-1, .col-xs-2, .col-sm-2, .col-md-2, .col-lg-2, .col-xs-3, .col-sm-3, .col-md-3, .col-lg-3, .col-xs-4, .col-sm-4, .col-md-4, .col-lg-4, .col-xs-5, .col-sm-5, .col-md-5, .col-lg-5, .col-xs-6, .col-sm-6, .col-md-6, .col-lg-6, .col-xs-7, .col-sm-7, .col-md-7, .col-lg-7, .col-xs-8, .col-sm-8, .col-md-8, .col-lg-8, .col-xs-9, .col-sm-9, .col-md-9, .col-lg-9, .col-xs-10, .col-sm-10, .col-md-10, .col-lg-10, .col-xs-11, .col-sm-11, .col-md-11, .col-lg-11, .col-xs-12, .col-sm-12, .col-md-12, .col-lg-12 &#123; position: relative; min-height: 1px; padding-right: 15px; padding-left: 15px;&#125;.col-xs-1, .col-xs-2, .col-xs-3, .col-xs-4, .col-xs-5, .col-xs-6, .col-xs-7, .col-xs-8, .col-xs-9, .col-xs-10, .col-xs-11, .col-xs-12 &#123; float: left;&#125;.col-xs-12 &#123; width: 100%;&#125;.col-xs-11 &#123; width: 91.66666667%;&#125;.col-xs-10 &#123; width: 83.33333333%;&#125;.col-xs-9 &#123; width: 75%;&#125;.col-xs-8 &#123; width: 66.66666667%;&#125;.col-xs-7 &#123; width: 58.33333333%;&#125;.col-xs-6 &#123; width: 50%;&#125;.col-xs-5 &#123; width: 41.66666667%;&#125;.col-xs-4 &#123; width: 33.33333333%;&#125;.col-xs-3 &#123; width: 25%;&#125;.col-xs-2 &#123; width: 16.66666667%;&#125;.col-xs-1 &#123; width: 8.33333333%;&#125; 3.媒体查询123456789101112131415@media (min-width: 768px) &#123; .container &#123; width: 750px; &#125;&#125;@media (min-width: 992px) &#123; .container &#123; width: 970px; &#125;&#125;@media (min-width: 1200px) &#123; .container &#123; width: 1170px; &#125;&#125; 4.列偏移(以.col-xs-x为例)123456789101112131415161718192021222324252627282930313233343536373839.col-xs-offset-12 &#123; margin-left: 100%;&#125;.col-xs-offset-11 &#123; margin-left: 91.66666667%;&#125;.col-xs-offset-10 &#123; margin-left: 83.33333333%;&#125;.col-xs-offset-9 &#123; margin-left: 75%;&#125;.col-xs-offset-8 &#123; margin-left: 66.66666667%;&#125;.col-xs-offset-7 &#123; margin-left: 58.33333333%;&#125;.col-xs-offset-6 &#123; margin-left: 50%;&#125;.col-xs-offset-5 &#123; margin-left: 41.66666667%;&#125;.col-xs-offset-4 &#123; margin-left: 33.33333333%;&#125;.col-xs-offset-3 &#123; margin-left: 25%;&#125;.col-xs-offset-2 &#123; margin-left: 16.66666667%;&#125;.col-xs-offset-1 &#123; margin-left: 8.33333333%;&#125;.col-xs-offset-0 &#123; margin-left: 0;&#125; 5.列排序(以.col-xs-x为例)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778.col-xs-pull-12 &#123; right: 100%;&#125;.col-xs-pull-11 &#123; right: 91.66666667%;&#125;.col-xs-pull-10 &#123; right: 83.33333333%;&#125;.col-xs-pull-9 &#123; right: 75%;&#125;.col-xs-pull-8 &#123; right: 66.66666667%;&#125;.col-xs-pull-7 &#123; right: 58.33333333%;&#125;.col-xs-pull-6 &#123; right: 50%;&#125;.col-xs-pull-5 &#123; right: 41.66666667%;&#125;.col-xs-pull-4 &#123; right: 33.33333333%;&#125;.col-xs-pull-3 &#123; right: 25%;&#125;.col-xs-pull-2 &#123; right: 16.66666667%;&#125;.col-xs-pull-1 &#123; right: 8.33333333%;&#125;.col-xs-pull-0 &#123; right: auto;&#125;.col-xs-push-12 &#123; left: 100%;&#125;.col-xs-push-11 &#123; left: 91.66666667%;&#125;.col-xs-push-10 &#123; left: 83.33333333%;&#125;.col-xs-push-9 &#123; left: 75%;&#125;.col-xs-push-8 &#123; left: 66.66666667%;&#125;.col-xs-push-7 &#123; left: 58.33333333%;&#125;.col-xs-push-6 &#123; left: 50%;&#125;.col-xs-push-5 &#123; left: 41.66666667%;&#125;.col-xs-push-4 &#123; left: 33.33333333%;&#125;.col-xs-push-3 &#123; left: 25%;&#125;.col-xs-push-2 &#123; left: 16.66666667%;&#125;.col-xs-push-1 &#123; left: 8.33333333%;&#125;.col-xs-push-0 &#123; left: auto;&#125;","categories":[{"name":"FE综合","slug":"FE综合","permalink":"http://www.gcidea.info/categories/FE综合/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"前端框架","slug":"前端框架","permalink":"http://www.gcidea.info/tags/前端框架/"},{"name":"FE","slug":"FE","permalink":"http://www.gcidea.info/tags/FE/"}]},{"title":"客户端浏览器检测","slug":"browser-hack","date":"2016-11-24T16:00:39.000Z","updated":"2018-12-12T16:08:54.317Z","comments":true,"path":"2016/11/25/browser-hack/","link":"","permalink":"http://www.gcidea.info/2016/11/25/browser-hack/","excerpt":"","text":"前言 几种web浏览器在实现相关标准时会有一些差异和区别，这可能会给开发带来一些问题。此时就会需要进行客户端检测从而给出不同的方案。但是，从根本上来讲，只要能够找到更通用的方法，就应该优先采用更通用的方法，先设计最通用的方案，然后再使用特定于浏览器的技术增强该方案。《JavaScript权威指南》相关描述如下： 检测方法与主要参数navigator对象的主要参数 方法 主流浏览器的userAgent示例ChromeMozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.152 Safari/537.36 FirefoxMozilla/5.0 (Windows NT 6.1; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0 SafariMozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2 OperaMozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.152 Safari/537.36 OPR/29.0.1795.60； IE IE7如下：mozilla/4.0 (compatible; msie 7.0; windows nt 6.1; wow64; trident/7.0; slcc2; .net clr 2.0.50727; .net clr 3.5.30729; .net clr 3.0.30729; media center pc 6.0; infopath.3; .net4.0c; .net4.0e) IE8如下：mozilla/4.0 (compatible; msie 8.0; windows nt 6.1; wow64; trident/7.0; slcc2; .net clr 2.0.50727; .net clr 3.5.30729; .net clr 3.0.30729; media center pc 6.0; infopath.3; .net4.0c; .net4.0e) 但是IE9+ 对字符串的格式做了一点调整；mozilla的版本号增加到5.0; IE9如下：mozilla/5.0 (compatible; msie 9.0; windows nt 6.1; wow64; trident/7.0; slcc2; .net clr 2.0.50727; .net clr 3.5.30729; .net clr 3.0.30729; media center pc 6.0; infopath.3; .net4.0c; .net4.0e) IE10如下：mozilla/5.0 (compatible; msie 10.0; windows nt 6.1; wow64; trident/7.0; slcc2; .net clr 2.0.50727; .net clr 3.5.30729; .net clr 3.0.30729; media center pc 6.0; infopath.3; .net4.0c; .net4.0e) IE11如下：mozilla/5.0 (windows nt 6.1; wow64; trident/7.0; slcc2; .net clr 2.0.50727; .net clr 3.5.30729; .net clr 3.0.30729; media center pc 6.0; infopath.3; .net4.0c; .net4.0e; rv:11.0) like gecko IOS和Androidios设备的基本格式如下：Mozilla/5.0 (平台；加密类型；操作系统或CPU like Mac OS x;语言)AppleWebKit/ AppleWebKit版本号(KHTML,like Gecko) Version/浏览器版本号 Android浏览器中默认格式与IOS格式相似，没有移动版本号(但有Mobile记号)：Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91)AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1 对浏览器客户端检测的应用实例 手机淘宝团队开源的移动端自适应方案lib-flexible就需要根据当前浏览器信息对页面html元素设置不同的font-size从而达到动态修改rem基准px值的目的，其中一段源码如下：12345678910111213141516171819if (!dpr &amp;&amp; !scale) &#123; var isAndroid = win.navigator.appVersion.match(/android/gi); var isIPhone = win.navigator.appVersion.match(/iphone/gi); var devicePixelRatio = win.devicePixelRatio; if (isIPhone) &#123; // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案 if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) &#123; dpr = 3; &#125; else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2))&#123; dpr = 2; &#125; else &#123; dpr = 1; &#125; &#125; else &#123; // 其他设备下，仍旧使用1倍的方案 dpr = 1; &#125; scale = 1 / dpr; &#125; 客户端检测代码参考： http://web.jobbole.com/82452/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139var client = function()&#123; var engine = &#123; // 呈现引擎 ie: 0, gecko:0, webkit: 0, khtml:0, opera:0, //其他版本号 ver: null &#125;; var browser = &#123; // 浏览器 ie: 0, firefox:0, safari:0, konq:0, opera:0, chrome:0, // 其他的版本 ver: null &#125;; var system = &#123; win: false, mac: false, xll: false, // 移动设备 iphone: false, ipod: false, ipad: false, ios: false, android:false &#125;; // 在此检测呈现引擎，平台和设备 return &#123; engine: engine, browser: browser, system: system &#125;; &#125;(); var engine = client; var browser = client; var ua = navigator.userAgent.toLowerCase(); if(ua.match(/opr\\/([\\d\\.]+)/) || window.opera) &#123; var result = ua.match(/opr\\/([\\d\\.]+)/); engine.ver = browser.ver = result[1]; engine.opera = browser.opera = parseFloat(engine.ver); if(window.opera) &#123; engine.ver = browser.ver = window.opera.version(); engine.opera = browser.opera = parseFloat(engine.ver); &#125; &#125;else if(/applewebkit\\/(\\S+)/.test(ua)) &#123; engine.ver = RegExp[\"$1\"]; engine.webkit = parseFloat(engine.ver); // 确定是chrome还是safari /* * chrome用户代理字符串 * Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) * Chrome/42.0.2311.152 Safari/537.36 */ if(/chrome\\/(\\S+)/.test(ua)) &#123; browser.ver = RegExp[\"$1\"]; browser.chrome = parseFloat(browser.ver); &#125;else if(/version\\/(\\S+)/.test(ua)) &#123; /* * safari用户代理字符串 * Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) * Version/5.1.7 Safari/534.57.2 */ browser.ver = RegExp[\"$1\"]; browser.safari = parseFloat(browser.ver); &#125;else &#123; //近似地确定版本号 var safariVersion = 1; if (engine.webkit &lt; 100)&#123; safariVersion = 1; &#125; else if (engine.webkit &lt; 312)&#123; safariVersion = 1.2; &#125; else if (engine.webkit &lt; 412)&#123; safariVersion = 1.3; &#125; else &#123; safariVersion = 2; &#125; browser.safari = browser.ver = safariVersion; &#125; &#125;else if (/khtml\\/(\\S+)/.test(ua) || /konqueror\\/([^;]+)/.test(ua))&#123; engine.ver = browser.ver = RegExp[\"$1\"]; engine.khtml = browser.konq = parseFloat(engine.ver); &#125;else if(/rv:([^\\)]+)\\) gecko\\/\\d&#123;8&#125;/.test(ua))&#123; engine.ver = RegExp[\"$1\"]; engine.gecko = parseFloat(engine.ver); /* * firefox的用户代理的字符串 * Mozilla/5.0 (Windows NT 6.1; WOW64; rv:38.0) * Gecko/20100101 Firefox/38.0 */ // 确定是不是firefox if(/firefox\\/(\\S+)/.test(ua)) &#123; browser.ver = RegExp[\"$1\"]; browser.firefox = parseFloat(browser.ver); &#125; &#125;else if (/msie ([^;]+)/.test(ua) || \"ActiveXObject\" in window)&#123; if(\"ActiveXObject\" in window) &#123; if(/msie ([^;]+)/.test(ua)) &#123; engine.ver = browser.ver = RegExp[\"$1\"]; engine.ie = browser.ie = parseFloat(engine.ver); &#125;else &#123; if(/rv:([^\\)]+)\\)/.test(ua)) &#123; engine.ver = browser.ver = RegExp[\"$1\"]; engine.ie = browser.ie = parseFloat(engine.ver); &#125; &#125; &#125; &#125; // 检测平台 var system = client; var platform = navigator.platform; system.win = platform.indexOf(\"Win\") == 0; system.mac = platform.indexOf(\"Mac\") == 0; system.x11 = (platform.indexOf(\"X11\") == 0) || (platform.indexOf(\"Linux\") == 0); // 移动设备 system.iphone = ua.indexOf(\"iphone\") &gt; -1; system.ipod = ua.indexOf(\"ipod\") &gt; -1; system.ipad = ua.indexOf(\"ipad\") &gt; -1; //检测iOS 版本 if (system.mac &amp;&amp; ua.indexOf(\"mobile\") &gt; -1)&#123; if (/cpu (?:iphone )?os (\\d+_\\d+)/.test(ua))&#123; system.ios = parseFloat(RegExp.$1.replace(\"_\", \".\")); &#125; else &#123; system.ios = 2; //不能真正检测出来，所以只能猜测 &#125; &#125; //检测Android 版本 if (/android (\\d+\\.\\d+)/.test(ua))&#123; system.android = parseFloat(RegExp.$1); &#125;","categories":[{"name":"FE综合","slug":"FE综合","permalink":"http://www.gcidea.info/categories/FE综合/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"浏览器","slug":"浏览器","permalink":"http://www.gcidea.info/tags/浏览器/"},{"name":"HTTP","slug":"HTTP","permalink":"http://www.gcidea.info/tags/HTTP/"},{"name":"兼容性","slug":"兼容性","permalink":"http://www.gcidea.info/tags/兼容性/"}]},{"title":"使用数组和链表实现背包、队列、栈3种集合类数据结构","slug":"bag-queue-stack","date":"2016-11-22T14:15:18.000Z","updated":"2018-12-12T16:08:55.554Z","comments":true,"path":"2016/11/22/bag-queue-stack/","link":"","permalink":"http://www.gcidea.info/2016/11/22/bag-queue-stack/","excerpt":"","text":"API背包 队列 栈 实现背包1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class Bag&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; private Node&lt;Item&gt; first; // beginning of bag private int n; // number of elements in bag // helper linked list class private static class Node&lt;Item&gt; &#123; private Item item; private Node&lt;Item&gt; next; &#125; /** * Initializes an empty bag. */ public Bag() &#123; first = null; n = 0; &#125; /** * Returns true if this bag is empty. * * @return &#123;@code true&#125; if this bag is empty; * &#123;@code false&#125; otherwise */ public boolean isEmpty() &#123; return first == null; &#125; /** * Returns the number of items in this bag. * * @return the number of items in this bag */ public int size() &#123; return n; &#125; /** * Adds the item to this bag. * * @param item the item to add to this bag */ public void add(Item item) &#123; Node&lt;Item&gt; oldfirst = first; first = new Node&lt;Item&gt;(); first.item = item; first.next = oldfirst; n++; &#125; /** * Returns an iterator that iterates over the items in this bag in arbitrary order. * * @return an iterator that iterates over the items in this bag in arbitrary order */ public Iterator&lt;Item&gt; iterator() &#123; return new ListIterator&lt;Item&gt;(first); &#125; // an iterator, doesn't implement remove() since it's optional private class ListIterator&lt;Item&gt; implements Iterator&lt;Item&gt; &#123; private Node&lt;Item&gt; current; public ListIterator(Node&lt;Item&gt; first) &#123; current = first; &#125; public boolean hasNext() &#123; return current != null; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public Item next() &#123; if (!hasNext()) throw new NoSuchElementException(); Item item = current.item; current = current.next; return item; &#125; &#125; /** * Unit tests the &#123;@code Bag&#125; data type. * * @param args the command-line arguments */ public static void main(String[] args) &#123; Bag&lt;String&gt; bag = new Bag&lt;String&gt;(); while (!StdIn.isEmpty()) &#123; String item = StdIn.readString(); bag.add(item); &#125; StdOut.println(\"size of bag = \" + bag.size()); for (String s : bag) &#123; StdOut.println(s); &#125; &#125;&#125; 队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; private Node&lt;Item&gt; first; // beginning of queue private Node&lt;Item&gt; last; // end of queue private int n; // number of elements on queue // helper linked list class private static class Node&lt;Item&gt; &#123; private Item item; private Node&lt;Item&gt; next; &#125; /** * Initializes an empty queue. */ public Queue() &#123; first = null; last = null; n = 0; &#125; /** * Returns true if this queue is empty. * * @return &#123;@code true&#125; if this queue is empty; &#123;@code false&#125; otherwise */ public boolean isEmpty() &#123; return first == null; &#125; /** * Returns the number of items in this queue. * * @return the number of items in this queue */ public int size() &#123; return n; &#125; /** * Returns the item least recently added to this queue. * * @return the item least recently added to this queue * @throws NoSuchElementException if this queue is empty */ public Item peek() &#123; if (isEmpty()) throw new NoSuchElementException(\"Queue underflow\"); return first.item; &#125; /** * Adds the item to this queue. * * @param item the item to add */ public void enqueue(Item item) &#123; Node&lt;Item&gt; oldlast = last; last = new Node&lt;Item&gt;(); last.item = item; last.next = null; if (isEmpty()) first = last; else oldlast.next = last; n++; &#125; /** * Removes and returns the item on this queue that was least recently added. * * @return the item on this queue that was least recently added * @throws NoSuchElementException if this queue is empty */ public Item dequeue() &#123; if (isEmpty()) throw new NoSuchElementException(\"Queue underflow\"); Item item = first.item; first = first.next; n--; if (isEmpty()) last = null; // to avoid loitering return item; &#125; /** * Returns a string representation of this queue. * * @return the sequence of items in FIFO order, separated by spaces */ public String toString() &#123; StringBuilder s = new StringBuilder(); for (Item item : this) &#123; s.append(item); s.append(' '); &#125; return s.toString(); &#125; /** * Returns an iterator that iterates over the items in this queue in FIFO order. * * @return an iterator that iterates over the items in this queue in FIFO order */ public Iterator&lt;Item&gt; iterator() &#123; return new ListIterator&lt;Item&gt;(first); &#125; // an iterator, doesn't implement remove() since it's optional private class ListIterator&lt;Item&gt; implements Iterator&lt;Item&gt; &#123; private Node&lt;Item&gt; current; public ListIterator(Node&lt;Item&gt; first) &#123; current = first; &#125; public boolean hasNext() &#123; return current != null; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public Item next() &#123; if (!hasNext()) throw new NoSuchElementException(); Item item = current.item; current = current.next; return item; &#125; &#125; /** * Unit tests the &#123;@code Queue&#125; data type. * * @param args the command-line arguments */ public static void main(String[] args) &#123; Queue&lt;String&gt; queue = new Queue&lt;String&gt;(); while (!StdIn.isEmpty()) &#123; String item = StdIn.readString(); if (!item.equals(\"-\")) queue.enqueue(item); else if (!queue.isEmpty()) StdOut.print(queue.dequeue() + \" \"); &#125; StdOut.println(\"(\" + queue.size() + \" left on queue)\"); &#125;&#125; 栈1.动态调整数组大小的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128public class ResizingArrayStack&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; private Item[] a; // array of items private int n; // number of elements on stack /** * Initializes an empty stack. */ public ResizingArrayStack() &#123; a = (Item[]) new Object[2]; n = 0; &#125; /** * Is this stack empty? * @return true if this stack is empty; false otherwise */ public boolean isEmpty() &#123; return n == 0; &#125; /** * Returns the number of items in the stack. * @return the number of items in the stack */ public int size() &#123; return n; &#125; // resize the underlying array holding the elements private void resize(int capacity) &#123; assert capacity &gt;= n; // textbook implementation Item[] temp = (Item[]) new Object[capacity]; for (int i = 0; i &lt; n; i++) &#123; temp[i] = a[i]; &#125; a = temp; // alternative implementation // a = java.util.Arrays.copyOf(a, capacity); &#125; /** * Adds the item to this stack. * @param item the item to add */ public void push(Item item) &#123; if (n == a.length) resize(2*a.length); // double size of array if necessary a[n++] = item; // add item &#125; /** * Removes and returns the item most recently added to this stack. * @return the item most recently added * @throws java.util.NoSuchElementException if this stack is empty */ public Item pop() &#123; if (isEmpty()) throw new NoSuchElementException(\"Stack underflow\"); Item item = a[n-1]; a[n-1] = null; // to avoid loitering n--; // shrink size of array if necessary if (n &gt; 0 &amp;&amp; n == a.length/4) resize(a.length/2); return item; &#125; /** * Returns (but does not remove) the item most recently added to this stack. * @return the item most recently added to this stack * @throws java.util.NoSuchElementException if this stack is empty */ public Item peek() &#123; if (isEmpty()) throw new NoSuchElementException(\"Stack underflow\"); return a[n-1]; &#125; /** * Returns an iterator to this stack that iterates through the items in LIFO order. * @return an iterator to this stack that iterates through the items in LIFO order. */ public Iterator&lt;Item&gt; iterator() &#123; return new ReverseArrayIterator(); &#125; // an iterator, doesn't implement remove() since it's optional private class ReverseArrayIterator implements Iterator&lt;Item&gt; &#123; private int i; public ReverseArrayIterator() &#123; i = n-1; &#125; public boolean hasNext() &#123; return i &gt;= 0; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public Item next() &#123; if (!hasNext()) throw new NoSuchElementException(); return a[i--]; &#125; &#125; /** * Unit tests the &#123;@code Stack&#125; data type. * * @param args the command-line arguments */ public static void main(String[] args) &#123; ResizingArrayStack&lt;String&gt; stack = new ResizingArrayStack&lt;String&gt;(); while (!StdIn.isEmpty()) &#123; String item = StdIn.readString(); if (!item.equals(\"-\")) stack.push(item); else if (!stack.isEmpty()) StdOut.print(stack.pop() + \" \"); &#125; StdOut.println(\"(\" + stack.size() + \" left on stack)\"); &#125;&#125; 2.链表实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; private Node&lt;Item&gt; first; // top of stack private int n; // size of the stack // helper linked list class private static class Node&lt;Item&gt; &#123; private Item item; private Node&lt;Item&gt; next; &#125; /** * Initializes an empty stack. */ public Stack() &#123; first = null; n = 0; &#125; /** * Returns true if this stack is empty. * * @return true if this stack is empty; false otherwise */ public boolean isEmpty() &#123; return first == null; &#125; /** * Returns the number of items in this stack. * * @return the number of items in this stack */ public int size() &#123; return n; &#125; /** * Adds the item to this stack. * * @param item the item to add */ public void push(Item item) &#123; Node&lt;Item&gt; oldfirst = first; first = new Node&lt;Item&gt;(); first.item = item; first.next = oldfirst; n++; &#125; /** * Removes and returns the item most recently added to this stack. * * @return the item most recently added * @throws NoSuchElementException if this stack is empty */ public Item pop() &#123; if (isEmpty()) throw new NoSuchElementException(\"Stack underflow\"); Item item = first.item; // save item to return first = first.next; // delete first node n--; return item; // return the saved item &#125; /** * Returns (but does not remove) the item most recently added to this stack. * * @return the item most recently added to this stack * @throws NoSuchElementException if this stack is empty */ public Item peek() &#123; if (isEmpty()) throw new NoSuchElementException(\"Stack underflow\"); return first.item; &#125; /** * Returns a string representation of this stack. * * @return the sequence of items in this stack in LIFO order, separated by spaces */ public String toString() &#123; StringBuilder s = new StringBuilder(); for (Item item : this) &#123; s.append(item); s.append(' '); &#125; return s.toString(); &#125; /** * Returns an iterator to this stack that iterates through the items in LIFO order. * * @return an iterator to this stack that iterates through the items in LIFO order */ public Iterator&lt;Item&gt; iterator() &#123; return new ListIterator&lt;Item&gt;(first); &#125; // an iterator, doesn't implement remove() since it's optional private class ListIterator&lt;Item&gt; implements Iterator&lt;Item&gt; &#123; private Node&lt;Item&gt; current; public ListIterator(Node&lt;Item&gt; first) &#123; current = first; &#125; public boolean hasNext() &#123; return current != null; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public Item next() &#123; if (!hasNext()) throw new NoSuchElementException(); Item item = current.item; current = current.next; return item; &#125; &#125; /** * Unit tests the &#123;@code Stack&#125; data type. * * @param args the command-line arguments */ public static void main(String[] args) &#123; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); while (!StdIn.isEmpty()) &#123; String item = StdIn.readString(); if (!item.equals(\"-\")) stack.push(item); else if (!stack.isEmpty()) StdOut.print(stack.pop() + \" \"); &#125; StdOut.println(\"(\" + stack.size() + \" left on stack)\"); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/tags/算法/"}]},{"title":"JavaScript的预加载与懒加载","slug":"js-preload-lazyload","date":"2016-11-22T04:40:47.000Z","updated":"2018-12-12T16:08:30.970Z","comments":true,"path":"2016/11/22/js-preload-lazyload/","link":"","permalink":"http://www.gcidea.info/2016/11/22/js-preload-lazyload/","excerpt":"","text":"预加载目的 增强用户的体验，当用户需要查看时可直接从本地缓存中渲染。。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白。但会加载服务器的负担。并且，如果不设置预加载，那么当需要渲染十分大的图片时，可能就会有“逐行扫描渲染”的感觉，用户体验不好。使用预加载的话，我们可以在图片完整渲染完成之前在页面上设置“loading”类的图标提示，而当图片数据完全获取后一次性直接将图片展现出来，提升用户体验。 做法典型方法如下：1234567891011function loadImage(url, callback) &#123; var img = new Image(); img.src = url; if (img.complete) &#123; // 如果图片已经存在于浏览器缓存，直接调用回调函数 防止IE6不执行onload BUG callback.call(img); return; &#125; img.onload = function () &#123; callback.call(img);//将回调函数的this替换为Image对象 &#125;;&#125;; 懒加载目的 延迟加载图片或符合某些条件时才加载某些图片。这样做的好处是减少不必要的请求。懒加载的主要目的是减轻服务端压力。 做法 纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟. 条件加载，符合某些条件，或触发了某些事件才开始异步下载。 可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。案例 参考网上一篇例子：网页与设备（浏览器）可视区域的关系：当页面过长的时候就会出现滚动条，一旦滚动了一部分，上面的页面就会看不到，上图中绿色部分就是那被隐藏的部分页面。那么，何时加载哪些图片，就是判断当前页面可视区域和图片位置的关系问题，判断是否在当前可视区域的顶部和底部的范围内，如果是就加载图，不是就不加载。 页面可视区域12viewTop = window.scrollY || window.pageYOffset;viewBottom = window.innerHeight + viewTop; viewTop表示可视区域顶部在整个文档Y方向上的坐标viewBottom表示可视区域底部在整个文档Y方向上的坐标 图片区域12nodeTop = node.getBoundingClientRect().top + viewTop;nodeBottom = nodeTop + node.offsetHeight; nodeTop表示图片顶部在整个文档Y方向上的坐标nodeBottom表示图片底部在整个文档Y方向上的坐标","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"前端工程化","slug":"前端工程化","permalink":"http://www.gcidea.info/tags/前端工程化/"}]},{"title":"使用AngularJs封装Tabs选项卡组件","slug":"angular-tabs","date":"2016-11-21T06:15:25.000Z","updated":"2018-12-12T16:08:55.963Z","comments":true,"path":"2016/11/21/angular-tabs/","link":"","permalink":"http://www.gcidea.info/2016/11/21/angular-tabs/","excerpt":"","text":"angular-table使用AngularJs封装Tabs选项卡组件 功能描述 该组件是管理系统中很常用的功能，平台使用者可能会同时使用不同模块的功能，这时候需要打开多个模块，Tabs组件是一种类似浏览器多标签页的效果。可以： 可以在多个模块的页面间进行切换 在某个页面上右键关闭 附带收起侧边栏功能 … 实现 demo源码托管于github，详见Github gcidea/angular-tabs 概述 承载该表格插件的主要模板html结构如下123456789101112131415161718192021222324252627282930313233343536template: '&lt;div id=\"&#123;&#123;$ctrl.componentId&#125;&#125;\" class=\"module-tabs\"&gt;'+ '&lt;div class=\"tab-label\"&gt;'+ '&lt;ul class=\"main-tabs\"&gt;'+ '&lt;li class=\"glyphicons\"&gt;'+ '&lt;span class=\"glyphicon glyphicon-home\"&gt;'+ '&lt;/span&gt;'+ '&lt;/li&gt;'+ '&lt;li ng-repeat=\"pane in $ctrl.showPanes\" ng-class=\"&#123;active:pane.selected&#125;\" '+ 'ng-mousedown=\"$ctrl.paneClick($event,pane,$index)\"'+ 'oncontextmenu=\"javascript:return false;\" onmousemove=\"javascript:return false;\" ng-style=\"pane.paneStyle\"&gt;'+ '&lt;label ng-bind=\"pane.title\" title=\"&#123;&#123;pane.title&#125;&#125;\"&gt;&lt;/label&gt;'+ '&lt;button ng-click=\"$ctrl.close(pane)\"&gt;&lt;/button&gt;'+ '&lt;/li&gt;'+ '&lt;/ul&gt;'+ '&lt;div ng-if=\"$ctrl.rightMenu\" class=\"tab-menu\" oncontextmenu=\"javascript:return false;\"&gt;'+ '&lt;ul class=\"dropdown-menu\" ng-style=\"$ctrl.menuStyle\"&gt;'+ '&lt;li ng-click=\"$ctrl.closeAll()\"&gt;关闭全部&lt;/li&gt;'+ '&lt;li ng-click=\"$ctrl.closeOther()\"&gt;关闭其他标签页&lt;/li&gt;'+ '&lt;/ul&gt;'+ '&lt;/div&gt;'+ '&lt;div ng-if=\"$ctrl.moreTab\" class=\"more-tab\"&gt;'+ '&lt;button ng-click=\"$ctrl.openMoreTab()\" class=\"more-tab-btn\"&gt;&lt;/button&gt;'+ '&lt;/div&gt;'+ '&lt;/div&gt;'+ '&lt;div ng-show=\"$ctrl.moreTabContent\" class=\"more-tabContent\" ng-style=\"$ctrl.mTCStyle\"&gt;'+ '&lt;div ng-repeat=\"pane in $ctrl.morePanes\" class=\"more-panes\" ng-click=\"$ctrl.show(pane)\"&gt;'+ '&lt;label ng-bind=\"pane.title\" title=\"&#123;&#123;pane.title&#125;&#125;\"&gt;&lt;/label&gt;'+ '&lt;button ng-click=\"$ctrl.close(pane)\"&gt;&lt;/button&gt;'+ '&lt;/div&gt;'+ '&lt;/div&gt;'+ '&lt;div class=\"tab-content\"&gt;'+ '&lt;div id=\"&#123;&#123;pane.id&#125;&#125;\" ng-show=\"pane.selected\" ng-repeat=\"pane in $ctrl.panes\"&gt;'+ '&lt;pane pane-content=\"pane\" is-active=\"pane.selected\" xmlns=\"custom\"/&gt;'+ '&lt;/div&gt;'+ '&lt;/div&gt;'+ '&lt;/div&gt;' 主要逻辑解释数据绑定123456bindings:&#123; showLength:'@', maxLength:'@', container:'@', initTab:'=' &#125;,","categories":[{"name":"AngularJs","slug":"AngularJs","permalink":"http://www.gcidea.info/categories/AngularJs/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"AngularJs","slug":"AngularJs","permalink":"http://www.gcidea.info/tags/AngularJs/"},{"name":"前端框架","slug":"前端框架","permalink":"http://www.gcidea.info/tags/前端框架/"},{"name":"MVVM","slug":"MVVM","permalink":"http://www.gcidea.info/tags/MVVM/"},{"name":"实现/应用","slug":"实现-应用","permalink":"http://www.gcidea.info/tags/实现-应用/"}]},{"title":"CSS预处理---Less使用案例","slug":"less-example","date":"2016-11-18T05:22:04.000Z","updated":"2018-12-12T16:07:50.598Z","comments":true,"path":"2016/11/18/less-example/","link":"","permalink":"http://www.gcidea.info/2016/11/18/less-example/","excerpt":"","text":"前言示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@import \"../../assets/less/common\";.countDownAd &#123; &amp;:extend(.flexLayout); padding: 30rem / @font-size-base; box-sizing: border-box; background-color: #fff; .content &#123; flex: 1; .title &#123; &amp;:extend(.oneLineFormatEllipsis); width: 100%; height: 40rem / @font-size-base; margin: 10rem / @font-size-base 0 0 0; color: #444; font-family: @font-family-base; font-weight: bold; font-size: 20px; [data-dpr=\"2\"] &amp; &#123; font-size: 40px; &#125; [data-dpr=\"3\"] &amp; &#123; font-size: 60px; &#125; &#125; .subtitle &#123; &amp;:extend(.oneLineFormatEllipsis); width: 100%; height: 26rem / @font-size-base; margin: 14rem / @font-size-base 0 0 0; color: #999; font-family: @font-family-base; font-size: 13px; [data-dpr=\"2\"] &amp; &#123; font-size: 26px; &#125; [data-dpr=\"3\"] &amp; &#123; font-size: 39px; &#125; &#125; &#125; .thumb &#123; display: block; width: 240rem / @font-size-base; height: 180rem / @font-size-base; margin-left: 50rem / @font-size-base; &#125;&#125; 对应效果 解释1.使用less可以依据DOM结构进行嵌套声明，如.countDownAd和.content的关系2.@import “../../assets/less/common”;是ES6的写法，表明引入依赖的公共基础样式common.less3.&amp;:extend(.flexLayout);表示继承，继承的是公共基础样式common.less的样式4.@font-size-base表示变量，可以在多个地方使用，这样一旦要修改就可以只改动一个地方。","categories":[{"name":"CSS/CSS3","slug":"CSS-CSS3","permalink":"http://www.gcidea.info/categories/CSS-CSS3/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"CSS/CSS3","slug":"CSS-CSS3","permalink":"http://www.gcidea.info/tags/CSS-CSS3/"},{"name":"Less","slug":"Less","permalink":"http://www.gcidea.info/tags/Less/"}]},{"title":"使用AngularJs封装表格内容渲染（含分页）组件","slug":"angular-table-plugin","date":"2016-11-15T06:15:25.000Z","updated":"2018-12-12T16:08:56.364Z","comments":true,"path":"2016/11/15/angular-table-plugin/","link":"","permalink":"http://www.gcidea.info/2016/11/15/angular-table-plugin/","excerpt":"","text":"功能描述 该组件是管理系统中很常用的功能，管理系统的典型使用是批量数据的处理，表格展示是最直接的方式。该插件实现： 批量数据的列表展示 每行数据提供操作项（修改，删除等）接口 翻页查询接口 每页显示条数修改 点击表头排序 列表宽度自定义 … 实现 demo源码托管于github，详见Github gcidea/angular-table html结构 承载该表格插件的主要html结构如下（直接内联了部分样式 ,且不是完整的html结构，只是该组件的模板部分）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;meta charset=\"UTF-8\"&gt;&lt;style&gt;.pagination&gt;li &#123; cursor: pointer; -moz-user-select:none; -webkit-user-select:none; -ms-user-select:none; -khtml-user-select:none; user-select:none;&#125;.overLength &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; &#125;.tp th&#123; min-width: 100px;&#125;&lt;/style&gt;&lt;div style=\"width: 100%;overflow: auto\" class=\"tablediv\"&gt;&lt;table stlye=\"min-width:1000px;\" class=\"table table-bordered table-hover table-striped table-condensed tp\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th ng-if=\"$ctrl.hasCheck\"&gt;&lt;input type=\"checkbox\" ng-model=\"$ctrl.tChooseAll\" ng-click=\"$ctrl.triChooseAll($ctrl.config.rows)\"&gt;&lt;/th&gt; &lt;th ng-if=\"$ctrl.hasIndex\"&gt;&lt;/th&gt; &lt;th ng-if=\"$ctrl.hasRadio\"&gt;选择&lt;/th&gt; &lt;th class=\" &#123;&#123;col.thCss()&#125;&#125; \" ng-repeat=\"col in $ctrl.columns|filter:$ctrl.tdFilter\" ng-bind=\"col.label\" ng-class=\"&#123;noSortCss:!col.sort,css:$ctrl.sort.column != key &amp;&amp; col.sort,upCss:$ctrl.sort.column == key &amp;&amp; $ctrl.sort.order == 'ASC' &amp;&amp; col.sort,downCss:$ctrl.sort.column == key &amp;&amp; $ctrl.sort.order == 'DESC' &amp;&amp; col.sort&#125;\" ng-click=\"$ctrl.sortTrigger(col)\" width=\"&#123;&#123;col.width&#125;&#125;\" ng-style=\"col.thStyle()\"&gt;&lt;/th&gt; &lt;th ng-if=\"$ctrl.hasOperation\"&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr ng-repeat=\"row in $ctrl.config.rows\"&gt; &lt;td ng-if=\"$ctrl.hasCheck\"&gt;&lt;input type=\"checkbox\" ng-model=\"$ctrl.tCheck[$index]\" ng-click=\"$ctrl.checked(row,$index)\"&gt;&lt;/td&gt; &lt;td ng-if=\"$ctrl.hasIndex\" ng-bind=\"$ctrl.config.currentPage*$ctrl.countPerPage+$index+1\"&gt;&lt;/td&gt; &lt;td ng-if=\"$ctrl.hasRadio\"&gt;&lt;input type=\"radio\" ng-model=\"$ctrl.tRadio\" ng-value=\"$index\" ng-click=\"$ctrl.selectRadio(row,$index)\"&gt;&lt;/td&gt; &lt;td class=\"overLength &#123;&#123;col.tdCss(row)&#125;&#125;\" ng-repeat=\"col in $ctrl.columns|filter:$ctrl.tdFilter\" title=\"&#123;&#123;row|getTdValue:col:true&#125;&#125;\" ng-bind-html=\"row|getTdValue:col\" width=\"&#123;&#123;col.width&#125;&#125;\" ng-click=\"col.onClick(row)\" ng-style=\"col.tdStyle(row)\"&gt;&lt;/td&gt; &lt;td ng-if=\"$ctrl.hasOperation\"&gt; &lt;ng-repeat ng-repeat=\"opt in $ctrl.operation\"&gt; &lt;a ng-if=\"!$ctrl.isDisabled(opt,row)\" ng-bind='opt.label' ng-click=\"opt.doFunc(row)\" class=\"btn-click\"&gt;&lt;/a&gt; &lt;a ng-if=\"$ctrl.isDisabled(opt,row)\" ng-bind='opt.label' class=\"btn-click\"&gt;&lt;/a&gt; &lt;/ng-repeat&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;div ng-if=\"$ctrl.totalPage &gt; 0\" class=\"pagination-panel\"&gt; &lt;div class=\"pagination-right\"&gt; &lt;span&gt;显示&#123;&#123;$ctrl.dataBegin&#125;&#125;-&#123;&#123;$ctrl.dataEnd&#125;&#125;，共&#123;&#123;$ctrl.totalCount&#125;&#125;条数据&lt;/span&gt; &lt;/div&gt; &lt;div class=\"pagination-left\"&gt; &lt;div class=\"perPage\"&gt; &lt;select ng-model=\"$ctrl.countPerPage\" ng-options=\"value for value in $ctrl.numPerPage\" ng-change=\"$ctrl.onPerPageChange()\"&gt; &lt;/select&gt; &lt;/div&gt; &lt;ul class=\"pagination\"&gt; &lt;li ng-class=\"&#123;disabled:$ctrl.totalPage &gt; 0 &amp;&amp; $ctrl.config.currentPage == 0&#125;\"&gt;&lt;a ng-click=\"$ctrl.lastPage()\"&gt;&amp;lt;上一页&lt;/a&gt;&lt;/li&gt; &lt;li ng-repeat=\"num in $ctrl.pageNum track by $index\" ng-class=\"&#123;active:($ctrl.config.currentPage + 1 == num)&#125;\"&gt;&lt;a ng-click=\"$ctrl.selectedPage(num)\" ng-bind=\"num\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li ng-class=\"&#123;disabled:($ctrl.totalPage-1) == $ctrl.config.currentPage&#125;\"&gt;&lt;a ng-click=\"$ctrl.nextPage()\"&gt;下一页&amp;gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"totalPage\"&gt; &lt;span&gt;共&#123;&#123;$ctrl.totalPage&#125;&#125;页，&lt;/span&gt; &lt;span&gt;到&lt;/span&gt; &lt;input ng-model=\"$ctrl.turnTo\" type=\"number\" min=\"1\" class=\"turnToPage\" ng-keypress=\"$ctrl.putPageNum($event)\"&gt; &lt;span&gt;页&lt;/span&gt; &lt;button ng-click=\"$ctrl.selectedPage($ctrl.turnTo)\"&gt;跳转&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 主要逻辑解释数据绑定12345678910111213141516171819bindings:&#123; id:'@?', columns:'&lt;', pageLength:'&lt;?', operation:'&lt;?', numPerPage:'=?', hasIndex:'=?', hasRadio:'=?', hasCheck:'=?', defaultCheck:'&lt;?', removeLoadingBox:'=?', initReq:'=?', sortColumn:'@?defaultSortColumn', order:'@?defaultOrder', radio:'&amp;onCheck', beforeCheck:'&amp;onMulCheck', afterCheck:'&amp;onCancelMulCheck', update:'&amp;onUpdate'&#125;, 完整组件源码 详见github，AngularJs表格内容渲染组件","categories":[{"name":"AngularJs","slug":"AngularJs","permalink":"http://www.gcidea.info/categories/AngularJs/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"AngularJs","slug":"AngularJs","permalink":"http://www.gcidea.info/tags/AngularJs/"},{"name":"前端框架","slug":"前端框架","permalink":"http://www.gcidea.info/tags/前端框架/"},{"name":"MVVM","slug":"MVVM","permalink":"http://www.gcidea.info/tags/MVVM/"},{"name":"实现/应用","slug":"实现-应用","permalink":"http://www.gcidea.info/tags/实现-应用/"}]},{"title":"AngularJs中使用拦截器interceptor对全局HTTP错误进行统一处理","slug":"angular-error-interceptor","date":"2016-11-12T03:32:20.000Z","updated":"2018-12-12T16:08:56.776Z","comments":true,"path":"2016/11/12/angular-error-interceptor/","link":"","permalink":"http://www.gcidea.info/2016/11/12/angular-error-interceptor/","excerpt":"","text":"前言 在web开发的各种业务场景中，http请求无疑是家常便饭，任何前后端交互数据都需要通过http请求进行传输。同时我们知道，HTTP响应有很多状态码，对应着很多种不同的服务处理结果。在这种情况下，如果项目中每一处http请求中我们都要对各种响应结果做以判断的话，那么整个工程中就会出现大量重复代码，这样做会带来不少问题，比如：重复劳动，代码结构不清晰、核心逻辑不明确，一旦对错误处理的需求变更就要对每一处进行修改、费时费力且容易遗漏。 针对这样的情况，在以AngularJs为前端框架的项目中，我们可以使用拦截器interceptor对全局HTTP错误进行统一处理。 相关背景知识AngularJs的拦截器interceptor 功能：任何时候如果我们想要为请求添加全局功能，例如身份验证、错误处理等，在请求发送给服务器之前或者从服务器返回时可以对其进行拦截。 本质：$http服务的基础中间件，用来向应用的业务流程中注入新的逻辑。 核心：服务工厂factory。通过向$httpProvider.interceptors数组中添加服务工厂，在$httpProvider中进行注册。 服务工厂factory() 服务提供了一种能在应用的整个生命周期内保持数据的方法，它能够在控制器之间进行通信，并且能保证数据的一致性。服务是一个单例对象，在每个应用中只会被实例化一次（被$injector实例化），并且是延迟加载的（需要时才会被创建）。服务提供了把与特定功能相关联的方法集中在一起的接口。 服务的工厂函数用来生成一个单例的对象或函数，这个对象或函数就是服务，它会存在于应用的整个生命周期内。当我们的AngularJS应用加载服务时，这个函数会被执行并返回一个单例的服务对象。服务的工厂函数既可以是一个函数也可以是一个数组，比如：123// 用方括号声明工厂angular.module('myApp.services', []).factory('githubService', [function($http) &#123; &#125;]); 顺便提一下，控制器controller的声明也是这样，可以是函数或数组，比如：1controller: function()&#123;&#125;; 或1controller: [function() &#123;&#125;] 在AngularJS应用中，factory()方法是用来注册服务的最常规方式。。factory()函数可以接受两个参数。name：（字符串），需要注册的服务名。getFn:（函数），这个函数会在AngularJS创建服务实例时被调用。 种类一共有四种拦截器，两种成功拦截器，两种失败拦截器。requestAngularJS通过$http设置对象来对请求拦截器进行调用。它可以对设置对象进行修改，或者创建 一个新的设置对象，它需要返回一个更新过的设置对象，或者一个可以返回新的设置对象的promise。responseAngularJS通过$http设置对象来对响应拦截器进行调用。它可以对响应进行修改，或者创建 一个新的响应，它需要返回一个更新过的响应，或者一个可以返回新响应的promise。requestErrorAngularJS会在上一个请求拦截器抛出错误，或者promise被reject时调用此拦截器。 responseErrorAngularJS会在上一个响应拦截器抛出错误，或者promise被reject时调用此拦截器。 AngularJs的$httpProvider $httpProvider是用来修改AngularJs中$http服务的默认行为的。它有两个属性：defaults和interceptors。 其中，defaults是一个包含了全局$http服务请求的参数值的对象，主要有这几个属性：defaults.cachedefaults.xsrfCookieNamedefaults.xsrfHeaderNamedefaults.headersdefaults.paramSerializer 而interceptors则是一个数组，是一个服务工厂的数组。它包含了所有的同步/异步$http中对请求进行预处理或者对响应进行后处理的服务工厂。 AngularJs模块加载前的配置config() 在模块的加载阶段，AngularJS会在提供者注册和配置的过程中对模块进行配置。在整个AngularJS的工作流中，这个阶段是唯一能够在应用启动前进行修改的部分。 config()函数接受一个参数：configFunction（函数）：AngularJS在模块加载时会执行这个函数。如：1234567angular.module('myApp', []).config(function($routeProvider) &#123; $routeProvider.when('/', &#123; controller: 'WelcomeController', template: 'views/welcome.html' &#125;);&#125;) AngularJs的$q服务 $q是AngularJs中的一个服务，可以用来异步执行函数，并在异步请求执行完成时使用返回的结果。$q的使用和ES6(ES2015)中的promise很类似。关于promise的学习，推荐阮一峰的ES6标准入门。关于$q服务的详细信息，参考这一篇AngularJs中$q服务(service)的使用，这里不过多介绍。 在拦截到HTTP后，我们需要使用$q服务通过返回一个rejection来阻止下一步的默认行为。 AngularJs的$on服务 $on用于监听事件变化，比如状态改变事件：12345$scope.$on('$stateChangeStart',function(evt, toState, roParams, fromState, fromParams) &#123;// 可以阻止这一状态完成evt.preventDefault();&#125;); 我们可以通过如上方法自定义监听事件，第一个字符串参数是事件名称，第二个是监听事件发生时的回调函数。我们使用这种监听，当拦截到http错误时，向下broadcast广播这个事件，从而触发一些其他事件（比如使用弹窗提醒错误信息）。关于$broadcast和$emit，参考这一篇AngularJs的$emit和$broadcast事件分析。 AngularJs的运行块run()方法 它是所有AngularJS应用中第一个被执行的方法。运行块是AngularJS中与平时所说“main()方法”最接近的概念。运行块通常用来注册全局的事件监听器。例如，我们会在.run()块中设置路由事件的监听器以及过滤未经授权的请求。假设我们需要在每次路由发生变化时，都执行一个函数来验证用户的权限，放置这个功能唯一合理的地方就是run方法。 在拦截HTTP请求的过程中，我们在整个应用的module上注册一个这样的运行块，通过拦截，将错误信息保存到$rootScope，并由Box组件负责展示。 HTTP错误拦截器的实现创建错误拦截服务工厂12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364angular.module('portalApp').factory('errorInterceptor', function($q,$rootScope) &#123; return &#123; // optional method 'request' : function(config) &#123; return config; &#125;, // optional method 'response' : function(response) &#123; if(!response.data) return response; if(response.data.success==undefined) return response; if(response.data.success==false)&#123; $rootScope.$broadcast(\"warn\",&#123; type:'error', desc:response.data.desc &#125;); &#125; return response; &#125;, // optional method 'responseError' : function(rejection) &#123; // do something on error if (rejection.status == -1) &#123; $rootScope.$broadcast(\"warn\",&#123; type:'error', desc:'连接服务器失败' &#125;); return $q.reject(rejection); &#125; if (rejection.status == 500) &#123; $rootScope.$broadcast(\"warn\",&#123; type:'error', desc:'服务器内部错误' &#125;); return $q.reject(rejection); &#125; if (rejection.status == 404) &#123; $rootScope.$broadcast(\"warn\",&#123; type:'error', desc:'请求的页面不存在' &#125;); return $q.reject(rejection); &#125; if (rejection.status == 401) &#123; window.location=\"/login.html\"; &#125; if (rejection.status == 403) &#123; $rootScope.$broadcast(\"warn\",&#123; type:'error', desc:'对不起，您没有访问权限' &#125;); return $q.reject(rejection); &#125; $rootScope.$broadcast(\"warn\",&#123; type:'error', desc:'服务器发生未知错误（status'+rejection.status+'）' &#125;); return $q.reject(rejection); &#125; &#125;;&#125;); 向$httpProvider配置错误拦截器123angular.module('portalApp').config([ '$httpProvider', function($httpProvider) &#123; $httpProvider.interceptors.push('errorInterceptor');&#125;]); 注册运行块run，监听错误结果进行回调处理12345678910angular.module('portalApp', [ 'ngComponentRouter', ...及其他依赖注入模块]) .controller( 'mainCtrl',[...此处省略...] ).run(function($rootScope,ngDialog,Box)&#123; $rootScope.$on('warn',function(event, warnMsg)&#123; setTimeout(function()&#123; Box.error(warnMsg.desc); &#125;, 500); &#125;); &#125;); 参考：《AngularJs权威教程》、AngularJs官方文档","categories":[{"name":"AngularJs","slug":"AngularJs","permalink":"http://www.gcidea.info/categories/AngularJs/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"AngularJs","slug":"AngularJs","permalink":"http://www.gcidea.info/tags/AngularJs/"},{"name":"前端框架","slug":"前端框架","permalink":"http://www.gcidea.info/tags/前端框架/"},{"name":"MVVM","slug":"MVVM","permalink":"http://www.gcidea.info/tags/MVVM/"},{"name":"前端工程化","slug":"前端工程化","permalink":"http://www.gcidea.info/tags/前端工程化/"}]},{"title":"AngularJs的$emit和$broadcast事件分析","slug":"angular-emit-broadcast","date":"2016-11-08T06:15:25.000Z","updated":"2018-12-12T16:08:57.168Z","comments":true,"path":"2016/11/08/angular-emit-broadcast/","link":"","permalink":"http://www.gcidea.info/2016/11/08/angular-emit-broadcast/","excerpt":"","text":"前言 Angular的作用域在本质上是分层次的：它们可以通过父子关系很自然地来回沟通。但通常，作用域是不共享变量的，它们执行的功能往往各不相同，跟在父树上的位置无关。在这种情况下，我们可以通过在这个链上传递事件的方式在作用域之间通信。 因为作用域是有层次的，所以我们可以在作用域链上传递事件。通常来说，选择要使用的事件传递方式，一个好的经验法则是：查看将要触发事件的作用域。如果要通知整个事件系统（允许任意作用域处理这个事件），就要往下广播。 另一方面，如果要提醒一个全局模块，我们最终需要通知高层次的作用域（例如$rootScope），并且需要把事件向上传递。 $emit作用 要把事件沿着作用域链向上派送（从子作用域到父作用域），我们要使用$emit()函数。一个$emit()事件函数的调用中，事件从子作用域冒泡到父作用域。在产生事件的作用域之上的所有作用域都会收到这个事件的通知。当想要跟应用的其他部分交流状态的变更时，我们使用$emit()。如果想要跟$rootScope通信，需要$emit()这个事件。 参数1scope.$emit('user:logged_in', scope.user); $emit()方法带有两个参数。 name（字符串）要发出的事件名称。 args（集合）一个参数的集合，作为对象传递到事件监听器中。 示例123456789101112angular.module('portalApp').component('orderIndex', &#123; transclude : true, controller : function($scope, $http, $window,orderIndexService,currentUserService) &#123; var ctrl = this; this.$routerOnActivate = function(next,previous) &#123; $scope.$emit(\"ComponentChange\", &#123;path:[\"个人中心\"],pageTitle:\"我的订阅\"&#125;); ... ... &#125; ... ... templateUrl : '/component/xxx/yyy/index.html'&#125; 以上例子是angular组件的写法，当该组件路由被激活后，自动执行一次向上传递事件，从而更新当前页面的面包屑导航组件（是一个全局公共组件）。 $broadcast作用 要把事件向下传递（从父作用域到子作用域），我们使用$broadcast()函数。在$broadcast()法上，每个注册了监听器的子作用域都会收到这个信息。事件传播到所有的指令和当前作用域的间接作用域上，并且一路往下调用每个监听器。用了$broadcast()方法之后，就没法取消事件的发送了。 参数$broadcast()方法自身带有两个参数。 name（字符串）要发出的事件名称。 args（集合）一个参数的集合，作为对象传递到事件监听器中。示例123456789$scope.searchReport = function () &#123; $scope.$broadcast('openTab', &#123; title: \"检索\", name: \"search-report\", data: &#123;\"text\": $scope.text&#125;, reBuild: true &#125;); ... ...&#125;; 以上例子在系统入口js中，向下广播了一个openTab事件，从而在系统加载完成后一进入时就默认打开一个tab页。","categories":[{"name":"AngularJs","slug":"AngularJs","permalink":"http://www.gcidea.info/categories/AngularJs/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"AngularJs","slug":"AngularJs","permalink":"http://www.gcidea.info/tags/AngularJs/"},{"name":"前端框架","slug":"前端框架","permalink":"http://www.gcidea.info/tags/前端框架/"},{"name":"MVVM","slug":"MVVM","permalink":"http://www.gcidea.info/tags/MVVM/"}]},{"title":"AngularJs中组件---component的相关总结","slug":"angular-component","date":"2016-11-07T15:15:25.000Z","updated":"2018-12-12T16:08:57.542Z","comments":true,"path":"2016/11/07/angular-component/","link":"","permalink":"http://www.gcidea.info/2016/11/07/angular-component/","excerpt":"","text":"前言 组件component是AngularJs中一个非常重要的概念，一个项目的前端代码结构可以完全以组件component为单位进行实现，也就是说项目的不同页面（比如列表页、详情页、编辑页）或者通用功能（比如表格渲染组件、分页组件）都可以设计为一个独立的component，再通过路由配置关联起来，实现功能需求。本篇以AngularJs官方文档为根据，对组件相关内容进行总结。 综述 在Angular中，component是一种特殊的指令（directive），相比于directive，它的配置要更简单，这很适合于基于组件的应用程序结构，也使得使用类似于Web Components或者Angular 2风格的应用程序结构来编写代码要更容易。 组件component的优点 比原生指令（directive）配置更加简单 提供了更加健全的默认设置和最佳实践 可以优化基于component的应用结构 编写component这种directive使得升级到Angular 2更加容易 什么时候不要用component 对那些依赖于DOM元素操作和绑定监听事件的指令不要使用，因为在component中是不能直接编译链接函数的。 当需要定义配置一些更高级的directive选项时不要使用，选项比如：priority, terminal, multi-element。 当你想通过一个属性或者CSS类来触发一个指令，而不是通过一个元素来触发时，不要使用。 创建并配置component组件 要想注册一个component组件，可以使用Angular模型module上的.component()方法。（模型module是通过调用angular.module()来返回的。）该方法接收两个参数： 组件名称（字符串） 组件配置对象（注意，不同于.directive()方法，该方法不需要使用工厂函数） 示例 创建heroDetail.js文件,定义一个组件component 1234567891011function HeroDetailController() &#123; //do something&#125;angular.module('heroApp').component('heroDetail', &#123; templateUrl: 'heroDetail.html', controller: HeroDetailController, bindings: &#123; hero: '=' &#125;&#125;); 创建heroDetail.html文件,定义组件的DOM结构 1&lt;span&gt;Name: &#123;&#123;$ctrl.hero.name&#125;&#125;&lt;/span&gt; 创建index.js文件，增加控制器，为model变量初始化 12345angular.module('heroApp', []).controller('MainCtrl', function MainCtrl() &#123; this.hero = &#123; name: 'Spawn' &#125;;&#125;); 创建index.html文件，定义文档结构，引入定义好的组件heroDetail(驼峰写法要转换成短横线”-“相连) 1234&lt;div ng-controller=\"MainCtrl as ctrl\"&gt; &lt;b&gt;Hero&lt;/b&gt;&lt;br&gt; &lt;hero-detail hero=\"ctrl.hero\"&gt;&lt;/hero-detail&gt;&lt;/div&gt; 结果如下图： 另外，也可以使用$compileProvider在module的配置阶段引入组件。 附：directive与component的比较 directive component bindings No Yes(绑定到controller) bindToController Yes(默认：false) No(使用bindings来替代) compile function Yes No controller Yes Yes(默认：function(){}) controllerAs Yes(默认：false) Yes(默认：$ctrl) link functions Yes No multiElement Yes No priority Yes No require Yes Yes restrict Yes No(仅限于元素elements) scope Yes(默认：false) No(scope总是独立的) template Yes Yes(可注入) templateNamespace Yes No templateUrl Yes Yes(可注入) terminal Yes No transclude Yes(默认：false) Yes(默认：false) 基于component组件的应用程序结构 如上所述，component使得按组件结构来组织应用程序变得更加容易。基于component组件的应用程序结构主要有以下几个特性： component只控制它自己的视图和数据 组件从不应修改超出它们作用域scope的任何数据或者DOM元素。一般来讲，在Angular中，通过作用域继承（inheritance）和监视（watches），我们能够修改程序中的任何数据。这是有实用性的，但是也可能导致一些问题-尤其当不明确到底程序中的哪一部分对数据修改负责时。这也就是为什么component这种directive采用了独立隔离作用域，这样对所有scope的操作就不可能发生了。 component具有定义完备的公用API-Inputs 和 Outputs 然而，独立作用域也有捉襟见肘的时候，因为Angular采用了“双向绑定”。假设你给组件传入了这样一个对象：bindings: {item: &#39;=&#39;}，然后修改其中一个属性，你会发现这个变化也会反映在父级组件中。但是对于组件来说，为了更容易的判定什么数据发生变化，何时变化，只应该由拥有该数据的组件来对其进行修改。因此，component需要遵循一些简单的约定： 输入Inputs应该使用&lt;和@绑定。 &lt;符号表明“单向绑定”，是从1.5版本开始可用的。它和=的区别在于：组件作用域中的相关属性没有被监视（watched），这意味着如果你给属性赋了一个新值，父级作用域并不会因此而更新。但是要注意，父级和本级组件都是指向同一个对象，因此如果你在当前组件中修改了对象属性或者数组元素，父级组件还是能感受到这个变化。综上，一般性的规律是在组件作用域中永远不要修改对象或者数组属性。 @绑定可以用于当输入是字符串，尤其是绑定的值不会发生改变时。 1234bindings: &#123; hero: '&lt;', comment: '@'&#125; 输出Outputs应该使用&amp;来绑定。这说的输出是作为组件事件的回调函数。 1234bindings: &#123; onDelete: '&amp;', onUpdate: '&amp;'&#125; 相比于直接操作输入数据，组件应该将变化的数据交付给正确的输出事件来处理。比如一次删除操作，组件不会直接删掉hero本身，而是通过正确的事件将数据传递给拥有该数据属性的组件。 123&lt;!-- note that we use kebab-case for bindings in the template as usual --&gt;&lt;editable-field on-update=&quot;$ctrl.update(&apos;location&apos;, value)&quot;&gt;&lt;/editable-field&gt;&lt;br&gt;&lt;button ng-click=&quot;$ctrl.onDelete(&#123;hero: $ctrl.hero&#125;)&quot;&gt;Delete&lt;/button&gt; 通过这种方式，父级组件可以来决定如何处理（比如，是删除一个元素还是更新属性。） 12345678ctrl.deleteHero(hero) &#123; $http.delete(...).then(function() &#123; var idx = ctrl.list.indexOf(hero); if (idx &gt;= 0) &#123; ctrl.list.splice(idx, 1); &#125; &#125;);&#125; component具有定义完备的生命周期 每一个组件都可以执行一套“声明周期钩子”，在生命周期的特定点，以下方法可以被调用： $onInit() 满足以下条件时会在controller上调用该方法： a. 当一个元素上的全部controller都已经构建完成 b. 它们的bindings已经初始化 c. 在该元素上指令directives的pre &amp; post linking functions执行之前 将初始化代码放在这个方法中是很合适的。 $onChanges(changesObj) 在任何时刻，只要单向绑定的数据发生更新，就会调用该方法。changesObj是一个哈希表，它的键是发生变化的绑定属性的属性名称，它的值是一个对象，形式为：{ currentValue, previousValue, isFirstChange()}。比如当需要复制一个绑定的值以防外部值发生突变的时候，就可以触发该方法。 $doCheck() 该方法提供了一个检测并处理变化的接口。当检测到变化想做出相应处理时，任何的处理函数都必须从这个钩子调用。但是，当$onChanges已经调用时，这个钩子是不起作用的。举例来说，当你想进行一次“js对象深度相等比较”（这个概念应该参考js的深拷贝和浅拷贝），或者要检测一个Date对象这类操作时，它们的变化不会被Angular的变化检测器检测到，因此不会触发$onChanges，这时候就可以使用$doCheck()。这个钩子的调用没有参数，如果检测到了变化，必须手动保存旧值来和当前值比较。 $onDestroy() 当一个controller的作用域已经销毁，会调用该函数。使用该函数可以释放外部资源，watches监听函数和其他事件处理函数。 $postLink() 当控制器对应的元素及其子元素已经”link”完成（关于”link”，要单独分析$compile的相关内容），会调用该函数。和directive中的post-link function类似，这个钩子可以用来设置DOM元素事件处理函数，或者进行直接的DOM操作。注意一个例外，当前的controller对应的组件可能有子组件，那些包含有templateUrl的子元素在调用该函数的时候并没有”link”完成，因为它们要等待templateUrl指定的模板template异步加载完成，因此在完成之前它自己的编译和链接就会被挂起。这个指令可以看做是和Angular 2中的ngAfterViewInit和ngAfterContentInit作用类似。 一个应用程序就是一棵组件树 理论上最佳的状态是，整个应用应该由不同层级的component构成一棵树，能够处理定义完备的输入输出，并且具有最少的双向数据绑定。这样，就能够更加轻松地预测数据何时变化以及组件的状态是什么。 使用案例 具体案例，详细参见这一篇使用AngularJs封装表格内容渲染（含分页）插件。整个表格插件就是一个大的component，实现过程中用到了上述很多特性。","categories":[{"name":"AngularJs","slug":"AngularJs","permalink":"http://www.gcidea.info/categories/AngularJs/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"AngularJs","slug":"AngularJs","permalink":"http://www.gcidea.info/tags/AngularJs/"},{"name":"前端框架","slug":"前端框架","permalink":"http://www.gcidea.info/tags/前端框架/"},{"name":"MVVM","slug":"MVVM","permalink":"http://www.gcidea.info/tags/MVVM/"}]},{"title":"AngularJs中$scope.$apply()方法总结","slug":"angular-$scope-$apply","date":"2016-11-04T06:15:25.000Z","updated":"2018-12-12T16:08:57.921Z","comments":true,"path":"2016/11/04/angular-$scope-$apply/","link":"","permalink":"http://www.gcidea.info/2016/11/04/angular-$scope-$apply/","excerpt":"","text":"功能 $apply()函数可以从Angular框架的外部让表达式在Angular上下文内部执行。例如，假设你实现了一个setTimeout()或者使用第三方库并且想让事件运行在Angular上下文内部时，就必须使用$apply()。 参数 $apply()函数接受一个可选的参数。这个表达式可选地接受一个字符串或函数，并且是在当前作用域内执行。如果传入一个字符串，$apply()首先会在这个字符串上调用$eval()，以强制Angular在局部作用域上下文中使用$eval()运行字符串表达式。如果传入一个函数，这个函数将会在所传入的函数作用域上执行。$exceptionHandler服务会捕获和处理$eval()方法抛出的所有异常。最后，$apply()方法还会直接调用$digest循环。 示例一12345678910111213// 使用要eval的字符串调用$apply示例$scope.$apply('message = \"Hello World\"');// 使用函数的方式并给函数传入一个作用域$scope.apply(function(scope) &#123; // 然后在函数中使用传入作用域 $scope.message = \"Hello World\";&#125;);// 使用函数时忽略作用域$scope.$apply(function() &#123; $scope.message = \"Hello World\";&#125;);// 或者通过在操作的尾部调用$apply()以强制运行$digest循环$scope.apply(); 示例二1234567functionCtrl($scope) &#123; $scope.message =\"Waiting 2000ms for update\"; setTimeout(function () &#123; $scope.message =\"Timeout called!\"; // AngularJS unaware of update to $scope &#125;, 2000); &#125; 上述代码执行完成后，$scope.message仍然是”Waiting 2000ms for update”。原因是setTimeout函数创建了一个闭包，是自己独立的作用域，而这个作用域的变化不能被angular检测感知。 修改写法如下即可：12345678functionCtrl($scope) &#123; $scope.message =\"Waiting 2000ms for update\"; setTimeout(function () &#123; $scope.$apply(function () &#123; $scope.message =\"Timeout called!\"; &#125;); &#125;, 2000); &#125; 注意事项 简而言之，使用$scope.$apply()时可以从外部进入上下文。如果在事件被触发时调用$apply()，就会使用Angular事件循环来运行它。如果没有调用$apply()，就不会在事件循环内执行这个函数，而它会运行在Angular上下文外部。 通常可以依赖于Angular提供的可用于视图中的任意指令来调用$apply()。所有ng-[event]指令（比如ng-click、ng-keypress）都会调用$apply()。此外还可以依赖于一系列Angular内置的服务来调用$digest()。比如$http服务会在XHR请求完成并触发更新返回值（promise）之后调用$apply()。无论何时我们手动处理事件，使用第三方框架（比如jQuery），或者调用setTimeout()，都可以使用$apply()函数让Angular返回$digest循环。 当我们将jQuery和Angular集成在一起时(并非最佳实践)，就需要使用$apply()，因为Angular不会察觉到执行在Angular上下文外部的事件。例如，在使用jQuery插件时（比如datepicker），就需要使用$apply()将来自jQuery的值传递到Angular应用中。","categories":[{"name":"AngularJs","slug":"AngularJs","permalink":"http://www.gcidea.info/categories/AngularJs/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"AngularJs","slug":"AngularJs","permalink":"http://www.gcidea.info/tags/AngularJs/"},{"name":"前端框架","slug":"前端框架","permalink":"http://www.gcidea.info/tags/前端框架/"},{"name":"MVVM","slug":"MVVM","permalink":"http://www.gcidea.info/tags/MVVM/"},{"name":"实现/应用","slug":"实现-应用","permalink":"http://www.gcidea.info/tags/实现-应用/"}]},{"title":"浏览器页面渲染引擎与页面重绘(repaint)与重排(reflow)问题","slug":"browser-rendering-engine","date":"2016-11-03T14:15:18.000Z","updated":"2018-12-12T16:08:53.944Z","comments":true,"path":"2016/11/03/browser-rendering-engine/","link":"","permalink":"http://www.gcidea.info/2016/11/03/browser-rendering-engine/","excerpt":"","text":"","categories":[{"name":"FE综合","slug":"FE综合","permalink":"http://www.gcidea.info/categories/FE综合/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"浏览器","slug":"浏览器","permalink":"http://www.gcidea.info/tags/浏览器/"},{"name":"页面渲染","slug":"页面渲染","permalink":"http://www.gcidea.info/tags/页面渲染/"}]},{"title":"AngularJs中$q服务(service)的使用","slug":"angular-$q-service","date":"2016-11-02T03:32:30.000Z","updated":"2018-12-12T16:09:36.511Z","comments":true,"path":"2016/11/02/angular-$q-service/","link":"","permalink":"http://www.gcidea.info/2016/11/02/angular-$q-service/","excerpt":"","text":"前言 $q服务的实现与ES6(ES2015)中的promise十分相似，这种方式改变了传统长期使用的JavaScript异步编程方式-处理回调函数。试想一下，如果有这样的业务逻辑：我们需要根据某个异步ajax请求的结果是否符合要求，再发起一个异步请求，在回调函数中对响应数据进行请求后再发起异步请求… …当出现这样的异步嵌套逻辑，代码结构就会变得很差。promise正是改变了这种情况，以一种流式的方式对异步请求进行声明和处理，表现出顺序的编码结构。本篇对$q服务的常用内容进行总结，而对于promise的学习，推荐阮一峰的ES6标准入门。 综述 $q是AngularJs中的一个服务，可以用来异步执行函数，并在异步请求执行完成时使用返回的结果。$q是对Kris Kowal提出的Kris Kowal’s Q中的promises/deferred对象的一种实现。$q有两种使用风格，一种和Kris Kowal’s Q或者jQuery中的defer实现类似，另一种实现与ES6(ES2015)中的promise十分相似。 $q构造函数 上面提到的ES6流式风格的promise对象本质上就是把$q用作构造函数，并且这个构造函数的第一个参数是一个函数-resolver，构造函数返回一个promise对象。这个结果和原生的ES6的promise对象是十分类似的。 要注意的是，虽然能够按照构造函数的形式来使用$q，但是并不是ES6的promise对象的所有方法在这里都得到了支持。 根据AngularJs的官方文档，$q构造函数的典型使用如下：12345678910111213141516171819202122// for the purpose of this example let's assume that variables `$q` and `okToGreet`// are available in the current lexical scope (they could have been injected or passed in).function asyncGreet(name) &#123; // perform some asynchronous operation, resolve or reject the promise when appropriate. return $q(function(resolve, reject) &#123; setTimeout(function() &#123; if (okToGreet(name)) &#123; resolve('Hello, ' + name + '!'); &#125; else &#123; reject('Greeting ' + name + ' is not allowed.'); &#125; &#125;, 1000); &#125;);&#125;var promise = asyncGreet('Robin Hood');promise.then(function(greeting) &#123; alert('Success: ' + greeting);&#125;, function(reason) &#123; alert('Failed: ' + reason);&#125;); 上面这种写法，执行asyncGreet(‘Robin Hood’)返回了一个$q构造函数，该函数执行后要么调用resolve，要么调用reject，返回一个promise对象。之后再调用这个对象上的then()方法，具体下面有解释。 Deferred API 一个新的deferred实例—延迟对象实例，是通过调用$q.defer()创建的。 创建deferred对象的目的是： 暴露出一个与之相关的promise对象 提供标识任务状态以及是否成功完成的API接口 对应上述1，$q.defer()创建的延迟对象实例有以下属性： promise 可通过下面方法调用：12var deferred = $q.defer();var promise = deferred.promise; 对应上述2，$q.defer()创建的延迟对象实例有以下方法： resolve(value) 表明成功解决了派生的promise对象，此时value值将会作为参数值传递给对应promise对象的then()方法的第一个参数，而这个第一个参数是一个函数，即successCallback成功回调函数。也就是value值传递给successCallback函数。 而如果这个value值是通过”$q.reject()”创建的rejection(实际上也是一个promise对象，详见下文)，那么表明deferred的promise对象未被成功处理。 reject(reason) 表明未能成功解决派生的promise对象，这和下文要提到的通过”$q.reject()”创建的rejection来处理promise是一样的。 notify(value) 根据promise的执行状态来提供更新情况。在promise对象被resolve或者被reject前，这个方法可能会被调用多次。 Promise API当一个deferred实例被成功创建时，随之而来的也成功创建了一个promise实例，并且可以通过调用deferred.promise来获取到这个promise实例。 这个promise对象的目的是允许在延迟执行任务deferred执行完成时获取对其执行结果的访问权限。Promise API提供如下３个方法： then(successCallback, [errorCallback], [notifyCallback]) 无论是promise已经被resolve或者reject，还是promise将要被resolve或者reject，只要结果一旦可用，then()方法就会异步调用成功回调函数或者失败回调函数中的一个。回调函数有一个参数：成功执行的结果或者拒绝执行的原因。另外，在promise被resolve或者reject之前，notifyCallback可能不会被调用，也可能调用多次用以表明执行进度。 这个方法会通过successCallback或者errorCallback的返回值来返回一个新的被resolve或者被reject的promise对象(不能通过notifyCallback方法) catch(errorCallback) 是promise.then(null, errorCallback)的简写形式。 finally(callback, notifyCallback) 此方法允许观察处理一个promise对象是完成还是拒绝。但这样做不用修改最后的value值。 这可以用来做一些释放资源或者清理无用对象的工作,不管promise 被拒绝还是解决。 链式promises 由于调用promise对象的then()方法会返回一个新派生出的promise对象，因此很容易创建一个链式的promise调用。如下所示：12345promiseB = promiseA.then(function(result) &#123; return result + 1;&#125;);//一旦promiseA调用完成，就会执行promiseB，并且promiseB的值是promiseA返回的结果值加1。 我们可以创建任意长度的链式调用。并且由于一个promise对象的执行可能要受另一个promise对象的影响，这使得在链上任意一点暂停或者推迟promise的执行成为可能。这一点很有用，比如http响应拦截器，具体参考AngularJs中使用拦截器interceptor对全局HTTP错误进行统一处理。 Kris Kowal’s Q和$q的区别主要有两点不同： $q是与$rootScope.Scope结合在一起的，AngularJs中的作用域模型观察机制意味着可以更加快速地将resolution或者rejection传入模型，同时避免浏览器的重新渲染，而这往往会造成界面UI的闪烁，体验不好。 Q比$q有更多特性，但代价是体积上更大。$q是轻量级的，即便简单，但也包含了常见异步任务所需要的全部重要功能。 使用格式$q(resolver); 参数值：resolver（类型：function(function, function)）解释：参数是一个函数，这个函数是用来处理或者拒绝新创建的promise对象的。它有两个参数，分别是一个函数，第一个函数是用来执行处理promise对象，第二个用来拒绝promise对象。 返回值新创建的promise对象。 提供的方法 defer();解释创建一个延迟对象deferred，它代表着一个在将来完成的任务。参数无。返回值一个新的deferred实例。 reject(reason);解释 创建一个promise对象，这个对象的处理状态是被拒绝，参数reson表明具体原因。这个API应该用来在链式promise中向前传递rejection。如果是在处理链式调用中的最后一个promise对象，就不用担心这个了。 当把deferreds/promises和有类似行为的try/catch/throw作比较时，应该这样想：把reject类比为JavaScript中的throw关键字。这就意味着，如果你通过promise的errorCallback捕获到了一个错误，并且你想将这个错误从当前promise对象向派生出的promise对象继续传播时，你就必须将这个错误重新抛出，而方法就是，使用该API，通过reject(reason);返回一个rejection。示例如下： 1234567891011121314promiseB = promiseA.then(function(result) &#123; // success: do something and resolve promiseB // with the old or a new result return result;&#125;, function(reason) &#123; // error: handle the error if possible and // resolve promiseB with newPromiseOrValue, // otherwise forward the rejection to promiseB if (canHandle(reason)) &#123; // handle the error and recover return newPromiseOrValue; &#125; return $q.reject(reason);&#125;); 参数reson(类型任意)。可以是代表着异常原因的常量、消息、对象等。返回值promise对象。并且这个对象已经被处理为rejected，参数就是reson。 when(value, [successCallback], [errorCallback], [progressCallback]);解释该方法会将一个普通任意值或者第三方的promise对象统一包装成$q的promise对象，第一个参数若不是promise对象则直接运行successCallback，若为promise那么返回的promise其实就是对这个promise类型的参数的一个包装，被传入的这个promise对应的defer发送的消息，会被我们when函数返回的promise对象所接收到。示例如下： 123456789101112131415161718var promise = $q.when(\"a value\", function(val) &#123; console.log(\"a value---resolve,this is \" + val);&#125;, function() &#123; console.log(\"a value---reject\");&#125;);var defer1 = $q.defer();var promise1 = defer1.promise;var promise2 = $q.when(promise1, function(val) &#123; console.log(\"a (3rd party) then-able promise,this is \" + val);&#125;, function() &#123; console.log(\"a (3rd party) then-able promise---reject\");&#125;);defer1.reject(1);//运行结果：//a value---resolve,this is a value//a (3rd party) then-able promise---reject 参数value：任意值或者promise对象successCallback：可选，成功回调函数errorCallback：可选，错误回调函数progressCallback：可选，执行过程通知回调函数返回值传入值包装后的promise对象。 resolve(value, [successCallback], [errorCallback], [progressCallback]);这是when()方法的一个别名，是为了保持和ES6的命名一致性。 all(promises);解释这个方法用来将多个promise对象绑定到一个promise对象上，当且仅当输入的所有promise对象执行完成，这个对象才会被执行。参数promises：一个promise的数组或者hash表。返回值一个promise对象，这个对象传入的参数值是一个数组或者hash表，其中的每一个值和传入的promise数组一一对应相关，是相应promise执行的返回值。如果传入的promise数组中有任意一个得到了reject的结果，那么返回的这个promise也会因为相同的值而被reject。 race(promises);解释这个方法会传入promise数组或者对象，一旦传入的对象中有一个执行得到reject或者resolve的结果，那么就会返回，并且返回的promise的执行结果是一致的。参数promises：一个promise的数组或者promise对象。返回值一旦传入的对象中有一个执行得到reject或者resolve的结果，那么就会返回，并且返回的promise的执行结果是一致的。 使用案例一 $q提供了很多方法和使用形式，但在实际中还没有用到太复杂的。下面这段代码是对$q的一个简单使用：列表的更新方法ctrl.update是一个异步操作，不知道确切在哪个时间点返回，那么这正符合$q的使用场景。1.其中更新方法ctrl.update的实现如下：12345678910111213function(reqInfo,toTable) &#123; var params = &#123; 'taskName':$scope.taskName, 'createUser':$scope.createUser, 'taskStatus':$scope.taskStatus &#125;; params = angular.extend(params,reqInfo); $http.get(\"/rest/idap/taskList/index\",&#123;params:params&#125;).success(function(result)&#123; if(result.success)&#123; toTable(result.data); &#125; &#125;);&#125; 我们不需要管其中具体的业务逻辑，比如请求的参数、路由之类的。我们只需要知道，$http.get发起了一个异步请求，当成功执行时，我们会将返回的数据result.data传递给作为参数的函数toTable，由这个函数来将数据渲染到表格中。 2.接下来就是核心：$q如何使用。执行$q(function(resolve, reject) {})这部分后会返回一个新创建的promise对象，我们在function(resolve, reject) {}中发起数据查询请求：pageInfo只是一个配置表格分页信息的普通对象，不需多管。resolve是当promise对象成功执行时候用来进行处理的函数。我们就把这个函数传递给toTable方法，用来当查询成功时对表格进行数据渲染。12345678910111213141516171819$q(function(resolve, reject) &#123; if(!ctrl.removeLoadingBox)&#123; loadingDialogId = Box.startLoading(\"查询中...\"); &#125; ctrl.update(&#123;reqInfo:pageInfo,toTable:resolve&#125;);&#125;).then(function(msg) &#123; if(!ctrl.removeLoadingBox)&#123; setTimeout(function(id)&#123; return function() &#123; Box.stopLoading(id); &#125; &#125;(loadingDialogId),100); &#125; if(angular.isObject(msg)) &#123; ctrl.config = msg; &#125; else &#123; Box.error(msg); &#125;&#125;); 3.既然执行$q后返回promise对象，我们由上述promise API可知，通过then()方法的第一个参数可以指定promise成功执行后的回调函数，我们就在这里来具体指定我们在2中说的resolve到底是怎么处理的，是怎样一个函数：1234567891011121314function(msg) &#123; if(!ctrl.removeLoadingBox)&#123; setTimeout(function(id)&#123; return function() &#123; Box.stopLoading(id); &#125; &#125;(loadingDialogId),100); &#125; if(angular.isObject(msg)) &#123; ctrl.config = msg; &#125; else &#123; Box.error(msg); &#125;&#125; 当promise成功执行，由1知道，传递给toTable()函数的参数是result.data，也就是说resolve()方法拿到的是result.data，也就是说successCallback-成功回调函数拿到的是result.data，那么上面的msg就是result.data，我们现在就可以拿着这个数据进行渲染了。这里我们只要把它赋值给ctrl.config即可（而config具体如何实现已经不是这里需要考虑的问题，总之它做的事情就是配置并渲染表格）。 使用案例二 另一个案例就是使用$q异步服务对全局HTTP请求错误的进行拦截处理，具体内容参考这一篇AngularJs中使用拦截器interceptor对全局HTTP错误进行统一处理。","categories":[{"name":"AngularJs","slug":"AngularJs","permalink":"http://www.gcidea.info/categories/AngularJs/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"AngularJs","slug":"AngularJs","permalink":"http://www.gcidea.info/tags/AngularJs/"},{"name":"前端框架","slug":"前端框架","permalink":"http://www.gcidea.info/tags/前端框架/"},{"name":"MVVM","slug":"MVVM","permalink":"http://www.gcidea.info/tags/MVVM/"}]},{"title":"MySQL重置密码时遇到的问题与解决","slug":"mysql-reset-password","date":"2016-10-28T02:29:39.000Z","updated":"2018-12-12T16:07:49.496Z","comments":true,"path":"2016/10/28/mysql-reset-password/","link":"","permalink":"http://www.gcidea.info/2016/10/28/mysql-reset-password/","excerpt":"","text":"错误提示1ERROR 1054 (42S22): Unknown column &apos;password&apos; in &apos;field list&apos; 场景输入update mysql.user set password=password(‘root’) where user=’root’时提示ERROR 1054 (42S22): Unknown column ‘password’ in ‘field list’ 原因新版（如mysql5.7）数据库下password字段更新为authentication_string 解决1update MySQL.user set authentication_string=password(&apos;root&apos;) where user=&apos;root&apos; ; 即可。","categories":[{"name":"搭建部署","slug":"搭建部署","permalink":"http://www.gcidea.info/categories/搭建部署/"},{"name":"工程","slug":"搭建部署/工程","permalink":"http://www.gcidea.info/categories/搭建部署/工程/"}],"tags":[{"name":"搭建部署","slug":"搭建部署","permalink":"http://www.gcidea.info/tags/搭建部署/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"}]},{"title":"Nginx服务器基本配置及在模块化项目中的转发应用","slug":"nginx-configuration-and-modules-project-dispatch","date":"2016-10-25T14:15:18.000Z","updated":"2018-12-12T16:07:48.639Z","comments":true,"path":"2016/10/25/nginx-configuration-and-modules-project-dispatch/","link":"","permalink":"http://www.gcidea.info/2016/10/25/nginx-configuration-and-modules-project-dispatch/","excerpt":"","text":"nginx概述 来源 Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日，nginx 1.0.4发布。 特点 占有内存少，并发能力强。Nginx可以在大多数Unix like OS上编译运行，并有Windows移植版。windows下的nginx使用的是native Win32 API编写的，使用select处理连接，所以windows下的nginx性能不会太高且伸缩性(scalability，意思是通过数量上的扩展满足系统业务的增长）也差些。另外windows下的nginx缺少一些模块：XSLT filter, image filter, GeoIP module, 和 embedded Perl language。同时需要注意的是： windows下nginx配置文件中的目录请使用“/”，而不是“”做目录分隔 windows下的nginx只有一个有效的工作进程 windows vista以后系统的不支持nginx的cache模块和需要共享内存支持的模块 widows下的nginx支持最大1024个并发连接 基本目录结构在window系统中，nginx目录结构如下（本文以nginx-1.11.5为例）：其中：conf存放默认配置文件。contrib存放一些实用工具，如geo配置生成工具（geo2nginx.pl）。docs存放一些说明文档。html存放默认的网页文件。logs存放nginx运行的访问接入日志和错误日志。temp存放一些静态缓存数据，用户访问的时候，如果有就直接从缓存里取。nginx.exenginx启动方式：双击nginx.exe或者在当前目录打开cmd窗口，使用命令nginx即可：如果要关闭nginx，则需要再打开一个cmd窗口，使用命令nginx -s stop: 配置文件nginx.conf基本介绍Nginx配置文件主要分为4部分：main（全局设置）、server（主机设置）、upstream（负载均衡服务器设置）和location（URL匹配特定位置的设置）。nginx.conf中的配置信息，根据其逻辑上的意义，对它们进行了分类，也就是分成了多个作用域，或者称之为配置指令上下文。不同的作用域含有一个或者多个配置项。 当前nginx支持的几个指令上下文：mainnginx在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。http与提供http服务相关的一些配置参数。例如：是否使用keepalive，是否使用gzip进行压缩等。serverhttp服务上支持若干虚拟主机。每个虚拟主机一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。在提供mail服务的代理时，也可以建立若干server.每个server通过监听的地址来区分。locationhttp服务中，某些特定的URL对应的一系列配置项。mail实现email相关的SMTP/IMAP/POP3代理时，共享的一些配置项（因为可能实现多个代理，工作在多个监听地址上）。 一个实际使用的nginx.conf 注：下述配置文件由于要加入注释说明，缩进效果不佳，因此取消了所有缩进，这可能不利于阅读，为此，说明文件结构如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253user nobody;worker_processes 4;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset utf-8; #access_log logs/host.access.log main; location / &#123; proxy_pass http://127.0.0.1:8089/; &#125; location /rest/monitor/ &#123; proxy_pass http://127.0.0.1:8080/dw-monitorTask/rest/monitor/; #反向代理配置 &#125; #error_page 404 /404.html; error_page 500 502 503 504 /50x.html; #定义错误页面 location = /50x.html &#123; root html; &#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; #&#125; # HTTPS server server &#123; &#125;&#125; 相应含义见每行注释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140####################################################################################################user nobody;#指定nginx worker进程运行用户以及用户组，默认nobody。worker_processes 4;#指定nginx要开启的进程数，最好与CPU个数相同。#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#用来定义全局错误日志文件。级别有：debug、info、notice、warn、error和crit。debug输出日志最为详细，crit输出日志最少。#pid logs/nginx.pid;#用来指定进程id的存储文件位置。events &#123; worker_connections 1024;&#125;#设定nginx的工作模式及连接上限。####################################################################################################http &#123;include mime.types;#实现对配置文件所包含的文件的设定，可以减少主配置文件的复杂度。default_type application/octet-stream;#设定默认类型为二进制流。#log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;# &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;# &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;#指定nginx日志的输出格式。main为此日志文件输出格式的名称，可以在下面access_log指令中引用。#access_log logs/access.log main;#指定nginx的access日志输出，使用上面声明的格式。sendfile on;#用于开启高效文件传输模式。#tcp_nopush on;#防止TCP阻塞。keepalive_timeout 65;#用于设置客户端连接保持活动的超时时间，超过这个时间，服务器会关闭该连接。#gzip on;#支持压缩传输，提高传输速度。#server这部分指定了一个虚拟主机。server &#123;listen 80;#监听端口。server_name localhost;#主机名（域名）。#charset utf-8;#web服务器的语言编码。#access_log logs/host.access.log main;#虚拟主机独立的访问日志。# ==================================================================================================================# 匹配url地址中有&quot;/&quot;，则执行花括号中的配置。具体在本项目中，匹配到&quot;/&quot;，则将请求转发至http://127.0.0.1:8089/，也就是项目中管理员模块（基础模块）所运行在的端口#（本地测试，管理员模块部署在本地tomcat中，且运行在8089端口，因此是http://127.0.0.1:8089/）location / &#123;proxy_pass http://127.0.0.1:8089/;#反向代理配置。特别注意：在nginx中配置proxy_pass时，当在后面的url加上了/（如上所写http://127.0.0.1:8089/），相当于是绝对根路径，则nginx不会把location中匹配的路径部分代理走；如果没有/，则会把匹配的路径部分也给代理走。再比如：#1、location /test/ &#123; # proxy_pass http://t6:8300; # &#125; ##2、location /test/ &#123; # proxy_pass http://t6:8300/; # &#125; ##对于上面两种配置，区别只在于proxy_pass转发的路径后是否带 “/” ##针对情况1，由于proxy_pass配置最后没有加/，则会把匹配的路径部分也给代理走。即如果访问http://server/test/test.jsp，则被nginx代理后，请求路径会便问http://t6:8300/test/test.jsp，将test/ 作为根路径（是一个相对路径），请求test/路径下的资源。##针对情况2，由于proxy_pass配置最后加了/，则不会把匹配的路径部分也给代理走。即如果访问http://server/test/test.jsp，则被nginx代理后，请求路径会变为 http://proxy_pass/test.jsp，直接访问server的根资源。&#125;# ==================================================================================================================# 匹配url地址中有&quot;/rest/monitor/&quot;，则执行花括号中的配置。具体在本项目中，匹配到&quot;/rest/monitor/&quot;，表明是具体业务子模块monitorTask的业务逻辑，则将请求转发至http://127.0.0.1:8080/dw-monitorTask/rest/monitor/location /rest/monitor/ &#123; proxy_pass http://127.0.0.1:8080/dw-monitorTask/rest/monitor/; #反向代理配置&#125;#error_page 404 /404.html;#定义错误页面# redirect server error pages to the static page /50x.htmlerror_page 500 502 503 504 /50x.html;#定义错误页面location = /50x.html &#123; root html; #nginx指定文件路径有两种方式root和alias，这里是默认值：root html&#125;#等号“=”表示完全一致&#125;#server这部分指定了其它的虚拟主机。# another virtual host using mix of IP-, name-, and port-based configuration##server &#123;# listen 8000;# listen somename:8080;# server_name somename alias another.alias;# location / &#123;# root html;# index index.html index.htm;# &#125;#&#125;#server这部分指定了其它的虚拟主机。# HTTPS server##server &#123;# listen 443 ssl;# server_name localhost;# ssl_certificate cert.pem;# ssl_certificate_key cert.key;# ssl_session_cache shared:SSL:1m;# ssl_session_timeout 5m;# ssl_ciphers HIGH:!aNULL:!MD5;# ssl_prefer_server_ciphers on;# location / &#123;# root html;# index index.html index.htm;# &#125;#&#125;&#125; 应用案例 在模块化的web项目中，应用被合理地拆分成了多个模块。有一些通用的模块会被多个项目复用，比如上述配置文件中提到的管理员模块，也就是基础入口模块。 具体访问一个web应用时，诸如登录鉴权，系统菜单路由这些功能统一由基础模块进行处理。具体地，这个独立的模块被部署在了本地tomcat中（8089端口），那么，项目启动后，初始访问路由”/“就会由此转发给http://127.0.0.1:8089/; 而对于具体业务项目来说，业务模块其功能根据需求单独开发，开发完成后结合基础管理员模块，通过nginx进行反向代理来进行通信。具体地，本项目业务模块部署在了本地另一个tomcat中（端口8080）。在这里，凡是拦截到请求“/rest/monitor/”，说明是本项目具体业务逻辑的内容，则会被转发至http://127.0.0.1:8080/dw-monitorTask/rest/monitor/。 可以看出，通过上述这种方式，整个项目不但变得清晰，而且模块化特点很明显，易于灵活迁移。比如，公共模块统一部署在某个公网服务器上，那么后续开发的新业务系统就可以通过这种方式复用某些共有功能，避免了重复开发，提高了开发效率。","categories":[{"name":"搭建部署","slug":"搭建部署","permalink":"http://www.gcidea.info/categories/搭建部署/"},{"name":"工程","slug":"搭建部署/工程","permalink":"http://www.gcidea.info/categories/搭建部署/工程/"}],"tags":[{"name":"搭建部署","slug":"搭建部署","permalink":"http://www.gcidea.info/tags/搭建部署/"},{"name":"Nginx","slug":"Nginx","permalink":"http://www.gcidea.info/tags/Nginx/"}]},{"title":"使用dora-proxy-plugin处理异步请求跨域问题","slug":"cross-origin-dora-proxy-plugin","date":"2016-10-25T05:22:04.000Z","updated":"2018-12-12T16:08:51.198Z","comments":true,"path":"2016/10/25/cross-origin-dora-proxy-plugin/","link":"","permalink":"http://www.gcidea.info/2016/10/25/cross-origin-dora-proxy-plugin/","excerpt":"","text":"前言 这个问题描述的背景，是基于访问本地前端项目的nodejs服务器，但是却请求线上API数据接口的场景。如果能做到统一本地线上环境是更好的，有利于维护和调试，具体做法可以参考：使用SwitchyOmega和Charles配置统一的开发和生产环境、客户端代理配置的几种常见方式 概述 根据前后端分离的原则，前端独立进行功能的开发，在与后端真实接口进行对接之前，可以自己通过mock数据的方式进行自测。如果后端已经产生接口，这时，代码中以相对路径发出的所有异步请求，就不能发送至本地服务器，而要通过代理进行转发。 实践 以dora为例，项目地址https://github.com/dora-js/dora。这是一个轻量的开发测试服务器。其配置文件为proxy.config.js，一般位于项目的根目录下，通过如下配置可达到效果。 12345678不使用mock数据的情况下，通过dora-proxy-plugin代理进行跨域请求转发工程运行在当前服务器（端口8989），所有API请求跨域转发至当前服务器（默认端口80）module.exports = &#123; 'GET /admin/!*': 'http://xxx.cn/index.php', 'PUT /admin/!*': 'http://xxx.cn/index.php', 'DELETE /admin/!*': 'http://xxx.cn/index.php', 'POST /admin/!*': 'http://xxx.cn/index.php',&#125;","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"http://www.gcidea.info/categories/前端工程化/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"前端工程化","slug":"前端工程化","permalink":"http://www.gcidea.info/tags/前端工程化/"}]},{"title":"Hexo博客框架配置优化-网站sitemap和RSS源订阅","slug":"hexo-sitemap-baidu-spider","date":"2016-10-23T14:53:13.000Z","updated":"2018-12-12T16:08:44.772Z","comments":true,"path":"2016/10/23/hexo-sitemap-baidu-spider/","link":"","permalink":"http://www.gcidea.info/2016/10/23/hexo-sitemap-baidu-spider/","excerpt":"","text":"前言 Sitemap 可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页。最简单的 Sitemap 形式，就是XML 文件，在其中列出网站中的网址以及关于每个网址的其他元数据（上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度为何等），以便搜索引擎可以更加智能地抓取网站。 简易信息聚合（也叫聚合内容）是一种RSS基于XML标准，在互联网上被广泛采用的内容包装和投递协议。RSS(Really Simple Syndication)是一种描述和同步网站内容的格式，是使用最广泛的XML应用。RSS搭建了信息迅速传播的一个技术平台，使得每个人都成为潜在的信息提供者。发布一个RSS文件后，这个RSS Feed中包含的信息就能直接被其他站点调用，而且由于这些数据都是标准的XML格式，所以也能在其他的终端和服务中使用，是一种描述和同步网站内容的格式。 可以看出，sitemap可以使得博客被搜索引擎抓取，增加博客受众；rss则提供了订阅博客的一种方式。为此，对本博客进行如下配置。 Hexo的sitemap 配置和RSS 配置 在hexo_config.yml中，做出如下配置：配置后重启hexo server 进行测试，使用网站域名/sitemap.xml看是否正常。（下图为本地测试） 使用百度站长工具提交sitemap并抓取1.登录站长平台，对网站进行CNAME验证在个人域名的注册商系统做好如下配置 2.提交链接 3.出现抓取失败的问题 原因：博客是搭建在github服务器上的，github拒绝百度爬虫爬取。相关解决方案：如何解决百度爬虫无法爬取搭建在Github上的个人博客的问题？ 使用AZ Reader进行RSS订阅测试AZ Reader是一款免费的rss阅读器，具备rss基本功能。进行简单配置后，就可进行正常浏览：","categories":[{"name":"搭建部署","slug":"搭建部署","permalink":"http://www.gcidea.info/categories/搭建部署/"},{"name":"工程","slug":"搭建部署/工程","permalink":"http://www.gcidea.info/categories/搭建部署/工程/"}],"tags":[{"name":"搭建部署","slug":"搭建部署","permalink":"http://www.gcidea.info/tags/搭建部署/"},{"name":"sitemap","slug":"sitemap","permalink":"http://www.gcidea.info/tags/sitemap/"},{"name":"rss源订阅","slug":"rss源订阅","permalink":"http://www.gcidea.info/tags/rss源订阅/"}]},{"title":"智慧交通数据可视化展现Demo","slug":"data-visualization","date":"2016-10-17T05:54:23.000Z","updated":"2018-12-12T16:08:48.348Z","comments":true,"path":"2016/10/17/data-visualization/","link":"","permalink":"http://www.gcidea.info/2016/10/17/data-visualization/","excerpt":"","text":"简介demo基于csv等格式的数据处理结果文件，对数据进行可视化展现。 模块划分 目标区域驻留人数统计 高铁到发站人流量统计 地铁到发站人流量统计 行政区客流量分析 城市职住分布 交互方式及效果呈现 demo源码托管于github，详见Github gcidea/data-visualization 下载完整的文件目录，浏览器（推荐Chrome）打开根目录下index.html即可。五个模块所需的测试数据文件在根目录下的data文件夹中，分别为data1—data5 目标区域驻留人数统计1.选择已经处理好的数据csv文件2.选择日期3.查看目标区域驻留人数统计情况 高铁到发站人流量统计1.文件引入与时间选择同上2.查看高铁到发站人流量统计情况3.点击某个高铁站可查询具体情况 地铁到发站人流量统计1.文件引入与时间选择同上2.查看高铁到发站人流量统计情况-全市站点3.点击某个站点可查询具体情况 行政区客流量分析1.文件引入与时间选择同上2.查看行政区客流量分析 城市职住分布1.文件引入与时间选择同上2.查看居住地人口分布热力图3.查看职住比蜂窝图 改进作为demo，目前还有很多可以完善的地方，比如支持更多种数据源，支持更多种数据展现形式等。","categories":[{"name":"FE综合","slug":"FE综合","permalink":"http://www.gcidea.info/categories/FE综合/"}],"tags":[{"name":"实现/应用","slug":"实现-应用","permalink":"http://www.gcidea.info/tags/实现-应用/"},{"name":"前端工程化","slug":"前端工程化","permalink":"http://www.gcidea.info/tags/前端工程化/"}]},{"title":"HTTP协议的持久连接-\"keep-alive\"与\"persistent\"","slug":"http-persistent-connection","date":"2016-10-16T07:27:31.000Z","updated":"2018-12-12T16:08:43.516Z","comments":true,"path":"2016/10/16/http-persistent-connection/","link":"","permalink":"http://www.gcidea.info/2016/10/16/http-persistent-connection/","excerpt":"","text":"前言 “keep-alive”概述 HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。 优点 可以看出keep-alive减小了连接的开销，时间有所缩短。 主要参数 “persistent” “keep-alive”主要用于HTTP1.0及以前的协议，新协议应使用”persistent”（保持对”keep-alive”的支持）。 HTTP1.0中默认是关闭的，需要在http头加入”Connection:Keep-Alive”，才能启用Keep-Alive；HTTP1.1中默认启用Keep-Alive，如果加入”Connection:close”，才关闭。目前大部分浏览器都是用HTTP1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://www.gcidea.info/categories/HTTP/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"HTTP","slug":"HTTP","permalink":"http://www.gcidea.info/tags/HTTP/"}]},{"title":"浏览器的文档模式-“标准模式”和“怪异模式”","slug":"browser-standards-quirks-mode","date":"2016-10-02T03:31:02.000Z","updated":"2018-12-12T16:08:53.586Z","comments":true,"path":"2016/10/02/browser-standards-quirks-mode/","link":"","permalink":"http://www.gcidea.info/2016/10/02/browser-standards-quirks-mode/","excerpt":"","text":"前言 所谓的标准模式是指，浏览器按W3C标准解析执行代码；怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。浏览器解析时到底使用标准模式还是怪异模式，与你网页中的DTD声明直接相关，DTD声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相应的方式加载网页并显示，忽略DTD声明,将使网页进入怪异模式(quirks mode)。《JavaScript权威指南》对此描述如下： 概述 由于历史的原因，不同浏览器对页面的渲染是不同的，甚至同一浏览器的不同版本也是不同的。在W3C标准出台之前，不同的浏览器在页面的渲染上没有同一的规范，产生了差异，即Quirks mode(怪异模式或兼容模式)；当W3C标准出台之后，不同浏览器对页面的渲染有了统一的标准,即Strict mode（标准模式或严格模式）；这就是两者之间的区别。 W3C标准推出前，旧的页面都是根据旧的渲染方式对页面进行渲染的，因此在W3C标准推出后为了保证旧页面的正常显示，保持浏览器的兼容性，这样浏览器上就产生了能够兼容W3C标准渲染的严格模式和保证旧页面显示的怪异模式的标准兼容模式。 知道了这两种渲染模式的来由，那剩下的问题就是浏览器如何能够确定应该使用哪种模式了。其实归根结底就是，浏览器如何能将旧网页与新网页区分开来。平常编写网页的时候，一般都会见到HTML文档的头部会有文档类型声明：DOCTYPE。当浏览器遇到正确的文档声明时，浏览器就会启动标准模式，按照制定的文档类型标准解析和渲染文档。而对于旧有的网页，由于网页编写的当时标准还没有确定，所以一般是不会有文档类型声明的。所以，对于没有文档类型声明或者文档类型声明不正确的文档，浏览器就会认为它是一个旧的HTML文档，就会使用怪异模式解析和渲染该文档。 目前开发中，统一使用html5下的标准：&lt;!DOCTYPE html&gt; 文档模式注意事项&lt;!DOCTYPE&gt; 声明必须是 HTML 文档的第一行，位于html标签之前。&lt;!DOCTYPE&gt; 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。HTML5 不基于 SGML，所以不需要引用 DTD。 常用声明1.HTML 51&lt;!DOCTYPE html&gt; 2.HTML 4.01 Strict该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。1&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"&gt; 3.HTML 4.01 Transitional该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。12&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt; 4.HTML 4.01 Frameset该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。12&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3.org/TR/html4/frameset.dtd\"&gt; 5.XHTML 1.0 Strict该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。12&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"&gt; 6.XHTML 1.0 Transitional该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。12&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt; 7.XHTML 1.0 Frameset该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。12&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\"&gt; 8.XHTML 1.1该 DTD 等同于 XHTML 1.0 Strict，但允许添加模型（例如提供对东亚语系的 ruby 支持）。1&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\"&gt; 典型区别盒模型的处理差异 标准CSS盒模型的宽度和高度等于内容区的高度和宽度，不包含内边距和边框，而IE6之前的浏览器实现的盒模型的宽高计算方式是包含内边距和边框的。因此，对于IE，怪异模式和标准模式下的盒模型宽高计算方式是不一样的。 行内元素的垂直对齐 很多早期的浏览器对齐图片至包含它们的盒子的下边框，虽然CSS的规范要求它们被对齐至盒内文本的基线。标准模式下，基于Gecko的浏览器将会对齐至基线，而在quirks模式下它们会对齐至底部。最直接的例子就是图片的显示。在标准模式下，图片并不是与父元素的下边框对齐的，如果仔细观察，你会发现图片与父元素下边框之间存在一点小空隙。那是因为标准模式下，图片是基线对齐的。而怪异模式下，则不存在这个问题。 width 在标准模式中，width是内容宽度 ，元素真正的宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right； 在怪异模式中，width则是元素的实际宽度 ，内容宽度 = width - ( padding-left + padding-right + border-left + border-right) 行内元素高度宽度 在标准模式下，给span等行内元素设置wdith和height都不会生效，而在怪异s模式下，则会生效。 百分比高度 在标准模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。 margin:0 auto设置水平居中 使用margin:0 auto在标准模式下可以使元素水平居中，但在怪异模式下却会失效。","categories":[{"name":"FE综合","slug":"FE综合","permalink":"http://www.gcidea.info/categories/FE综合/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"FE","slug":"FE","permalink":"http://www.gcidea.info/tags/FE/"}]},{"title":"JavaScript中的事件传播机制","slug":"client-side-js-event-propagation","date":"2016-09-22T14:40:47.000Z","updated":"2018-12-12T16:08:52.813Z","comments":true,"path":"2016/09/22/client-side-js-event-propagation/","link":"","permalink":"http://www.gcidea.info/2016/09/22/client-side-js-event-propagation/","excerpt":"","text":"前言 javascript与html的交互是通过事件实现的。在DOM2级模型中，为DOM元素绑定的事件有一套完整的事件传播机制，主要有3个阶段，本文进行小结。 ##","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"git pull 与 git fetch 的区别","slug":"git-pull-git-fetch","date":"2016-09-20T15:45:08.000Z","updated":"2018-12-12T16:08:45.588Z","comments":true,"path":"2016/09/20/git-pull-git-fetch/","link":"","permalink":"http://www.gcidea.info/2016/09/20/git-pull-git-fetch/","excerpt":"","text":"概述引用网上的一张图来说明 对比git fetch1.git fetch这将更新git remote 中所有的远程repo 所包含分支的最新commit-id, 将其记录到.git/FETCH_HEAD文件中。 2.git fetch remote_repo这将更新名称为remote_repo 的远程repo上的所有branch的最新commit-id，将其记录。 3.git fetch remote_repo remote_branch_name这将这将更新名称为remote_repo 的远程repo上的分支： remote_branch_name。 4.git fetch remote_repo remote_branch_name:local_branch_name这将这将更新名称为remote_repo 的远程repo上的分支： remote_branch_name ，并在本地创建local_branch_name 本地分支保存远端分支的所有数据。 FETCH_HEAD： 是一个版本链接，记录在本地的一个文件中，指向着目前已经从远程仓库取下来的分支的末端版本。每一个执行过fetch操作的项目都会存在一个FETCH_HEAD列表,其中每一行对应于远程服务器的一个分支。当前分支指向的FETCH_HEAD,就是这个文件第一行对应的那个分支. git pull执行步骤：1.基于本地的FETCH_HEAD记录，比对本地的FETCH_HEAD记录与远程仓库的版本号。2.git fetch 获得当前指向的远程分支的后续版本的数据。3.利用git merge将其与本地的当前分支合并。","categories":[{"name":"FE综合","slug":"FE综合","permalink":"http://www.gcidea.info/categories/FE综合/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"版本控制","slug":"版本控制","permalink":"http://www.gcidea.info/tags/版本控制/"}]},{"title":"$(document).ready与window.onload的区别","slug":"document-ready-window-onload","date":"2016-09-20T05:22:04.000Z","updated":"2018-12-12T16:08:47.931Z","comments":true,"path":"2016/09/20/document-ready-window-onload/","link":"","permalink":"http://www.gcidea.info/2016/09/20/document-ready-window-onload/","excerpt":"","text":"document.ready执行时机 只要页面DOM结构绘制完毕就执行，不必等到外部资源（图片，css等）加载完毕。 并且，在jquery中，$(function(){}) 和$(document).ready(function(){})两种写法是等价的。 特点 在同一个页面中可以写多次，会顺序执行，见下面测试。 window.onload执行时机 必须等到页面内包括图片的所有元素加载完毕后才能执行。 特点 在同一个页面中可以写多次（但没有意义），只会有一个生效，后面的会覆盖前面的，见下面测试。 验证测试代码1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"jquery-2.2.1.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;document.ready与window.onload的区别&lt;/p&gt;&lt;img src=\"http://cdn.gcidea.cn/p103.jpg\"/&gt;&lt;script&gt; $(document).ready(function() &#123; console.log(\"document.ready执行第1次\"); &#125;) $(document).ready(function() &#123; console.log(\"document.ready执行第2次\"); &#125;) window.onload = function() &#123; console.log(\"window.onload执行第1次\"); &#125; window.onload = function() &#123; console.log(\"window.onload执行第2次\"); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打印输出结果","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"JavaScript异步编程案例","slug":"js-async-programming","date":"2016-09-19T03:18:20.000Z","updated":"2018-12-12T16:08:38.487Z","comments":true,"path":"2016/09/19/js-async-programming/","link":"","permalink":"http://www.gcidea.info/2016/09/19/js-async-programming/","excerpt":"","text":"【转载】阮一峰 Javascript异步编程的4种方法 前言你可能知道，Javascript语言的执行环境是”单线程”（single thread）。 所谓”单线程”，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。 这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。 为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。 “同步模式”就是上一段的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；“异步模式”则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。 “异步模式”非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，”异步模式”甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。 本文总结了”异步模式”编程的4种方法，理解它们可以让你写出结构更合理、性能更出色、维护更方便的Javascript程序。 回调函数这是异步编程最基本的方法。假定有两个函数f1和f2，后者等待前者的执行结果。12f1();f2(); 如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数。123456 function f1(callback)&#123; setTimeout(function () &#123; // f1的任务代码 callback(); &#125;, 1000); &#125; 执行代码就变成下面这样：1 f1(f2); 采用这种方式，我们把同步操作变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。 事件监听另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的jQuery的写法）。1 f1.on('done', f2); 上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写：123456 function f1()&#123; setTimeout(function () &#123; // f1的任务代码 f1.trigger('done'); &#125;, 1000); &#125; f1.trigger(‘done’)表示，执行完成后，立即触发done事件，从而开始执行f2。这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。 发布/订阅上一节的”事件”，完全可以理解成”信号”。我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。这个模式有多种实现，下面采用的是Ben Alman的Tiny Pub/Sub，这是jQuery的一个插件。首先，f2向”信号中心”jQuery订阅”done”信号。1 jQuery.subscribe(\"done\", f2); 然后，f1进行如下改写：123456 function f1()&#123; setTimeout(function () &#123; // f1的任务代码 jQuery.publish(\"done\"); &#125;, 1000); &#125; jQuery.publish(“done”)的意思是，f1执行完成后，向”信号中心”jQuery发布”done”信号，从而引发f2的执行。此外，f2完成执行后，也可以取消订阅（unsubscribe）。1 jQuery.unsubscribe(\"done\", f2); 这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 Promises对象Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成：1 f1().then(f2); 12345678 function f1()&#123; var dfd = $.Deferred(); setTimeout(function () &#123; // f1的任务代码 dfd.resolve(); &#125;, 500); return dfd.promise; &#125; 这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。比如，指定多个回调函数：1 f1().then(f2).then(f3); 再比如，指定发生错误时的回调函数： 1 f1().then(f2).fail(f3); 而且，它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。这种方法的缺点就是编写和理解，都相对比较难。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"异步编程","slug":"异步编程","permalink":"http://www.gcidea.info/tags/异步编程/"}]},{"title":"前端常用的几种图片格式及使用场景","slug":"fe-picture-type","date":"2016-09-18T16:22:16.000Z","updated":"2018-12-12T16:08:46.361Z","comments":true,"path":"2016/09/19/fe-picture-type/","link":"","permalink":"http://www.gcidea.info/2016/09/19/fe-picture-type/","excerpt":"","text":"基本概念矢量图与位图 矢量图是通过组成图形的一些基本元素，如点、线、面，边框，填充色等信息通过计算的方式来显示图形的。一般来说矢量图表示的是几何图形，文件相对较小，并且放大缩小不会失真。 位图又叫像素图或栅格图，它是通过记录图像中每一个点的颜色、深度、透明度等信息来存储和显示图像。一张位图就好比一幅大的拼图，只不过每个拼块都是一个纯色的像素点。位图的优点是利于显示色彩层次丰富的写实图像。缺点则是文件大小较大，放大和缩小图像会失真。 有损压缩和无损压缩 有损压缩是对图像数据进行处理，去掉那些图像上会被人眼忽略的细节，然后使用附近的颜色通过渐变或其他形式进行填充。这样既能大大降低图像信息的数据量，又不会影响图像的还原效果。JPG是我们最常见的采用有损压缩对图像信息进行处理的图片格式。 无损压缩的压缩原理是先判断图像上哪些区域的颜色是相同的，哪些是不同的，然后把这些相同的数据信息进行压缩记录，而把不同的数据另外保存。这里要说明的是，无损压缩只是一种相对的“无损”压缩，并不是说无论如何压缩图片都不会失真。这点在PNG8中体现的尤为明显。PNG8最多只能索引256种颜色，所以在图像上出现的颜色数量大于我们可以保存的颜色数量时，我们就不能真实的记录和还原图像了。PNG是我们最常见的一种采用无损压缩的图片格式。 图片格式BMP格式BMP是英文Bitmap（位图）的简写，它是Windows操作系统中的标准图像文件格式，能够被多种Windows应用程序所支持。随着Windows操作系统的流行与丰富的Windows应用程序的开发，BMP位图格式理所当然地被广泛应用。这种格式的特点是包含的图像信息较丰富，几乎不进行压缩，但由此导致了它与生俱生来的缺点–占用磁盘空间过大。 GIF格式GIF是英文Graphics Interchange Format（图形交换格式）的缩写。顾名思义，这种格式是用来交换图片的。上世纪80年代，美国一家著名的在线信息服务机构CompuServe针对当时网络传输带宽的限制，开发出了这种GIF图像格式。GIF格式的特点是压缩比高，磁盘空间占用较少，所以这种图像格式迅速得到了广泛的应用。 它是一种简单的动画图片。目前Internet上大量采用的彩色动画文件多为这种格式的文件，也称为GIF89a格式文件。 但GIF有个小小的缺点，即不能存储超过256色的图像。尽管如此，这种格式仍在网络上大行其道应用，这和GIF图像文件短小、下载速度快、可用许多具有同样大小的图像文件组成动画等优势是分不开的。 JPEG格式JPEG也是常见的一种图像格式， JPEG文件的扩展名为.jpg或.jpeg，其压缩技术十分先进，它用有损压缩方式去除冗余的图像和彩色数据，获取得极高的压缩率的同时能展现十分丰富生动的图像，换句话说，就是可以用最少的磁盘空间得到较好的图像质量。 由于JPEG优异的品质和杰出的表现，它的应用也非常广泛。目前各类浏览器均支持JPEG这种图像格式，因为JPEG格式的文件尺寸较小，下载速度快，使得Web页有可能以较短的下载时间提供大量美观的图像，JPEG同时也就顺理成章地成为网络上最受欢迎的图像格式。 JPEG2000格式它是JPEG的升级版。JPEG 2000同样是由JPEG组织负责制定的，它有一个正式名称叫做”ISO15444”，与JPEG相比，它具备更高压缩率以及更多新功能的新一代静态影像压缩技术。 其压缩率比JPEG高约30%左右。 JPEG 2000 和 JPEG相比优势明显，且向下兼容，因此取代传统的JPEG格式指日可待。 JPEG2000可应用于传统的JPEG市场，如扫描仪、数码相机等，亦可应用于新兴领域，如网路传输、无线通讯等等。 TIFF格式TIFF（Tag Image File Format）是Mac中广泛使用的图像格式，它的特点是图像格式复杂、存贮信息多。正因为它存储的图像细微层次的信息非常多，图像的质量也得以提高，故而非常有利于原稿的复制。 该格式有压缩和非压缩二种形式，其中压缩可采用LZW无损压缩方案存储。不过，由于TIFF格式结构较为复杂，兼容性较差，因此有时你的软件可能不能正确识别TIFF文件（现在绝大部分软件都已解决了这个问题）。目前在Mac和PC机上移植TIFF文件也十分便捷，因而TIFF现在也是微机上使用最广泛的图像文件格式之一。 PSD格式这是著名的Adobe公司的图像处理软件Photoshop的专用格式Photoshop Document（PSD）。PSD其实是Photoshop进行平面设计的一张”草稿图”，它里面包含有各种图层、通道、遮罩等多种设计的样稿，以便于下次打开文件时可以修改上一次的设计。在Photoshop所支持的各种图像格式中，PSD的存取速度比其它格式快很多，功能也很强大。由于Photoshop越来越被广泛地应用，所以我们有理由相信，这种格式也会逐步流行起来。 PNG格式PNG（Portable Network Graphics）是一种新兴的网络图像格式。PNG一开始便结合GIF及JPG两家之长，打算一举取代这两种格式。1996年得到国际网络联盟推荐认可标准，并且大部分绘图软件和浏览器开始支持PNG图像浏览，从此PNG图像格式生机焕发。 PNG是目前保证最不失真的格式，它汲取了GIF和JPG二者的优点，存贮形式丰富，兼有GIF和JPG的色彩模式；它的另一个特点能把图像文件压缩到极限以利于网络传输，但又能保留所有与图像品质有关的信息，因为PNG是采用无损压缩方式来减少文件的大小，这一点与牺牲图像品质以换取高压缩率的JPG有所不同；它的第三个特点是显示速度很快，只需下载1/64的图像信息就可以显示出低分辨率的预览图像；第四，PNG同样支持透明图像的制作，透明图像在制作网页图像的时候很有用，我们可以把图象背景设为透明，用网页本身的颜色信息来代替设为透明的色彩，这样可让图像和网页背景很和谐地融合在一起。 PNG的缺点是不支持动画应用效果，如果在这方面能有所加强，简直就可以完全替代GIF和JPEG了。Macromedia公司的Fireworks软件的默认格式就是PNG。现在，越来越多的软件开始支持这一格式，而且在网络上也越来截止流行。 SWF格式利用Flash我们可以制作出一种后缀名为SWF（Shockwave Format）的动画，这种格式的动画图像能够用比较小的体积来表现丰富的多媒体形式。在图像的传输方面，不必等到文件全部下载才能观看，而是可以边下载边看，因此特别适合网络传输，特别是在传输速率不佳的情况下，也能取得较好的效果。事实也证明了这一点，SWF如今已被大量应用于WEB网页进行多媒体演示与交互性设计。此外，SWF动画是其于矢量技术制作的，因此不管将画面放大多少倍，画面不会因此而有任何损害。综上，SWF格式作品以其高清晰度的画质和小巧的体积，受到了越来越多网页设计者的青睐，也越来越成为网页动画和网页图片设计制作的主流，目前已成为网上动画的事实标准。 SVG格式SVG可以算是目前最最火热的图像文件格式了，它的意思为可缩放的矢量图形。严格来说应该是一种开放标准的矢量图形语言，可让你设计激动人心的、高分辨率的Web图形页面。用户可以直接用代码来描绘图像，可以用任何文字处理工具打开SVG图像，通过改变部分代码来使图像具有互交功能，并可以随时插入到HTML中通过浏览器来观看。 它提供了目前网络流行格式GIF和JPEG无法具备了优势：可以任意放大图形显示，但绝不会以牺牲图像质量为代价；字在SVG图像中保留可编辑和可搜寻的状态；平均来讲，SVG文件比JPEG和GIF格式的文件要小很多，因而下载也很快。可以相信，SVG的开发将会为Web提供新的图像标准。 选用标准 根据网上的推荐：","categories":[{"name":"FE综合","slug":"FE综合","permalink":"http://www.gcidea.info/categories/FE综合/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"FE","slug":"FE","permalink":"http://www.gcidea.info/tags/FE/"}]},{"title":"可视化HTML5页面拖拽构建工具demo","slug":"html5-draggable","date":"2016-09-17T14:53:13.000Z","updated":"2018-12-12T16:08:43.921Z","comments":true,"path":"2016/09/17/html5-draggable/","link":"","permalink":"http://www.gcidea.info/2016/09/17/html5-draggable/","excerpt":"","text":"简介 demo，在web端通过拖拽编排的方式快速定制活动H5页面，初步阶段完成。 交互方式及效果呈现 demo源码托管于github，详见Github gcidea/html5-draggable 使用流程1.拖拽页面布局至手机预览区2.根据不同类型的布局，点击可以编辑不同参数3.布局定制完成后可以向布局中拖拽添加素材4.页面定制完成后可以分享页面（TODO） 改进作为demo，目前还有很多可以完善的地方，比如页面分享，适配等问题待完成，在适配、持久化、模块化、框架集成方面有待改进优化。。","categories":[{"name":"HTML/HTML5","slug":"HTML-HTML5","permalink":"http://www.gcidea.info/categories/HTML-HTML5/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"实现/应用","slug":"实现-应用","permalink":"http://www.gcidea.info/tags/实现-应用/"},{"name":"前端工程化","slug":"前端工程化","permalink":"http://www.gcidea.info/tags/前端工程化/"},{"name":"HTML/HTML5","slug":"HTML-HTML5","permalink":"http://www.gcidea.info/tags/HTML-HTML5/"},{"name":"可视化拖拽","slug":"可视化拖拽","permalink":"http://www.gcidea.info/tags/可视化拖拽/"}]},{"title":"CSS中a:link、a:visited、a:hover、a:active的使用总结","slug":"css-a-link-visitd-hover-active","date":"2016-09-17T05:22:04.000Z","updated":"2018-12-12T16:08:50.797Z","comments":true,"path":"2016/09/17/css-a-link-visitd-hover-active/","link":"","permalink":"http://www.gcidea.info/2016/09/17/css-a-link-visitd-hover-active/","excerpt":"","text":"前言伪类 伪元素 区别 可以理解为：伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到。伪类用一个冒号来表示，而伪元素则用两个冒号来表示。 概述:link 选择器对指向未被访问页面的链接设置样式，即页面初始化加载完成的时候。:visited 选择器用于选取已被访问的链接，即已经访问过的链接。:hover 选择器用于设置鼠标指针浮动到链接上时的样式，即鼠标停留在链接上但还未点击的时候。:active 选择器用于设置点击链接时的样式。即链接被点击按下的时候。 注意事项:hover版本：CSS1/CSS2 兼容性：IE4+ NS4+语法：Selector : hover { sRules }说明：设置对象在其鼠标悬停时的样式表属性。在CSS1中此伪类仅可用于a对象。且对于无href属性的a标签，此伪类不发生作用。在CSS2中此伪类可以应用于任何对象。 :active版本：CSS1/CSS2 兼容性：IE4+语法：Selector : active { sRules }说明：设置对象在被用户激活（在鼠标点击与释放之间发生的事件）时的样式表属性。在CSS1中此伪类仅可用于a对象。且对于无href属性的a标签，此伪类不发生作用。在CSS2中此伪类可以应用于任何对象。并且:active状态可以和:link以及:visited状态同时发生。 :link版本：CSS1 兼容性：IE4+ NS4+语法：Selector : link { sRules }说明：设置a对象在未被访问前的样式表属性。IE3将:link伪类的样式表属性作用于visited伪类。默认值由浏览器决定。对于无href属性的a标签，此伪类不发生作用。 :visited版本：CSS1 兼容性：IE4+ NS4+语法：Selector : visited { sRules }说明：设置a对象在其链接地址已被访问过时的样式表属性。IE3将:link伪类的样式表属性作用于visited伪类。默认值由浏览器决定。定义网页过期时间或用户清空历史记录将影响此伪类的作用。对于无href属性的a标签，此伪类不发生作用。","categories":[{"name":"CSS/CSS3","slug":"CSS-CSS3","permalink":"http://www.gcidea.info/categories/CSS-CSS3/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"CSS/CSS3","slug":"CSS-CSS3","permalink":"http://www.gcidea.info/tags/CSS-CSS3/"}]},{"title":"CSS3媒体查询@media功能使用总结","slug":"css-at-media","date":"2016-09-17T05:22:04.000Z","updated":"2018-12-12T16:08:50.394Z","comments":true,"path":"2016/09/17/css-at-media/","link":"","permalink":"http://www.gcidea.info/2016/09/17/css-at-media/","excerpt":"","text":"前言 媒体查询包含一个可选的媒体类型和零或多个表达式来限制使用媒体特性的样式表范围，这些表达式会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示文档所使用的设备的类型以及所有的表达式的值都是true，那么该媒体查询的结果就是true。例如width，height，color。CSS3中的Media queries让内容的呈现可以只针对特定范围的输出设备而不必去改变内容本身。 示例1234567891011&lt;!-- link元素中的CSS媒体查询 --&gt;&lt;link rel=\"stylesheet\" media=\"(max-width: 600px)\" href=\"example.css\" /&gt;&lt;!-- 样式表中的CSS媒体查询 --&gt;&lt;style&gt;@media (max-width: 600px) &#123; .facet_sidebar &#123; display: none; &#125;&#125;&lt;/style&gt; 解释： 当媒体查询是true时，其相应的样式表或样式规则就会被应用。比如上面的写法表示，当设备宽度在600px以内，就会应用example.css中的样式或者使得”.facet_sidebar”这个类生效。 样式遵循正常的级联规则.即使媒体查询返回false,标签指向的样式表也将会被下载(尽管,他们将不会被采用) 语法123@media mediatype and|not|only (media feature) &#123; CSS-Code;&#125; 媒体功能 值 描述 aspect-ratio 定义输出设备中的页面可见区域宽度与高度的比率 color 定义输出设备每一组彩色原件的个数。如果不是彩色设备，则值等于0 color-index 定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于0 device-aspect-ratio 定义输出设备的屏幕可见宽度与高度的比率 device-height 定义输出设备的屏幕可见高度 device-width 定义输出设备的屏幕可见宽度 grid 用来查询输出设备是否使用栅格或点阵 height 定义输出设备中的页面可见区域高度 max-aspect-ratio 定义输出设备的屏幕可见宽度与高度的最大比率 max-color 定义输出设备每一组彩色原件的最大个数 max-color-index 定义在输出设备的彩色查询表中的最大条目数 max-device-aspect-ratio 定义输出设备的屏幕可见宽度与高度的最大比率 max-device-height 定义输出设备的屏幕可见的最大高度 max-device-width 定义输出设备的屏幕最大可见宽度 max-height 定义输出设备中的页面最大可见区域高度 max-monochrome 定义在一个单色框架缓冲区中每像素包含的最大单色原件个数 max-resolution 定义设备的最大分辨率 max-width 定义输出设备中的页面最大可见区域宽度 min-aspect-ratio 定义输出设备中的页面可见区域宽度与高度的最小比率 min-color 定义输出设备每一组彩色原件的最小个数 min-color-index 定义在输出设备的彩色查询表中的最小条目数 min-device-aspect-ratio 定义输出设备的屏幕可见宽度与高度的最小比率 min-device-width 定义输出设备的屏幕最小可见宽度 min-device-height 定义输出设备的屏幕的最小可见高度 min-height 定义输出设备中的页面最小可见区域高度 min-monochrome 定义在一个单色框架缓冲区中每像素包含的最小单色原件个数 min-resolution 定义设备的最小分辨率 min-width 定义输出设备中的页面最小可见区域宽度。 monochrome 定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于0 orientation 定义输出设备中的页面可见区域高度是否大于或等于宽度 resolution 定义设备的分辨率。如：96dpi, 300dpi, 118dpcm scan 定义电视类设备的扫描工序。 width 定义输出设备中的页面可见区域宽度。","categories":[{"name":"CSS/CSS3","slug":"CSS-CSS3","permalink":"http://www.gcidea.info/categories/CSS-CSS3/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"CSS/CSS3","slug":"CSS-CSS3","permalink":"http://www.gcidea.info/tags/CSS-CSS3/"}]},{"title":"使用原生js实现元素拖拽功能","slug":"js-draggable","date":"2016-09-12T14:40:47.000Z","updated":"2018-12-12T16:08:33.372Z","comments":true,"path":"2016/09/12/js-draggable/","link":"","permalink":"http://www.gcidea.info/2016/09/12/js-draggable/","excerpt":"","text":"前言 本篇仅对拖拽过程中核心几个事件监听的写法进行小结，不涉及页面样式效果的展现。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//第一个参数传入拖拽DOM节点ID//第二个参数为可选项传入工具名(业务需要，非重点)function dragDom(idName,toolName)&#123; var toolNameVal = typeof toolName == \"string\" ? toolName : false;//第二个参数为可选参数，表示工具名称 //根据传入id获取对应DOM元素 var oDiv=document.getElementById(idName); var currentTop,currentLeft,zIndexVal; if(toolName)&#123; //targetOffsetLeft是拖拽的DOM元素相对于文档的左偏移 var targetOffsetLeft = $(\"#\"+toolName).offset().left; //targetOffsetTop是拖拽的DOM元素相对于文档的上偏移 var targetOffsetTop = $(\"#\"+toolName).offset().top; &#125; //监听拖拽过程的鼠标点击下事件 oDiv.onmousedown = function(ev)&#123; var oEvent= ev || event; var disX = oEvent.clientX - oDiv.offsetLeft; var disY = oEvent.clientY - oDiv.offsetTop; zIndexVal = $(oDiv).css(\"z-index\"); // ... ... 其他业务逻辑 //事件浏览器兼容写法 if(oDiv.setCapture)&#123; oDiv.onmousemove=fnMove; oDiv.onmouseup=fnUp; oDiv.setCapture(); &#125; else&#123; document.onmousemove=fnMove; document.onmouseup=fnUp; &#125; //监听拖拽过程的鼠标移动事件 function fnMove(ev)&#123; var oEvent=ev||event; if(toolName==\"key_index\")&#123; //获取currentLeft： currentLeft = oDiv.style.left = (oEvent.clientX-disX) &lt;= (0-targetOffsetLeft) ? (0-targetOffsetLeft) + 'px' : (oEvent.clientX-disX) + 'px'; //获取currentTop： currentTop = oDiv.style.top = (oEvent.clientY-disY)&lt;=(0-targetOffsetTop)? (0-targetOffsetTop)+'px' : (oEvent.clientY-disY)+'px'; &#125; else &#123; ... ... &#125; oDiv.style.zIndex = 1200; &#125; //监听拖拽过程的鼠标松开事件 function fnUp()&#123; this.onmousemove=null; this.onmouseup=null; if(this.releaseCapture)&#123; this.releaseCapture(); &#125; if(toolName == \"key_index\")&#123; //组件的坐标起点需要修改,修改浮层的z-index值,开始调用创建页面元素方法 currentTop = parseInt(currentTop) + parseInt(document.body.scrollTop) - 120; currentLeft = parseInt(currentLeft) + 168; $(oDiv).parents(\"dl\").removeAttr(\"style\"); //拖拽的工具没有超出工具，此时将视为无效拖拽（即只有当currentTop大于0时，说明才将元素由顶部组件栏拖入了main_work_content） //并还原拖拽层 if(currentTop &gt;= 0)&#123; //console.log(\"currentTop:\"+(parseInt(currentTop)-120)+\"px;\"+\"currentLeft:\"+(parseInt(currentLeft)+168)+\"px\"); createKeyIndex(currentTop,currentLeft,\"main_work_content\",\"key_warp\"); &#125; //拖拽结束后重置拖拽层 currentTop = oDiv.style.left = 0; currentLeft = oDiv.style.top = 0; $(oDiv).removeAttr(\"style\"); &#125;else if(toolName == \"time_trend\")&#123; &#125; &#125; //... ... 其他业务逻辑 &#125;;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"实现/应用","slug":"实现-应用","permalink":"http://www.gcidea.info/tags/实现-应用/"},{"name":"可视化拖拽","slug":"可视化拖拽","permalink":"http://www.gcidea.info/tags/可视化拖拽/"}]},{"title":"DOM级别","slug":"dom-rank","date":"2016-09-12T05:22:04.000Z","updated":"2018-12-12T16:08:47.537Z","comments":true,"path":"2016/09/12/dom-rank/","link":"","permalink":"http://www.gcidea.info/2016/09/12/dom-rank/","excerpt":"","text":"DOM目标 DOM标准的目标是让“任何一种程序设计语言”能操控使用“任何一种标记语言”编写出的“任何一份文档”。“操控”具体含义为能通过DOM提供的API对文档的内容、结构、样式进行访问和修改。 DOM分类 DOM核心：针对任何结构化文档的标准模型 DOM XML ：只针对XML文档的标准模型 DOM HTML：只针对HTML文档的标准模型 DOM级别DOM Level 0 实际上没有没有DOM0级的官方标准。它是DOM历史的一个参照点，指的是IE4和Netscape4.0这些浏览器最初支持的DHTML。 DOM Level 1 DOM1级（DOM Level 1）于1998年10月成为W3C的推荐标准。DOM1级由两个模块组成：DOM核心（DOM Core）和DOM HTML。其中，DOM核心规定的是如何映射基于XML的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML模块则在DOM核心的基础上加以扩展，添加了针对HTML的对象和方法。 DOM Level 2 DOM2级在原来DOM的基础上又扩充了（DHTML一直都支持的）鼠标和用户界面事件、范围、遍历（迭代DOM文档的方法）等细分模块，而且通过对象接口增加了对CSS（Cascading Style Sheets，层叠样式表）的支持。DOM1级中的DOM核心模块也经过扩展开始支持XML命名空间。具体增加以下内容： DOM视图（DOM Views）：定义了跟踪不同文档（例如，应用CSS之前和之后的文档）视图的接口； DOM事件（DOM Events）：定义了事件和事件处理的接口； DOM样式（DOM Style）：定义了基于CSS为元素应用样式的接口； DOM遍历和范围（DOM Traversal and Range）：定义了遍历和操作文档树的接口。DOM Level 3 进一步扩展了DOM，引入了以统一方式加载和保存文档的方法–在DOM加载和保存（DOM Load and Save）模块中定义；新增了验证文档的方法–在DOM验证（DOM Validation）模块中定义。DOM3级也对DOM核心进行了扩展，开始支持XML 1.0规范，涉及XML Infoset、XPath和XML Base。 DOM级别与事件模型0级 0级模型的注册事件，典型如：1&lt;input type=\"button\" onclick=\"buttonClick()\"/&gt; 浏览器处理事件的时候只有原始事件模型，事件处理程序被设置为js代码串作为html的性质值。在js中html元素都有一个对应的对象，这个对象的属性对应那个html元素的性质，所以可以用js代码添加事件监听函数。通常情况下事件监听函数如果返回一个值并且是false，则会阻止浏览器执行默认的动作。无论用html还是js，都是把一个函数赋值给文档元素，在事件监听函数被调用时候它是作为产生事件的元素的方法调用的，所以this引用的是那个目标元素。 2级 2级DOM上的事件模型则涉及到了javascript对DOM的事件传播机制的操作，详见另一篇客户端JavaScript中的事件传播机制","categories":[{"name":"HTML/HTML5","slug":"HTML-HTML5","permalink":"http://www.gcidea.info/categories/HTML-HTML5/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"HTML/HTML5","slug":"HTML-HTML5","permalink":"http://www.gcidea.info/tags/HTML-HTML5/"}]},{"title":"使用IntelliJ IDEA构建并运行Java Web的maven项目","slug":"idea-java-web-maven-project","date":"2016-09-09T14:15:18.000Z","updated":"2018-12-12T16:08:42.237Z","comments":true,"path":"2016/09/09/idea-java-web-maven-project/","link":"","permalink":"http://www.gcidea.info/2016/09/09/idea-java-web-maven-project/","excerpt":"","text":"前言 相比于eclipse，IntelliJ IDEA的功能更加丰富，稳定。本文对使用IntelliJ IDEA构建运行一个基于maven管理的Java Web项目的过程进行记录。 项目代码导出 菜单栏选择VCS -&gt; Checkout from Version Control -&gt; Subversion 新建关联的SVN仓库，一般是填写内网部署的代码管理服务器地址 根据实际情况，填写访问授权信息 浏览文件结构，选择要导出的项目源码目录 可以看到IDEA在执行checkout任务 框架配置文件检测 导出完成后，IDEA会自动对整个项目目录进行indexing，这个过程中会检查到一些配置文件，选择确定即可 将项目添加为maven project 在项目根pom.xml文件上右键选择 Add as Maven Project，将项目添加为maven项目 可以看到 Add as Maven Project 后，IDEA开始根据pom文件配置下载依赖的plugins 项目结构project structure配置 添加为maven项目后，就可以开始配置项目结构相关的一些内容。首先在 Project 一项中，选择项目SDK，这里是jdk 1.8.0_9 同时下方Project language level要选择对应的SDK Default(8- Lambdas) 最基本的配置完成后，先尝试一下构建项目：Build Project，发现报错如下： 原因是本项目中并不是所有的依赖都是根据pom.xml文件进行配置的，有一部分依赖包就放在了项目本身中，具体是src-&gt;main-&gt;webapp-&gt;WEB-INF-&gt;lib。 因此，继续配置project structure的Libraries这一项，新建project library 将项目本身中存在的jar包目录添加进来 现在，再次Build Project，就没有报错了。 本地tomcat服务器配置1.点击右上角Edit Configurations 2.新增tomcat server -&gt; Local 3.在本页面具体配置如下红框中的项 具体分别是：Name：本服务器的名称，仅用作标识Application server：tomcat可执行目录文件JRE：对应1.8JDK默认即可HTTP port：服务运行所在端口JMX port：通过jdk的jconsole来监测tomcat运行情况 4.在Deployment选项卡下添加项目的artifact 5.选择war exploded包，这样才能在开发中使用热更新功能 6.至于Application context，则是项目运行后紧跟在端口号后的根路由 7.在如上选择war exploded包后，回到Server选项卡中配置如下两项，这就是热更新功能，在前端开发中十分方便，可以避免仅前端功能修改就要重新make整个项目并重启 项目启动 配置完成后，启动运行项目，可以在浏览器中看到项目运行正常","categories":[{"name":"搭建部署","slug":"搭建部署","permalink":"http://www.gcidea.info/categories/搭建部署/"},{"name":"工程","slug":"搭建部署/工程","permalink":"http://www.gcidea.info/categories/搭建部署/工程/"}],"tags":[{"name":"搭建部署","slug":"搭建部署","permalink":"http://www.gcidea.info/tags/搭建部署/"}]},{"title":"CSS3的pointer-events属性及典型应用","slug":"css3-pointer-events","date":"2016-09-01T05:22:04.000Z","updated":"2018-12-12T16:08:49.181Z","comments":true,"path":"2016/09/01/css3-pointer-events/","link":"","permalink":"http://www.gcidea.info/2016/09/01/css3-pointer-events/","excerpt":"","text":"概念 pointer-events是CSS3中的属性，最常用的有以下两个取值：1pointer-events:none|auto 设置“pointer-events:none”后元素永远不会成为鼠标事件的target。但是，当其后代元素的pointer-events属性指定其他值时，鼠标事件可以指向后代元素，在这种情况下，鼠标事件将在捕获或冒泡阶触发父元素的事件侦听器。 应用1 当已经点击“查询”按钮且查询结果尚未返回时，可使用该属性（结合按钮颜色变化）屏蔽按钮的点击事件，防止重复查询：1234567891011function btnStatusHandler(operation)&#123; if(operation == \"toSearch\")&#123; $(\"#submitButton\").html(\"查询中...\"); $(\"#submitButton\").css(\"background-color\",\"#EDEFF3\"); $(\"#submitButton\").css(\"pointer-events\",\"none\"); &#125; else &#123; $(\"#submitButton\").html(\"确定\"); $(\"#submitButton\").css(\"background-color\",\"transparent\"); $(\"#submitButton\").css(\"pointer-events\",\"auto\"); &#125;&#125; 应用2 在编辑列表选项可以上下移动交换位置的数据时，当某个item移动到第一行，其“上移”按钮应该不能再点击（同理，但某个item移动到最后一行，其“下移”按钮应该不能再点击）：1234567891011$(\"#histogram_data_right\").find('.table_td_text1_move_up_a').on('click',function(index)&#123; var $tr = $(this).parents(\"tr\"); $tr.prev().before($tr); if($tr.index() == 1)&#123; $(this).css(&#123;\"color\":\"#ddd\",\"pointer-events\":\"none\"&#125;); $tr.next().find('.table_td_text1_move_up_a').css(&#123;\"color\":\"#337ab7\",\"pointer-events\":\"auto\"&#125;); &#125;else if($tr.index() == 9)&#123;//一共有10个 $(this).next().css(&#123;\"color\":\"#337ab7\",\"pointer-events\":\"auto\"&#125;); $tr.next().find('.table_td_text1_move_down_a').css(&#123;\"color\":\"#ddd\",\"pointer-events\":\"none\"&#125;); &#125;&#125;);","categories":[{"name":"CSS/CSS3","slug":"CSS-CSS3","permalink":"http://www.gcidea.info/categories/CSS-CSS3/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"CSS/CSS3","slug":"CSS-CSS3","permalink":"http://www.gcidea.info/tags/CSS-CSS3/"}]},{"title":"JavaScript的call()、apply()、bind()方法对比总结","slug":"js-call-apply","date":"2016-08-26T03:27:31.000Z","updated":"2018-12-12T16:08:37.688Z","comments":true,"path":"2016/08/26/js-call-apply/","link":"","permalink":"http://www.gcidea.info/2016/08/26/js-call-apply/","excerpt":"","text":"前言 JavaScript中的函数其实就是一种对象。函数对象也有自己的很多方法。其中，call()方法和apply()方法就是两个用来间接调用函数的方法。两个方法都允许显式地指明调用时的上下文环境（即this的值）。也就是说，这给我们提供了一种自由—任何函数可以作为任何对象的方法来进行调用。并且，两个方法也都允许显式地指明调用时需要用到的实参。函数经call()或apply()调用后会立即执行，而经过bind()方法调用后，只是改变了函数绑定的作用域，要想执行函数，还需要对bind()的返回值（一个函数）进行一次调用。bind()方法的实现也是值得探究的内容。 call()方法参数 f.call(o, value1, value2, ...) f： 想要调用的方法 o： 想要调用的方法的作用域（也就是在哪个对象上调用该方法） value1, value2, …： 调用方法时传入的一系列参数使用示例1.简单调用call()方法，作用在当前this对象（浏览器对象）上 2.调用call()方法给自定义对象新增属性 apply()方法参数 f.apply(o, [value1, value2, ...]) f： 想要调用的方法 o： 想要调用的方法的作用域（也就是在哪个对象上调用该方法） [value1, value2, …]： 调用方法时传入的一个参数数组说明 给apply()传入的参数数组可以是真正的数组，也可以是类数组对象 类数组对象 它不是真正的数组对象，却有着很多与数组类似的特性。很多数组算法针对类数组对象的优化做的很好，就像针对真正的数组一样。下面是一个简单的类数组对象创建的过程： 使用示例Math.max()本来是可以接受任意个参数来判断最大值，但如果给它传入一个数组，是不能正确返回最大值的： 如果使用apply()方法，按照参数要求是接收一个数组，那么此时是可以给Math.max()传入一个数组的： bind()方法参数 fun.bind(thisArg[, arg1[, arg2[, ...]]]) thisArg当绑定函数被调用时，该参数会作为原函数运行时的this指向。当使用new操作符调用绑定函数时，该参数无效。 arg1, arg2, …当绑定函数被调用时，这些参数加上绑定函数本身的参数会按照顺序作为原函数运行时的参数。 返回值返回由指定的this值和初始化参数改造的原函数拷贝 说明 bind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call属性）。当目标函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。绑定函数被调用时，bind() 也接受预设的参数提供给原函数。一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 使用示例1234567891011121314this.x = 9; var module = &#123; x: 81, getX: function() &#123; return this.x; &#125;&#125;;module.getX(); // 返回 81var retrieveX = module.getX;retrieveX(); // 返回 9, 在这种情况下，\"this\"指向全局作用域// 创建一个新函数，将\"this\"绑定到module对象var boundGetX = retrieveX.bind(module);boundGetX(); // 返回 81 注意事项1.在ECMAScript5严格模式中，call()和apply()的第一个实参都会变为this的值，哪怕传入的实参是原始值甚至是null或undefined。而在ECMAScript3非严格模式中，传入的null或者undefined则会被全局对象代替，而原始值则会变成相应的包装对象。 2.为什么会存在call()和apply()这两个方法？—为了动态改变函数执行的环境。有时候，我们可能想在某个对象的作用域（上下文环境）A内调用一个方法—也就是要使用这个对象内的属性和值，但是这个对象内可能没有这个方法。此时，如果别处（全局函数或者其他对象的函数）有我们需要的方法F，那么我们就可以使用call()或apply()将需要的方法F和作用域A关联起来，从而实现目的。 3.从示例中可以看出三个方法的区别：call()和apply()放回会立即执行函数，而bind()只是将调用的函数的作用域进行绑定，如果要真正执行该函数，还要再调用一次：12var boundGetX = retrieveX.bind(module);boundGetX(); // 返回 81 也就是说，当希望改变上下文环境之后并非立即执行，而是回调执行的时候，应使用bind()方法。 4.bind()方法的原理是什么？如何实现一个bind方法？ 一句话来说，bind()的作用在于明确指定函数执行的作用域，而不是按照javascript语言本身的机制-函数的作用域由运行时决定而非声明时决定。比如说常见的错误做法是从对象中拿出了某个方法在对象外执行，却误以为该方法还能够使用对象中的相应属性。 bind()方法的实现涉及到了javascript语言的很多重要特性，分析过程如下：A. 简单地指定待调用目标函数的作用域：123456Function.prototype.bind = function (context) &#123; var self = this; return function () &#123; return self.apply(context, arguments); &#125;&#125; 解释A1. 实现的方法一定是Function原型链上的。A2. 该方法的参数是context，即指定的执行作用域。A3. 该方法只是改变了函数的执行作用域，并不立即执行，所以不能直接返回self.apply(context, arguments); 而是要返回一个函数，由该函数返回self.apply(context, arguments);A4. 返回的function的执行必然在bind这个function之外，由于闭包机制，返回的function的this将会丢失原来的指向调用bind方法的目标函数的引用，因此，采取的办法是，在bind方法内部使用一个变量self保存this，返回的函数在self上进行调用。这样，就避免了this的丢失和改变，self可以始终指向调用bind的目标函数。 B. 上面的实现有一个问题：不能在调用时传入额外的参数，也就是函数柯里化的问题。为此，改写如下：123456789Function.prototype.bind = function(context)&#123; var args = Array.prototype.slice.call(arguments, 1), self = this; return function()&#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return self.apply(context,finalArgs); &#125;;&#125;; 解释B1. arguments是一个类数组对象，使用Array.prototype.slice.call(arguments, 1),可以将其转换为真正的数组。而参数“1”的意思是，去掉bind()方法传入的第一个参数，因为第一个参数是指定的作用域，从第二个参数开始才是执行目标函数所需要的额外的参数。这样我们就得到了一个数组args，它存放的是调用bind()方法时传入的各个参数。B2. 在bind方法内部使用一个遍历self保存this，原因同上。B3. 返回的function中的arguments和B1中的不同，指的是传入待调用目标函数本身的参数项。这样，将args和innerArgs拼接起来，就既能支持bind传参，也能满足原目标函数的参数传入。 C. 现在已经有了bind()方法的实现。但是，Javascript中函数还可以作为构造函数，那么绑定后的函数如果以这种方式调用时，情况就会有所不同：1234567891011121314Function.prototype.bind = function(context)&#123; var args = Array.prototype.slice(arguments, 1), F = function()&#123;&#125;, self = this, bound = function()&#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return self.apply((this instanceof F ? this : (context || &#123;&#125;), finalArgs); &#125;; F.prototype = self.prototype; bound.prototype = new F(); return bound;&#125;; 解释C1. 与B中情况相比，新增了F = function(){}作为构造函数。js中的构造函数和其他面向对象的语言不太一样，js的构造函数并不是一类特殊的函数，准确地说应该是普通函数的构造调用 。 构造函数需要使用new关键字进行调用。以这种方式进行调用会经历以下4个阶段：1.创建一个新对象2.将构造函数的作用域赋给新对象（即使得构造函数中的this指向这个新对象）3.执行构造函数中的代码4.返回新对象 C2.将目标函数自身的参数和执行bind()时候传入的参数拼接在一起后，通过apply方法交由self也就是目标函数进行执行。而具体的作用域的选择与之前有所不同：(this instanceof F ? this : context)注意，这里的this与self不同，比如bind的使用方式一般如下：12var func = foo.bind(obj);func(); 在这种方式下，self指的是调用bind函数的目标函数，即foo；foo.bind(obj);会返回一个函数bound，也就是改变了作用域的foo函数，这里用变量func表示。而(this instanceof F ? this : context)中的this则相对比较复杂： 这实质上是一种polyfill代码，用于旧浏览器的兼容。总的来说，这段代码的作用是判断绑定后的函数是否是通过new关键字调用的（而非直接调用），如果是的话，就会使用新创建的this（即上面描述的new的4个阶段的第2个）代替硬绑定的context。由此也可以看出，new绑定方式的优先级是高于显式绑定的（调用bind()方法进行绑定叫做硬绑定，它是显式绑定的一种）。 C3.通过设置一个中转构造函数F，使绑定后的函数与调用bind()的函数处于同一原型链上，用new操作符调用绑定后的函数，返回的对象也能正常使用instanceof。 D.为了在浏览器中能支持bind()函数，需要对C中实现进行修改：1234567891011121314151617181920Function.prototype.bind = function (oThis) &#123; if (typeof this !== \"function\") &#123; throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\"); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () &#123;&#125;, fBound = function () &#123; return fToBind.apply( this instanceof fNOP &amp;&amp; oThis ? this : (oThis || window), aArgs.concat(Array.prototype.slice.call(arguments)) ); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; &#125;; 解释D1.与C相比，对bind方法进行增强，判断调用bind方法的对象是不是一个函数，如果不是，抛出错误。这种判断是与ES5内部的实现最为接近的用于IsCallable()函数。D2.关于this instanceof fNOP &amp;&amp; oThis ? this : (oThis || window)这一句，即判断新绑定的函数是否是通过new关键字调用的，如果是，且由于new绑定的优先级高，就要把函数的作用域绑定到new调用所创建的作用域this上，否则的话，说明是直接调用的，那么就继续使用调用bind()函数时候传入的作用域，为了健壮性，如果调用时未传入要绑定的对象或者传入了null，那么就默认绑定到window对象上。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"使用HTML5的FileAPI完成图片预览上传","slug":"js-html5-file-api","date":"2016-08-23T14:57:46.000Z","updated":"2018-12-12T16:08:32.271Z","comments":true,"path":"2016/08/23/js-html5-file-api/","link":"","permalink":"http://www.gcidea.info/2016/08/23/js-html5-file-api/","excerpt":"","text":"前言 html5提供了File API，可以很好用于图片上传和本地预览的使用场景。 html结构以下html片段表示了图片上传组件的文档结构，依赖Amaze UI样式框架。123456789101112131415161718192021222324252627282930313233343536&lt;div class=\"am-g\"&gt; &lt;div class=\"am-form-group-sm am-u-sm-6\"&gt; &lt;div class=\"am-form-group\"&gt; &lt;label id=\"thumb-label\"&gt;资讯缩略图&#123;$queryResult['id']==null?'(新增图片预览)':'(已有图片展示)'&#125;---尺寸&#123;$picConfig.width&#125; &amp;times; &#123;$picConfig.height&#125;&lt;/label&gt; &lt;div id=\"article-upload-preview\" class=\"am-form-field am-radius\" style=\"width: 100%; height: 200px;background-repeat:no-repeat;border: 0px;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"am-form-group-sm am-u-sm-6\"&gt; &lt;div class=\"am-form-group\"&gt; &lt;div class=\"am-form-group am-form-file\"&gt; &lt;button type=\"button\" class=\"am-btn am-btn-default am-btn-sm am-padding-xs\"&gt; &lt;i class=\"am-icon-cloud-upload\"&gt;&lt;/i&gt; 请选择要上传的图片&lt;/button&gt; &lt;input id=\"article-upload-file\" name=\"picture\" type=\"file\" accept=\".png,.jpg,.jpeg,.gif\" multiple&gt; &lt;input id=\"article-upload-file-hidden\" name=\"\" type=\"file\" accept=\".png,.jpg,.jpeg,.gif\" multiple style=\"display: none\"&gt; &lt;/div&gt; &lt;div id=\"article-upload-info\"&gt; &lt;label&gt;新增图片信息&lt;/label&gt; &lt;div class=\"am-tabs\" data-am-tabs&gt; &lt;ul class=\"am-tabs-nav am-nav am-nav-tabs\"&gt; &lt;li class=\"am-active\"&gt;&lt;a href=\"#tab1\"&gt;图片名称&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#tab2\"&gt;图片大小&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#tab3\"&gt;图片修改时间&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"am-tabs-bd\"&gt; &lt;div class=\"am-tab-panel am-fade am-in am-active\" id=\"tab1\"&gt; &lt;/div&gt; &lt;div class=\"am-tab-panel am-fade\" id=\"tab2\"&gt; &lt;/div&gt; &lt;div class=\"am-tab-panel am-fade\" id=\"tab3\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 使用效果如下图所示： 交互逻辑图片上传DOM元素获取1234var preview = document.getElementById('article-upload-preview'), fileInput = document.getElementById('article-upload-file'), fileInputHidden = document.getElementById('article-upload-file-hidden'), info = document.getElementById('article-upload-info'); 预览之前已经保存过的图片12preview.style.backgroundImage = 'url(\"xxxxxxx\")';preview.style.backgroundSize ='300px 200px'; 使用H5的API进行商品缩略图读取和预览-监听change事件12345678910111213141516171819202122232425262728293031323334353637fileInput.addEventListener('change', function () &#123; changeFlag = false; // 清除背景图片: preview.style.backgroundImage = ''; $('#thumb').val(''); // 检查文件是否选择: if (!fileInput.value) &#123; alert(\"请选择一张缩略图!\"); $('#tab1').html(\"\"); $('#tab2').html(\"\"); $('#tab3').html(\"\"); return; &#125; // 获取File引用: var file = fileInput.files[0]; // 设置Tabs选项卡组件File信息: $('#tab1').html(file.name); $('#tab2').html((file.size/1024).toFixed(2) + 'KB'); $('#tab3').html(file.lastModifiedDate.toLocaleDateString().replace(/\\//g,\"-\") + '' + file.lastModifiedDate.toLocaleTimeString()); if (file.type !== 'image/jpeg' &amp;&amp; file.type !== 'image/png' &amp;&amp; file.type !== 'image/gif' &amp;&amp; file.type !== 'image/gif') &#123; alert('不是有效的图片文件!'); return; &#125; // 读取文件: var reader = new FileReader(); reader.onload = function(e) &#123; var data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...' preview.style.backgroundImage = \"url(\" + data + \")\"; preview.style.backgroundSize ='300px 200px'; &#125;; // 以DataURL的形式读取文件: reader.readAsDataURL(file);&#125;);","categories":[{"name":"HTML/HTML5","slug":"HTML-HTML5","permalink":"http://www.gcidea.info/categories/HTML-HTML5/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"实现/应用","slug":"实现-应用","permalink":"http://www.gcidea.info/tags/实现-应用/"},{"name":"HTML/HTML5","slug":"HTML-HTML5","permalink":"http://www.gcidea.info/tags/HTML-HTML5/"}]},{"title":"jQuery中$.when()方法和deferred对象相关总结","slug":"jQuery-when-deferred","date":"2016-08-23T14:40:47.000Z","updated":"2018-12-12T16:08:41.002Z","comments":true,"path":"2016/08/23/jQuery-when-deferred/","link":"","permalink":"http://www.gcidea.info/2016/08/23/jQuery-when-deferred/","excerpt":"","text":"概述jQuery.when( deferreds )1.提供一种方法来执行零个或多个对象的回调函数， Deferred(延迟)对象通常表示异步事件。 2.如果没有参数传递给 jQuery.when()，它会返回一个resolved状态的Promise。 3.如果传递一个非Deferred或Promise对象给jQuery.when()，那么它会被当作是一个被解决（resolved）的延迟对象，并且绑定到上面的任何doneCallbacks 都会被立刻执行。向 doneCallbacks 中传入的是原始的参数。在这种情况下，设定的任何 failCallbacks 永远都不会被执行，因为延迟对象永远不会被拒绝（rejected）。 4.如果向 jQuery.when() 传入一个单独的延迟对象，那么会返回它的 Promise 对象(延迟方法的一个子集)。可以继续绑定 Promise 对象的其它方法，例如， defered.then 。123$.when( $.ajax(\"test.aspx\") ).then(function(data, textStatus, jqXHR) &#123; alert( jqXHR.status ); // alerts 200&#125;); 5.在多个延迟对象传递给jQuery.when() 的情况下，该方法根据一个新的“宿主”Deferred（延迟）对象，跟踪所有已通过Deferreds聚集状态，返回一个Promise对象。当所有的延迟对象被解决（resolve）时，“宿主”Deferred（延迟）对象才会解决（resolved）该方法，或者当其中有一个延迟对象被拒绝（rejected）时，“宿主”Deferred（延迟）对象就会reject（拒绝）该方法。如果“宿主”Deferred（延迟）对象是（resolved）解决状态时， “宿主” Deferred（延迟）对象的 doneCallbacks（解决回调）将被执行。参数传递给doneCallbacks提供这解决（resolved）值给每个对应的Deferreds对象，并匹配Deferreds传递给 jQuery.when()的顺序。 例如：12345678910var d1 = $.Deferred();var d2 = $.Deferred(); $.when( d1, d2 ).done(function ( v1, v2 ) &#123; console.log( v1 ); // \"Fish\" console.log( v2 ); // \"Pizza\"&#125;); d1.resolve( \"Fish\" );d2.resolve( \"Pizza\" ); 6.在多延迟情况下，如果Deferreds延迟对象一被拒绝（rejected），jQuery.when()触发立即调用“宿主”Deferred（延迟）对象的failCallbacks。请注意在这个时间点上，有一些延迟对象仍然可以是未解决（unresolved）的。 实例 实际项目中曾有这样的场景：同一个页面有多个模块的业务，需要查询不同的数据源。页面加载完成或者点击查询后，会发出多个异步请求，它们返回的先后是不一定的，而想对查询结果做一个统一处理，比如超时重试，错误处理等，就应该使用$.when：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//时间查询点击“确定”按钮 $(\"#submitButton\").click(function()&#123; $(\".portrait_make,.portrait_make1,.portrait_make2\").addClass(\"hide\"); var searchTime = $(\"#recordTime\").val(); if(searchTime==null||searchTime=='')&#123; alert(\"请选择查询日期!\"); &#125;else&#123; opType=1; var formatRecordTime=getSearchTimeFormat2(searchTime); $(\"#hideSearchTime\").val(formatRecordTime); searchBtnStatusHandler(\"toSearch\"); // ... ... 省略若干业务逻辑 //initTimeEChart等四个方法返回的都是$.ajax(&#123;&#125;)的deferred对象 var deferred = []; deferred.push(initTimeEChart(formatRecordTime)); deferred.push(initAllFunnelEchartAndTable(formatRecordTime)); deferred.push(initKeyModel(formatRecordTime)); deferred.push(initKeyGroupModel(formatRecordTime)); deferred.push(refreshPieEchartAll(formatRecordTime)); errorStack = []; $.when.apply($,deferred) .done(function () &#123; searchBtnStatusHandler(\"toReset\"); &#125;) .fail(function () &#123; alert(errorStack.join(\";\")); searchBtnStatusHandler(\"toReset\"); &#125;) &#125; &#125;);//时间搜索按钮状态处理函数function searchBtnStatusHandler(operation)&#123; if(operation == \"toSearch\")&#123; $(\"#submitButton\").html(\"查询中...\"); $(\"#submitButton\").css(\"background-color\",\"#EDEFF3\"); $(\"#submitButton\").css(\"pointer-events\",\"none\"); &#125; else &#123; $(\"#submitButton\").html(\"确定\"); $(\"#submitButton\").css(\"background-color\",\"transparent\"); $(\"#submitButton\").css(\"pointer-events\",\"auto\"); &#125;&#125;","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://www.gcidea.info/categories/jQuery/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://www.gcidea.info/tags/jQuery/"},{"name":"异步编程","slug":"异步编程","permalink":"http://www.gcidea.info/tags/异步编程/"}]},{"title":"使用JavaScript实现三级联动和实时搜索","slug":"js-three-level-linkage-and-dynamic-search","date":"2016-08-21T03:27:46.000Z","updated":"2018-12-12T16:08:30.180Z","comments":true,"path":"2016/08/21/js-three-level-linkage-and-dynamic-search/","link":"","permalink":"http://www.gcidea.info/2016/08/21/js-three-level-linkage-and-dynamic-search/","excerpt":"","text":"前言 本篇仅对三级联动和实时搜索的核心给出说明，对于页面设计、整个工程结构等不做说明。 三级联动根据交互操作异步触发获取第一列数据12345678910111213141516171819202122232425262728293031323334353637383940//异步请求第一列数据-可选指标名称 $.ajax(&#123; type: \"POST\", async: true, url: \"../xxxxxx\", data : &#123;\"indexId\":chiose_index_id,\"dimensionId\":chiose_dimension_id,timeDimId:$(\"#time_select_time\").val()&#125;, dataType: \"json\" &#125;).done(function (data) &#123; datalevel1 = data.rows1; datalevel2 = data.rows2; datalevel3 = data.rows3; var treeObj = $.fn.zTree.getZTreeObj(\"treeDemoTime\"); var checkedNode = treeObj.getCheckedNodes(true); var nodes = treeObj.getNodes(); //判断已选数据有值，有的话进行默认选中 if(chiose_dimension_length&gt;0) &#123; //默认选中第一维度中的选项 dimension_html(1, datalevel1, $('#time_trend_level1'), \"time_trend_name\", chiose_index_id); //默认选中第二维度中的选项 dimension_html(2, datalevel2, $('#time_trend_level2'), \"time_trend_name\", chiose_dimension_index_array[1].index_id); //默认选中第三维度中的选项 if(chiose_dimension_index_array[1].index_id == \"1\")&#123; dimension_html(3, datalevel3, $('#time_trend_level3'), \"time_trend_name\", time_info.glt_id, \"radio\"); &#125; else &#123; dimension_html(3, datalevel3, $('#time_trend_level3'), \"time_trend_name\", chiose_dimension_index_array[1].chiose.id, \"checkbox\"); &#125; &#125;else&#123; //没有默认数据的时候，直接回调第一维度选项（但没有选中的项） dimension_html(1,datalevel1,$('#time_trend_level1'),\"time_trend_name\",chiose_index_id); //同样调用level2 level3的渲染，但数据源传空 dimension_html(2, datalevel2, $('#time_trend_level2'), \"time_trend_name\"); dimension_html(3, &#123;&#125;, $('#time_trend_level3'), \"time_trend_name\"); &#125; // 省略其他各种业务逻辑... ... &#125;); 点击第一列数据异步获取第二列数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//绑定第一维度的li点击事件$(\"#time_trend_level1\").on('click',\"li\",function()&#123; //从第一维度的每个li上的data中取出绑定的数据 var currentLevel1_id = $(this).data(\"time_trend_name\").id; var currentLevel1_name = $(this).data(\"time_trend_name\").name; var is_url_rel = $(this).data(\"time_trend_name\").isUrlRel; //获取当前行&lt;tr&gt;标签上绑定的数据 var currentTrElement = $(\"#time_line_index_tab table tr\").eq(time_tab_index + 1); var currentDataObj = currentTrElement.data(\"indInformationAll\"); //已选指标的类型-单选/多选 var chiose_index_type = currentDataObj &amp;&amp; currentDataObj.chiose_index ? currentDataObj.chiose_index.type : \"\"; var time_trend_chiose_tit_info_index = $(\"#time_trend_chiose_tit_info_index&gt;dt\"); var time_trend_chiose_tit_info_index_dd = $(\"#time_trend_chiose_tit_info_index&gt;dd\"); var time_trend_chiose_tit_info_dimension_dd = $(\"#time_trend_chiose_tit_info_dimension&gt;dd\"); //选中项背景高亮 $(\"#time_trend_level1&gt;li\").removeClass(\"active\"); $(\"#time_chiose_tit_info&gt;dd\").remove(); $(this).addClass(\"active\"); //第一列指标名称一旦点击，就把第二列“可选维度”置空 $(\"#time_trend_level2\").html(\"\"); //根据新选择的指标名称，获取并渲染第二维度数据 $.ajax(&#123; type : \"POST\", async : true, url : \"../xxxxxx\", data : &#123;\"Level1Id\":currentLevel1_id&#125;, dataType : \"json\", success : function(data) &#123; datalevel2 = data.rows2; dimension_html(2,datalevel2,$('#time_trend_level2'),\"time_trend_name\"); var requriedDimId = []; for(var i = 0;i &lt; datalevel2.length;i++) &#123; var dim = datalevel2[i]['level' + (i+1)]['level1_name']; if (dim.is_required == 1)&#123; requriedDimId.push(dim.id); &#125; &#125; $(\"#time_trend_chiose_tit_info_index&gt;dd\").eq(0).data(\"required_dim_id\",requriedDimId); &#125; &#125;);&#125;); 点击第二列数据异步获取第三列数据 道理同上，不再重复。 实时搜索 实时搜索是一个和三级联动结合在一起的功能（当然也可以分开使用）。当每一列的数据选项有很多时，就可以提供一个搜索框，根据用户输入进行实时筛选（这个过程中是没有查询请求的，所有数据已经取回，渲染在列表中，只要监听相应事件进行筛选即可）1234567891011121314151617//可选指标搜索 $(\"#time_trend_chiose_con_search_indexname_input\").on(\"input\", function (event) &#123; //获取当前搜索框内容 var searchVal = $(\"#time_trend_chiose_con_search_indexname_input\").val().toLowerCase(); //每次查询都先将所有子标签显示，在此基础上筛选 $(\"#time_trend_level1 li\").each(function () &#123; $(this).removeClass(\"hide\"); &#125;); //如果子标签li中没有搜索字符串，则隐藏 $(\"#time_trend_level1 li\").each(function () &#123; if($(this).html().toString().toLowerCase().indexOf(searchVal) == -1)&#123; $(this).addClass(\"hide\"); &#125; &#125;) &#125;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"实现/应用","slug":"实现-应用","permalink":"http://www.gcidea.info/tags/实现-应用/"}]},{"title":"CSS的颜色空间-Color Name、HEX、RGB、RGBA、HSL、HSLA","slug":"css3-rgb-rgba-hsl-hsla","date":"2016-08-14T15:38:47.000Z","updated":"2018-12-12T16:08:48.751Z","comments":true,"path":"2016/08/14/css3-rgb-rgba-hsl-hsla/","link":"","permalink":"http://www.gcidea.info/2016/08/14/css3-rgb-rgba-hsl-hsla/","excerpt":"","text":"前言 通过CSS指定元素颜色是经常遇到的操作。在CSS中有多种表示颜色的方式。其中，RGBA、HSL、HSLA这三个是CSS3中新增的颜色表示方法。CSS提供了很多和color相关的属性，常用的主要有color、background-color、border-color、text-decoration-color等。下面的说明，均以对background-color的赋值为例。 Color Name格式background-color: Color Name 说明直接指定颜色英文名称。在webstorm中，我们只需要输入red/green/blue/yellow这样常见的颜色单词，IDE会提示我们相关颜色，可以通过预览进行选择，如下： 案例指定一组div元素的背景色：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #i1 &#123; border-radius: 50%; background-color: red; width: 100px; height: 100px; float: left; margin-left: 20px; &#125; #i2 &#123; border-radius: 50%; background-color: blue; width: 100px; height: 100px; float: left; margin-left: 20px; &#125; #i3 &#123; border-radius: 50%; background-color: yellow; width: 100px; height: 100px; float: left; margin-left: 20px; &#125; #i4 &#123; border-radius: 50%; background-color: green; width: 100px; height: 100px; float: left; margin-left: 20px; &#125; #i5 &#123; border-radius: 50%; background-color: gray; width: 100px; height: 100px; float: left; margin-left: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"color-preview\"&gt; &lt;div id=\"i1\"&gt;&lt;/div&gt; &lt;div id=\"i2\"&gt;&lt;/div&gt; &lt;div id=\"i3\"&gt;&lt;/div&gt; &lt;div id=\"i4\"&gt;&lt;/div&gt; &lt;div id=\"i5\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 结果如下： HEX格式background-color: #RRGGBB 或 #RGB 说明可以用如上的十六进制法表示颜色，其中RR、GG、BB或者R、G、B分别代表红(R)、绿(G)、蓝(B)三个颜色通道的变化用它们相互之间的叠加来得到各式各样的颜色。6位或者3位，每一位是一个十六进制数字（其中字母大小写均可），取值范围0~F。表示时必须是两位数，对于只有一位的，应在前面补零。如果每个参数各自在两位上的数字都相同，那么本单位也可缩写为 #RGB 的方式。例如：#FF8800 可以缩写为 #F80。注意此色彩模式与RGB色彩模式不同。 案例将上述代码中background-color分别替换为：”#0A8”、”#4a226d”、”#ee5f5b”、”#2b542c”、”#4f74cd”，结果如下： RGB格式background-color: rgb(R,G,B) 说明R：红色值。正整数 | 百分数G：绿色值。正整数 | 百分数B：蓝色值。正整数 | 百分数 以上三个参数，正整数值的取值范围为：0 - 255。百分数值的取值范围为：0.0% - 100.0%。超出范围的数值将被截至其最接近的取值极限。如：rgb(300,0,0)会被解析为rgb(255,0,0)正整数值255对应百分比数值100%，如：rgb(255,255,255) = rgb(100%,100%,100%) = #FFFFFF = #FFF。此RGB色彩模式与#RRGGBB/#RGB(HEX)不同。 案例将上述代码中background-color分别替换为：”rgb(255,255,0)”、”rgb(0,0,255)”、”rgb(0,255,0)”、”rgb(255,0,0)”、”rgb(0,0,0)”，结果如下： RGBA格式background-color: rgb(R,G,B,A) 说明R：红色值。正整数 | 百分数G：绿色值。正整数 | 百分数B：蓝色值。正整数 | 百分数A：Alpha透明度。取值0~1之间。 此色彩模式与RGB相同，只是在RGB模式上新增了Alpha透明度。0是完全透明，1是完全不透明。 案例将上述代码中background-color分别替换为：”rgba(0,255,0,0.1)”、”rgba(0,255,0,0.3)”、”rgba(0,255,0,0.5)”、”rgba(0,255,0,0.7)”、”rgba(0,255,0,1)”，结果如下： HSL格式background-color: HSL(H,S,L) 说明H：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360S：Saturation(饱和度)。取值为：0.0% - 100.0%。饱和度可定义为彩度除以明度，与彩度同样表征彩色偏离同亮度灰色的程度。饱和度是指色彩的鲜艳程度，也称色彩的纯度。饱和度取决于该色中含色成分和消色成分（灰色）的比例。含色成分越大，饱和度越大；消色成分越大，饱和度越小。纯的颜色都是高度饱和的，如鲜红，鲜绿。混杂上白色，灰色或其他色调的颜色，是不饱和的颜色，如绛紫，粉红，黄褐等。L：Lightness(亮度)。取值为：0.0% - 100.0%。在白色背景下，当亮度达到100.0%，表现出的效果就是完全看不到。 从网上找了一张HSL的色轮图如下： 案例将上述代码中background-color分别替换为：”HSL(0,40.0%,50.0%)”、”HSL(0,70.0%,50.0%)”、”HSL(0,100.0%,50.0%)”、”HSL(0,100.0%,70.0%)”、”HSL(0,100.0%,90.0%)”。前三个侧重比较在相同的亮度下，饱和度对颜色表现的影响；后三个侧重比较在相同的饱和度下，亮度对颜色表现的影响。结果如下： HSLA格式background-color: HSLA(H,S,L,A) 说明H：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360S：Saturation(饱和度)。取值为：0.0% - 100.0%L：Lightness(亮度)。取值为：0.0% - 100.0%A：Alpha透明度。取值0~1之间。HSLA与HSL在颜色表现方式上相同，不同就在于多了这个透明度参数，0是完全透明，1是完全不透明。 案例将上述代码中background-color分别替换为：”HSLA(220,100.0%,50.0%,0.1)”、”HSLA(220,100.0%,50.0%,0.3)”、”HSLA(220,100.0%,50.0%,0.5)”、“HSLA(220,100.0%,50.0%,0.7)”、”HSLA(220,100.0%,50.0%,1)”，结果如下：","categories":[{"name":"CSS/CSS3","slug":"CSS-CSS3","permalink":"http://www.gcidea.info/categories/CSS-CSS3/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"CSS/CSS3","slug":"CSS-CSS3","permalink":"http://www.gcidea.info/tags/CSS-CSS3/"}]},{"title":"JavaScript的caller属性和callee属性对比总结","slug":"js-caller-callee","date":"2016-08-09T03:27:46.000Z","updated":"2018-12-12T16:08:37.295Z","comments":true,"path":"2016/08/09/js-caller-callee/","link":"","permalink":"http://www.gcidea.info/2016/08/09/js-caller-callee/","excerpt":"","text":"背景 要说这两个方法，必须先说另一个东西—实参对象（arguments）。标识符arguments是指向实参对象的引用。当传入某个函数的参数个数超过函数定义时指定的形参个数时，默认的处理方法是自动忽略多出来的参数。也就是说，默认这不会引起错误。但是这会有另一个问题：无法获取多出来的参数的引用了（无法知道多出来的参数具体值是什么）。这也正是实参对象arguments可以解决的问题。通过arguments和数字下标，我们就可以获取任意某个传入的参数了。之所以能够通过数字下标，是因为arguments是一个类数组对象，有着以数字为索引的一系列属性（至于什么是类数组对象，在JavaScript的call()、apply()、bind()方法对比总结这篇文章中提到过）。除了这些属性外，正如真正的数组一样，arguments还有一个length属性，用来标识传入参数的总个数。arguments的存在，极大提高了传参的灵活性，可以使得函数扩展性更好，可操作任意数量的参数。在ECMA-262, 3rd官方文档中，对于一个函数被调用后，arguments对象的创建和初始化描述如下： 本文要提到的caller属性和callee属性，正是和arguments对象相关两个属性。理解的时候，可以类比“employer”和“employee”这两个单词，即“雇主”和“雇员”的概念。 caller属性 在ECMAScript5严格模式中，对此属性的读/写操作均会产生类型错误TypeError。 在非严格模式下，caller属性表示调用当前正在执行的函数的函数。如果函数是由顶层来调用，那么caller的值为null。见如下实验过程： 注意：caller是由函数来调用的，即格式为：functionName.caller，而不是arguments.caller，也就是说caller不是arguments的属性。如果写成了arguments.caller，编辑器也会给出如下警告： callee属性 在ECMAScript5严格模式中，对此属性的读/写操作均会产生类型错误TypeError。 在非严格模式下，callee属性表示当前正在执行的函数。如下所示： callee属性常用于递归操作： 这种情况下，可以给callee()传入参数，但是在上述过程中，通过caller或者callee获取“调用正在执行的函数的函数”或者“正在执行的函数”时，是以“属性”体现的，也就是说不能在caller或者callee后面加括号，否则报如下错误： 另外，arguments.length是实参长度，arguments.callee.length是形参长度，由此callee也可以用于判断调用时形参长度是否和实参长度一致。 说明 在ES6中（默认就是严格模式），上述两种属性被禁用。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"leetcode [#92]","slug":"leetcode-92","date":"2016-07-31T15:26:39.000Z","updated":"2018-12-12T16:07:51.148Z","comments":true,"path":"2016/07/31/leetcode-92/","link":"","permalink":"http://www.gcidea.info/2016/07/31/leetcode-92/","excerpt":"","text":"题目 Reverse a linked list from position m to n. Do it in-place and in one-pass. Example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. Example:Given m, n satisfy the following condition:1 ≤ m ≤ n ≤ length of list. 解决方案12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode reverseBetween(ListNode head, int m, int n) &#123; if(head == null) return null; int tempA = -1; ListNode pre = null; ListNode begin = null; ListNode end = null; ListNode before = null; ListNode fakeHead = new ListNode(0); fakeHead.next = head; ListNode p = fakeHead; while(p != null)&#123; tempA++; if(tempA &lt; m-1)&#123; p = p.next; &#125; if((tempA+1) == m) &#123; pre = p; before = p; p = p.next; &#125; if(tempA == m) &#123; begin = p; &#125; if(m &lt;= tempA &amp;&amp; tempA &lt;= n)&#123; ListNode next = p.next; p.next = pre; pre = p; if(tempA == n)&#123; end = p; &#125; p = next; &#125; if(tempA == n)&#123; begin.next = p; if(before != null)&#123; before.next = end; &#125; break; &#125; &#125; return fakeHead.next; &#125;&#125; 注意事项 使用“头指针”，从而去除头结点的特殊性。 难度在于要只一遍遍历且原地完成。 记录要翻转节点的前一个节点、要翻转的第一个节点、要翻转的最后一个节点。 核心代码：123456789if(m &lt;= tempA &amp;&amp; tempA &lt;= n)&#123; ListNode next = p.next; p.next = pre; pre = p; if(tempA == n)&#123; end = p; &#125; p = next;&#125; 是使用了链表翻转的典型做法。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#9]","slug":"leetcode-9","date":"2016-07-30T03:26:39.000Z","updated":"2018-12-12T16:07:51.647Z","comments":true,"path":"2016/07/30/leetcode-9/","link":"","permalink":"http://www.gcidea.info/2016/07/30/leetcode-9/","excerpt":"","text":"题目 Determine whether an integer is a palindrome. Do this without extra space. Some hints:Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. 解决方案12345678910111213public class Solution &#123; public boolean isPalindrome(int x) &#123; if(x &lt; 0 || (x != 0 &amp;&amp; x % 10 == 0)) return false; if(x == 0) return true; int tmp = 0; int x0 = x; while(x &gt; 0)&#123; tmp = tmp * 10 + x % 10; x = x / 10; &#125; return tmp == x0 ? true : false; &#125;&#125; 注意事项 负数不可能是回文的，不为零且为10的倍数的数不可能是回文的。 对于其他情况，使用tmp变量来进行累加，从x的个位开始，进行求和。比较最终x和tmp的大小关系。 不可能完全不用额外空间。题目的意思应该是不开辟线性增长的空间，但使用一个变量tmp应该是可以的。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#88]","slug":"leetcode-88","date":"2016-07-27T16:26:39.000Z","updated":"2018-12-12T16:07:52.167Z","comments":true,"path":"2016/07/28/leetcode-88/","link":"","permalink":"http://www.gcidea.info/2016/07/28/leetcode-88/","excerpt":"","text":"题目 Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 解决方案1234567891011121314151617181920212223242526272829303132public class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int[] result = new int[m + n]; int index = 0; int len1 = nums1.length; int len2 = nums2.length; int p = 0; int q = 0; while(p &lt; m || q &lt; n)&#123; if(p &lt; m &amp;&amp; q &lt; n)&#123; if(nums1[p] &lt;= nums2[q])&#123; result[index++] = nums1[p]; p++; &#125; else &#123; result[index++] = nums2[q]; q++; &#125; &#125; else if(p == m &amp;&amp; q &lt; n)&#123; result[index++] = nums2[q]; q++; &#125; else &#123; result[index++] = nums1[p]; p++; &#125; &#125; for(int s = 0; s &lt; result.length; s++)&#123; nums1[s] = result[s]; &#125; &#125;&#125; 注意事项 默认升序排序。 借鉴归并排序的方法进行排序。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#86]","slug":"leetcode-86","date":"2016-07-27T15:26:39.000Z","updated":"2018-12-12T16:07:53.256Z","comments":true,"path":"2016/07/27/leetcode-86/","link":"","permalink":"http://www.gcidea.info/2016/07/27/leetcode-86/","excerpt":"","text":"题目 Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example:Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5. 解决方案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode partition(ListNode head, int x) &#123; if(head == null) return null; List&lt;ListNode&gt; list1 = new ArrayList&lt;&gt;(); List&lt;ListNode&gt; list2 = new ArrayList&lt;&gt;(); ListNode p = head; while (p != null) &#123; if(p.val &lt; x) &#123; list1.add(p); &#125; else &#123; list2.add(p); &#125; p = p.next; &#125; if(list1.size() == 0 || list2.size() == 0)&#123; return head; &#125; else &#123; ListNode head1 = new ListNode(0); ListNode head2 = new ListNode(0); ListNode end = null; ListNode p1 = head1; ListNode p2 = head2; for(int m = 0; m &lt; list1.size(); m++)&#123; p1.val = list1.get(m).val; if(m == list1.size()-1)&#123; p1.next = null; end = p1; &#125; else &#123; p1.next = new ListNode(0); &#125; p1 = p1.next; &#125; for(int n = 0; n &lt; list2.size(); n++)&#123; p2.val = list2.get(n).val; if(n == list2.size()-1)&#123; p2.next = null; &#125; else &#123; p2.next = new ListNode(0); &#125; p2 = p2.next; &#125; end.next = head2; return head1; &#125; &#125;&#125; 注意事项 遍历一遍，将小于x的放在一个ArrayList中，将大于等于x的放在另一个ArrayList中。之后再分别构造链表，相连起来。 思路相同，但是不必放入List在连起来构造链表，这样效率比较低。下面方法直接用指针完成：12345678910111213141516171819public ListNode partition(ListNode head, int x) &#123; ListNode head1 = new ListNode(0); ListNode head2 = new ListNode(0); ListNode curr1 = head1; ListNode curr2 = head2; while (head != null)&#123; if (head.val &lt; x) &#123; curr1.next = head; curr1 = head; &#125;else &#123; curr2.next = head; curr2 = head; &#125; head = head.next; &#125; curr2.next = null; curr1.next = head2.next; return head1.next;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#82]","slug":"leetcode-82","date":"2016-07-24T15:56:39.000Z","updated":"2018-12-12T16:07:54.425Z","comments":true,"path":"2016/07/24/leetcode-82/","link":"","permalink":"http://www.gcidea.info/2016/07/24/leetcode-82/","excerpt":"","text":"题目 Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Example:Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3. 解决方案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head == null) return null; ListNode p = head; LinkedHashSet&lt;Integer&gt; setDuplicates = new LinkedHashSet&lt;&gt;(); LinkedHashSet&lt;Integer&gt; setAll = new LinkedHashSet&lt;&gt;(); while(p != null &amp;&amp; p.next != null)&#123; if(p.val == p.next.val)&#123; setDuplicates.add(p.val); &#125; p = p.next; &#125; p = head; while(p != null)&#123; setAll.add(p.val); p = p.next; &#125; Iterator&lt;Integer&gt; setDuplicatesIt = setDuplicates.iterator(); while(setDuplicatesIt.hasNext())&#123; setAll.remove(setDuplicatesIt.next()); &#125; if(setAll.size() &gt; 0)&#123; ListNode result = new ListNode(0); ListNode q = result; Iterator&lt;Integer&gt; it = setAll.iterator(); while(it.hasNext())&#123; q.val = it.next(); if(it.hasNext())&#123; q.next = new ListNode(0); q = q.next; &#125; else &#123; q.next = null; &#125; &#125; return result; &#125; else &#123; return null; &#125; &#125;&#125; 注意事项 与83链表去重相比，本题要求“完全去重”，即重复元素不是保留一次，而是完全删除。 这种方法用了LinkedHashSet，其特性是会去掉加入的重复元素，且与HashSet相比，可以保留元素加入的顺序不变，而不会像HashSet对加入的元素进行排序。 这种方法效率较低，与83题考虑指针变化来解题的思路类似，discuss中vote较高的回答做法如下：12345678910111213141516171819public ListNode deleteDuplicates(ListNode head) &#123; if(head==null) return null; ListNode FakeHead=new ListNode(0); FakeHead.next=head; ListNode pre=FakeHead; ListNode cur=head; while(cur!=null)&#123; while(cur.next!=null&amp;&amp;cur.val==cur.next.val)&#123; cur=cur.next; &#125; if(pre.next==cur)&#123; pre=pre.next; &#125; else&#123; pre.next=cur.next; &#125; cur=cur.next; &#125; return FakeHead.next;&#125; 其思路是： 1.定义了“头指针”，也就是指向头结点的“虚拟新增结点”。这样就去除了头结点的特殊性，从而可以应对从链表一开始元素就是重复的这种情况。2.一开始，pre指向头指针结点，cur指向头结点。从cur即头结点开始遍历整个链表。3.如果下一结点不为空且当前节点的值和下一结点的值相等，那么cur指针向后移动一位。4.此时考虑指针pre，如果pre就在cur前面1位，那么pre向后移动一位即可，也就是cur和pre此时指向同一元素。否则，说明cur和pre中间间隔有元素，就正是那些重复的元素，这些都应该被跳过，跳过的方法就是，让pre指向cur后面1位的元素，即pre.next=cur.next;。5.经过上述步骤，处理完所有情况，此时cur向后移动一位，重新开始考虑上面的步骤。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#83]","slug":"leetcode-83","date":"2016-07-24T15:26:39.000Z","updated":"2018-12-12T16:07:53.834Z","comments":true,"path":"2016/07/24/leetcode-83/","link":"","permalink":"http://www.gcidea.info/2016/07/24/leetcode-83/","excerpt":"","text":"题目 Given a sorted linked list, delete all duplicates such that each element appear only once. Example:Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 解决方案123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode p = head; while(p != null &amp;&amp; p.next != null)&#123; if(p.val == p.next.val)&#123; p.next = p.next.next; &#125; else &#123; p = p.next; &#125; &#125; return head; &#125;&#125; 注意事项 链表去重，使用一个p指针指向头结点，开始遍历该链表，如果当前元素和后一个元素值不同，指针后移一位；如果相同，则当前元素指向后一个元素之后的元素，也就是把相同的两个元素的后者删除掉。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#8]","slug":"leetcode-8","date":"2016-07-23T06:26:39.000Z","updated":"2018-12-12T16:07:54.848Z","comments":true,"path":"2016/07/23/leetcode-8/","link":"","permalink":"http://www.gcidea.info/2016/07/23/leetcode-8/","excerpt":"","text":"题目 Implement atoi to convert a string to an integer. HintCarefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. NotesIt is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. 解决方案12345678910111213141516171819202122232425262728293031323334353637383940import java.util.regex.Matcher;import java.util.regex.Pattern;public class Solution &#123; public int myAtoi(String str) &#123; str = str.trim(); if(str.length() == 0) return 0; String regex = \"[0-9]+\"; Pattern p = Pattern.compile(regex); Matcher m = p.matcher(str); if(!m.find()) return 0; int index = str.indexOf(m.group(0)); if(index &gt; 1)&#123; return 0; &#125; else if(index == 1)&#123; if(!(str.charAt(0) == '+' || str.charAt(0) == '-'))&#123; return 0; &#125; else &#123; if(str.charAt(0) == '+')&#123; return convert(m.group(0), '+'); &#125; else &#123; return convert(m.group(0), '-'); &#125; &#125; &#125; else &#123; return convert(m.group(0), '+'); &#125; &#125; private static int convert(String str, char pn)&#123; int length = str.length(); if(length &gt; 10 || (length == 10 &amp;&amp; str.compareTo(\"2147483647\") &gt; 0))&#123; return (pn == '+') ? 2147483647 : -2147483648; &#125; int result = 0; for(int i = 0; i &lt; length; i++)&#123; result += Integer.valueOf(String.valueOf(str.charAt(i))) * Math.pow(10, length - i - 1); &#125; return (pn == '+') ? result : 0-result; &#125;&#125; 注意事项 使用trim方法去掉所有的两段空格。 使用正则表达式匹配第一段连贯的数字。 判断第一段连贯的数字前面是否只有一位，如果超过一位，则肯定不为数字，返回0；如果仅一位，判断是否为“+”或“-”，如果不是，则肯定不为数字，返回0；如果为0位，表示这一段全是数字。 在3的基础上，统一调用字符串转数字的私有函数。同时考虑正负号、同时考虑溢出问题。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#75]","slug":"leetcode-75","date":"2016-07-22T09:26:39.000Z","updated":"2018-12-12T16:07:55.301Z","comments":true,"path":"2016/07/22/leetcode-75/","link":"","permalink":"http://www.gcidea.info/2016/07/22/leetcode-75/","excerpt":"","text":"题目 Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note:You are not suppose to use the library’s sort function for this problem. 解决方案1234567891011121314151617181920212223242526272829303132public class Solution &#123; public void sortColors(int[] nums) &#123; int N = nums.length; sort(nums, 0, N-1); &#125; private void sort(int[] nums, int lo, int hi)&#123; if(hi &lt;= lo) return; int j = partition(nums, lo, hi); sort(nums, lo, j-1); sort(nums, j+1, hi); &#125; private int partition(int[] nums, int lo, int hi)&#123; int i = lo; int j = hi + 1; int v = nums[lo]; while(true)&#123; while (nums[++i] &lt; v) if(i == hi) break; while (nums[--j] &gt; v) if(j == lo) break; if(i &gt;= j) break; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; int exch = nums[lo]; nums[lo] = nums[j]; nums[j] = exch; return j; &#125;&#125; 注意事项 实现快速排序。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#7]","slug":"leetcode-7","date":"2016-07-20T03:56:39.000Z","updated":"2018-12-12T16:07:55.741Z","comments":true,"path":"2016/07/20/leetcode-7/","link":"","permalink":"http://www.gcidea.info/2016/07/20/leetcode-7/","excerpt":"","text":"题目 Reverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 解决方案1234567891011public class Solution &#123; public int reverse(int x) &#123; String s = String.valueOf(x); if(x &lt; 0) s = s.substring(1, s.length()); StringBuilder builder = new StringBuilder(); for(int i = s.length() - 1; i&gt;=0; i--) builder.append(s.charAt(i)); if((x &gt; 0 &amp;&amp; builder.length() == 10 &amp;&amp; builder.toString().compareTo(\"2147483647\") &gt; 0) || (x &lt; 0 &amp;&amp; builder.length() == 10 &amp;&amp; builder.toString().compareTo(\"2147483648\") &gt; 0)) return 0; int res = Integer.valueOf(builder.toString()); return x &gt; 0 ? res : 0 - res; &#125;&#125; 注意事项 转换为字符串考虑，注意正负情况和边界溢出情况。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#67]","slug":"leetcode-67","date":"2016-07-18T12:26:39.000Z","updated":"2018-12-12T16:07:56.135Z","comments":true,"path":"2016/07/18/leetcode-67/","link":"","permalink":"http://www.gcidea.info/2016/07/18/leetcode-67/","excerpt":"","text":"题目 Given two binary strings, return their sum (also a binary string). Examplea = “11”b = “1”Return “100”. 解决方案123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Solution &#123; public String addBinary(String a, String b) &#123; int len1 = a.length(); int len2 = b.length(); int delta = Math.abs(len1 - len2); int max = Math.max(len1, len2); int[] intVal1 = new int[max]; int[] intVal2 = new int[max]; if(len1 &gt;= len2)&#123; for(int i = 0; i &lt; max; i++)&#123; intVal1[i] = Integer.parseInt(String.valueOf(a.charAt(i))); &#125; for(int j = 0; j &lt; max; j++)&#123; if(j &lt; delta)&#123; intVal2[j] = 0; &#125; else &#123; intVal2[j] = Integer.parseInt(String.valueOf(b.charAt(j - delta))); &#125; &#125; &#125; else &#123; for(int i = 0; i &lt; max; i++)&#123; intVal1[i] = Integer.parseInt(String.valueOf(b.charAt(i))); &#125; for(int j = 0; j &lt; max; j++)&#123; if(j &lt; delta)&#123; intVal2[j] = 0; &#125; else &#123; intVal2[j] = Integer.parseInt(String.valueOf(a.charAt(j - delta))); &#125; &#125; &#125; StringBuilder builder = new StringBuilder(\"\"); handle(max, 0, intVal1, intVal2, builder); return builder.reverse().toString(); &#125; private static void handle(int max, int more, int[] val1, int[] val2, StringBuilder builder)&#123; int temp = 0; if(max &gt;= 1)&#123; temp = val1[max - 1] + val2[max - 1] + more; &#125; else &#123; temp = val1[0] + val2[0] + more; &#125; if(max-1 &gt; 0)&#123; if(temp &lt;= 1)&#123; builder.append(Integer.toString(temp)); handle(--max, 0, val1, val2, builder); &#125; else &#123; builder.append(Integer.toString(temp % 2)); handle(--max, 1, val1, val2, builder); &#125; &#125; else &#123; if(temp &lt;= 1)&#123; builder.append(Integer.toString(temp)); &#125; else &#123; builder.append(Integer.toString(temp % 2)); builder.append(\"1\"); &#125; &#125; &#125;&#125; 注意事项 思路基本与leetcode [#415]相同。只不过此处变成了二进制。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#66]","slug":"leetcode-66","date":"2016-07-18T09:26:39.000Z","updated":"2018-12-12T16:07:56.521Z","comments":true,"path":"2016/07/18/leetcode-66/","link":"","permalink":"http://www.gcidea.info/2016/07/18/leetcode-66/","excerpt":"","text":"题目 Given a non-negative number represented as an array of digits, plus one to the number. The digits are stored such that the most significant digit is at the head of the list. 解决方案12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; public static int[] plusOne(int[] digits) &#123; int N = digits.length; int[] result = handle(digits, N - 1); return result; &#125; private static int[] handle(int[] a, int index)&#123; if(a[index] &lt; 9)&#123; a[index]++; return a; &#125; else &#123; a[index] = 0; index--; if(index &lt; 0)&#123; int[] y = new int[2]; y[0] = 1; y[1] = 0; return y; &#125; else if(index == 0)&#123; if(a[index] &lt; 9)&#123; a[index]++; return a; &#125; else &#123; a[index] = 0; int res[] = new int[a.length + 1]; res[0] = 1; for(int r = 1; r &lt; a.length + 1; r++)&#123; res[r] = a[r - 1]; &#125; return res; &#125; &#125; else &#123; int[] t = handle(a, index); return t; &#125; &#125; &#125;&#125; 注意事项 以下方法思路正确，但是会超时，不符合复杂度要求： 1234567891011121314151617181920public static int[] plusOne(int[] digits) &#123; int[] one = &#123;1&#125;; int N = digits.length; if(N == 0) return one; int val = 0; for(int i = 0; i&lt; N; i++)&#123; val += digits[i] * Math.pow(10, (N-i-1)); &#125; val++; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(val != 0)&#123; list.add(val % 10); val = val / 10; &#125; int[] result = new int[list.size()]; for(int p = 0; p &lt; list.size(); p++)&#123; result[p] = list.get(list.size() - 1 - p); &#125; return result;&#125; 解决方案中，使用递归，从数组最高位开始判定，如果小于9，直接加1返回即可；如果为9，则要进位，递归调用本身判断前一位的情况。跳出递归的条件是当前索引值。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#62]","slug":"leetcode-62","date":"2016-07-18T05:26:39.000Z","updated":"2018-12-12T16:07:56.879Z","comments":true,"path":"2016/07/18/leetcode-62/","link":"","permalink":"http://www.gcidea.info/2016/07/18/leetcode-62/","excerpt":"","text":"题目 A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Notem and n will be at most 100. 解决方案1234567891011121314151617181920212223public class Solution &#123; public int uniquePaths(int m, int n) &#123; int[][] map = new int[101][101]; for(int i = 1; i &lt; 101; i++)&#123; for(int j = 1; j &lt; 101; j++)&#123; map[i][j] = 0; if(i == 1 || j == 1)&#123; map[i][j] = 1; &#125; else &#123; int temp = 0; if(map[i][j] == 0)&#123; for(int k = 1; k &lt;= i; k++)&#123; temp += map[k][j-1]; &#125; map[i][j] = temp; map[j][i] = temp; &#125; &#125; &#125; &#125; return map[m][n]; &#125;&#125; 注意事项 找到规律，开辟二维数组，每个位置的值就是m,n为对应下标时不同路线的总数。计算方法是上一行元素从0到i所有元素之和。 这是一道典型的动态规划(DP)题目，上面给出的实质上是暴力递归的方法。而对暴力递归的方法进行优化正是动态规划要做的事情。使用动态规划，就是要考虑当前状态和哪些状态有关，并且只使用这些有意义的状态，避免大量冗余的重复计算。在上面的方法中，我们求每个位置的元素时，是将其上一排从0截止到当前横坐标i位置的所有元素进行相加，这就访问了很多次数组。而要想获得这个值，并不是非得需要这样，因为这个“累加过程”我们其实已经做过了—就是在求解当前位置元素左边元素的时候。但是，稍有不同的是，解当前位置元素左边元素的时候，我们求的是从0截止到横坐标i-1位置的所有元素和，差了一个i，而这个正是要求的当前元素上面的元素。因此，找到了规律：求解每个元素，只需要将该元素左边的和上边的元素相加即可。这就减少了大量无意义的计算。代码如下：123456789101112131415public int uniquePaths(int m, int n) &#123; Integer[][] map = new Integer[m][n]; for(int i = 0; i&lt;m;i++)&#123; map[i][0] = 1; &#125; for(int j= 0;j&lt;n;j++)&#123; map[0][j]=1; &#125; for(int i = 1;i&lt;m;i++)&#123; for(int j = 1;j&lt;n;j++)&#123; map[i][j] = map[i-1][j]+map[i][j-1]; &#125; &#125; return map[m-1][n-1];&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#53]","slug":"leetcode-53","date":"2016-07-17T09:26:39.000Z","updated":"2018-12-12T16:07:57.997Z","comments":true,"path":"2016/07/17/leetcode-53/","link":"","permalink":"http://www.gcidea.info/2016/07/17/leetcode-53/","excerpt":"","text":"题目 Find the contiguous subarray within an array (containing at least one number) which has the largest sum. Examplegiven the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. 解决方案1234567891011public class Solution &#123; public int maxSubArray(int[] nums) &#123; int maxSoFar = nums[0]; int maxEndingHere = nums[0]; for (int i = 1; i &lt; nums.length; i++)&#123; maxEndingHere = Math.max(maxEndingHere + nums[i], nums[i]); maxSoFar = Math.max(maxSoFar, maxEndingHere); &#125; return maxSoFar; &#125;&#125; 注意事项 典型的动态规划问题。 思路：","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#58]","slug":"leetcode-58","date":"2016-07-17T09:26:39.000Z","updated":"2018-12-12T16:07:57.616Z","comments":true,"path":"2016/07/17/leetcode-58/","link":"","permalink":"http://www.gcidea.info/2016/07/17/leetcode-58/","excerpt":"","text":"题目 Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0. ExampleGiven s = “Hello World”,return 5. NoteA word is defined as a character sequence consists of non-space characters only. 解决方案1234567891011public class Solution &#123; public int lengthOfLastWord(String s) &#123; if(s == null || s.length() == 0) return 0; String[] arr = s.split(\" \"); if(arr.length == 0)&#123; return 0; &#125; else &#123; return arr[arr.length - 1].length(); &#125; &#125;&#125; 注意事项 先处理特殊情况。 对字符串按空格切分，得到的数组如果长度为0，说明本来就是一系列空格组成的字符串，返回0；否则，返回数组最后一个元素的长度即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#6]","slug":"leetcode-6","date":"2016-07-17T03:26:39.000Z","updated":"2018-12-12T16:07:57.251Z","comments":true,"path":"2016/07/17/leetcode-6/","link":"","permalink":"http://www.gcidea.info/2016/07/17/leetcode-6/","excerpt":"","text":"题目 The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) 123P A H NA P L S I I GY I R And then read line by line: “PAHNAPLSIIGYIR” Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows); convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”. 解决方案1234567891011121314151617181920212223242526272829public class Solution &#123; public String convert(String s, int numRows) &#123; int len = s.length(); if(len == 0) return \"\"; if(numRows == 1) return s; char[] sArr = s.toCharArray(); StringBuilder[] b = new StringBuilder[numRows]; for(int k = 0; k &lt; numRows; k++)&#123; b[k] = new StringBuilder(); &#125; int piece = 2 * (numRows - 1); for(int i = 0; i &lt; len; i++)&#123; if(i &lt; numRows)&#123; b[i].append(sArr[i]); &#125; else &#123; if (i % piece &gt;= 0 &amp;&amp; i % piece &lt; numRows) &#123; b[i % piece].append(sArr[i]); &#125; else &#123; b[piece - i % piece].append(sArr[i]); &#125; &#125; &#125; StringBuilder resBuilder = new StringBuilder(); for(int m = 0; m &lt; numRows; m++)&#123; resBuilder.append(b[m]); &#125; return resBuilder.toString(); &#125;&#125; 注意事项 按照给定的numRows，将字符串排列成锯齿状，并且按照行返回。 先处理特殊情况。 定义numRows个StringBuilder，重点在于找到每个字符应该加入的StringBuilder。对于下标满足i % piece &gt;= 0 &amp;&amp; i % piece &lt; numRows范围的字符串，即锯齿中“垂直方向”的一段，依次填入b[i % piece]即可；对于下标满足i % piece &gt;= numRows范围的字符串，即锯齿中“倾斜方向”的一段，依次填入b[piece - i % piece]即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#448]","slug":"leetcode-448","date":"2016-07-16T15:26:39.000Z","updated":"2018-12-12T16:07:58.717Z","comments":true,"path":"2016/07/16/leetcode-448/","link":"","permalink":"http://www.gcidea.info/2016/07/16/leetcode-448/","excerpt":"","text":"题目 Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.Find all the elements of [1, n] inclusive that do not appear in this array.Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example:Input:[4,3,2,7,8,2,3,1] Output:[5,6] 解决方案123456789101112131415public class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); int n = nums.length; for(int i = 0; i &lt; n; i++)&#123; nums[(nums[i] - 1) % n] += n; &#125; for(int i = 0; i &lt; n; i++)&#123; if(nums[i] &lt;= n)&#123; list.add(i+1); &#125; &#125; return list; &#125;&#125; 注意事项 实质上要将数组中的每一个元素看做存储的是该数组的下标（每个数需要减1） 遍历一遍，取到每个数组元素的值，将其看做下标的情况下，将该数组对应位置加n 凡是在该数组不存在的元素（指范围1-n）内，对应下标的值就无法被加n（一次或多次加n都不可能） 再遍历一遍，找到现在元素值小于等于n的就是缺失的元素","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#463]","slug":"leetcode-463","date":"2016-07-16T15:26:39.000Z","updated":"2018-12-12T16:07:58.353Z","comments":true,"path":"2016/07/16/leetcode-463/","link":"","permalink":"http://www.gcidea.info/2016/07/16/leetcode-463/","excerpt":"","text":"题目 You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. Example:[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]Answer: 16Explanation: The perimeter is the 16 yellow stripes in the image below: 解决方案12345678910111213141516171819202122public class Solution &#123; public int islandPerimeter(int[][] grid) &#123; int islandNum = 0; int rightOrBottomNum = 0; int m = grid.length; int n = grid[0].length; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(grid[i][j] == 1) &#123; islandNum++; if(i &lt; m-1)&#123; if(grid[i+1][j] == 1) rightOrBottomNum++; &#125; if(j &lt; n-1)&#123; if(grid[i][j+1] == 1) rightOrBottomNum++; &#125; &#125; &#125; &#125; return islandNum * 4 - rightOrBottomNum * 2; &#125;&#125; 注意事项 遍历二维数组，统计陆地块总个数islandNum 统计的同时，如果当前块为陆地，则考察其右边或者下边（也可以左边或者上边）的情况，如果是陆地，则rightOrBottomNum加1 最后，周长的计算，如果各个陆地块是分开的，那么周长为islandNum*4，现在由于有一些合并，且每合并一次，减少两条边，减去 rightOrBottomNum*2即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#415]","slug":"leetcode-447","date":"2016-07-15T15:26:39.000Z","updated":"2018-12-12T16:07:59.089Z","comments":true,"path":"2016/07/15/leetcode-447/","link":"","permalink":"http://www.gcidea.info/2016/07/15/leetcode-447/","excerpt":"","text":"题目 Given n points in the plane that are all pairwise distinct, a “boomerang” is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters). Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive). Example:Input:[[0,0],[1,0],[2,0]] Output:2 Explanation:The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]] 解决方案123456789101112131415161718192021222324public class Solution &#123; public int numberOfBoomerangs(int[][] points) &#123; int count = 0; for (int i = 0; i &lt; points.length; i++) &#123; HashMap&lt;Double, Integer&gt; map = new HashMap&lt;Double, Integer&gt;(); for (int j = 0; j &lt; points.length; j++) &#123; double dis = distance(points[i], points[j]); if (!map.containsKey(dis)) &#123; map.put(dis, 0); &#125; count += map.get(dis) * 2; map.put(dis, map.get(dis) + 1); &#125; &#125; return count; &#125; private static double distance(int[] first, int[] second)&#123; int a1 = first[0]; int b1 = first[1]; int a2 = second[0]; int b2 = second[1]; return Math.pow((a1-a2), 2) + Math.pow((b1-b2), 2); &#125;&#125; 注意事项 本题题意是：在二维直角坐标系中给出一组坐标点，若存在三个点[i,j,k],i和j的距离与i和k的距离相等，则记为“一组”，求所都点中共有多少这样的组。 计算距离单独抽出函数。 两次遍历该二维数组，使用数据结构HashMap，计算两点间距离，如果map中不包含该距离值，将其存入map(作为key)，对应的值为0；如果map中已包含该距离值，则要将对应value更新：加一。表明截止目前，互相距离满足[i,j,k]关系的有value组。 不能使用比如HashSet这样的数据结构，虽然可以存储距离且去重，但是无法记录重复次数，导致求和无法进行。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#438]","slug":"leetcode-438","date":"2016-07-15T15:26:39.000Z","updated":"2018-12-12T16:07:59.462Z","comments":true,"path":"2016/07/15/leetcode-438/","link":"","permalink":"http://www.gcidea.info/2016/07/15/leetcode-438/","excerpt":"","text":"题目 Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s.Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.The order of output does not matter. Example1:Input:s: “cbaebabacd” p: “abc” Output:[0, 6] Explanation:The substring with start index = 0 is “cba”, which is an anagram of “abc”.The substring with start index = 6 is “bac”, which is an anagram of “abc”. Example2:Input:s: “abab” p: “ab” Output:[0, 1, 2] Explanation:The substring with start index = 0 is “ab”, which is an anagram of “ab”.The substring with start index = 1 is “ba”, which is an anagram of “ab”.The substring with start index = 2 is “ab”, which is an anagram of “ab”. 解决方案12345678910111213141516171819202122232425262728public class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); if (p == null || s == null || s.length() &lt; p.length()) return list; int pLen = p.length(); int sLen = s.length(); for(int i = 0 ; i + pLen -1 &lt; sLen; i++)&#123; String cur = s.substring(i, i + pLen); if (helper(cur, p)) list.add(i); &#125; return list; &#125; public static boolean helper(String a, String b) &#123; if (a == null || b == null || a.length() != b.length()) return false; int[] dict = new int[26]; for (int i = 0; i &lt; a.length(); i++) &#123; char ch = a.charAt(i); dict[ch-'a']++; &#125; for (int i = 0; i &lt; b.length(); i++) &#123; char ch = b.charAt(i); dict[ch-'a']--; if (dict[ch-'a'] &lt; 0) return false; &#125; return true; &#125;&#125; 注意事项 遍历s字符串（以pLen为每段长度） 准备数组int[] dict = new int[26];用于统计出现次数：在p中出现对应位加1，在s中出现对应位减1 如果最后数组该位小于零，则说明片段未能对应，不是Anagrams；否则能对应","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#409]","slug":"leetcode-409","date":"2016-07-15T03:26:39.000Z","updated":"2018-12-12T16:08:01.084Z","comments":true,"path":"2016/07/15/leetcode-409/","link":"","permalink":"http://www.gcidea.info/2016/07/15/leetcode-409/","excerpt":"","text":"题目 Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.This is case sensitive, for example “Aa” is not considered a palindrome here. Example1:Input:“abccccdd” Output:7 Explanation:One longest palindrome that can be built is “dccaccd”, whose length is 7. 解决方案123456789101112131415161718192021222324252627282930public class Solution &#123; public int longestPalindrome(String s) &#123; if(s.length() == 0) return 0; int res = 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++)&#123; if(!map.containsKey(s.charAt(i)))&#123; map.put(s.charAt(i), 1); &#125; else &#123; map.put(s.charAt(i), map.get(s.charAt(i)) + 1); &#125; &#125; Iterator it = map.entrySet().iterator(); boolean oddFlag = false; while (it.hasNext()) &#123; Map.Entry entry = (Map.Entry) it.next(); if((Integer)entry.getValue() % 2 == 1) &#123; if(!oddFlag) &#123; res += (Integer)entry.getValue(); oddFlag = true; &#125; else &#123; res += ((Integer)entry.getValue() - 1); &#125; &#125; else &#123; res += (Integer)entry.getValue(); &#125; &#125; return res; &#125;&#125; 注意事项 遍历字符串，使用hashmap存储，key为字符，value为出现次数。 遍历hashmap进行统计。设置针对奇数个数的字符的标记位，如果当前还未出现过奇数个数的字符，则直接将该个数添加到结果，表明这奇数个字符都可以参与构成回文。否则，表明已经有奇数参与，则当前字符只能取出最大的偶数个（即减1）；对于个数为偶数的字符，直接添加到结果。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#414]","slug":"leetcode-414","date":"2016-07-15T02:26:39.000Z","updated":"2018-12-12T16:08:00.699Z","comments":true,"path":"2016/07/15/leetcode-414/","link":"","permalink":"http://www.gcidea.info/2016/07/15/leetcode-414/","excerpt":"","text":"题目 Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). Example1:Input: [3, 2, 1] Output: 1 Explanation: The third maximum is 1. Example2:Input: [1, 2] Output: 2 Explanation: The third maximum does not exist, so the maximum (2) is returned instead. Example3:Input: [2, 2, 3, 1] Output: 1 Explanation: Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum. 解决方案123456789101112131415public class Solution &#123; public int thirdMax(int[] nums) &#123; int N = nums.length; Set&lt;Integer&gt; set = new TreeSet&lt;&gt;(); for(int i = 0; i &lt; N; i++)&#123; set.add(nums[i]); &#125; List&lt;Integer&gt; list = new LinkedList&lt;&gt;(set); if(list.size() &lt; 3)&#123; return list.get(list.size() - 1); &#125; else &#123; return list.get(list.size() - 3); &#125; &#125;&#125; 注意事项 使用TreeSet，结果有序且可以去重。之后取出相应元素即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#415]","slug":"leetcode-415","date":"2016-07-14T16:26:39.000Z","updated":"2018-12-12T16:07:59.870Z","comments":true,"path":"2016/07/15/leetcode-415/","link":"","permalink":"http://www.gcidea.info/2016/07/15/leetcode-415/","excerpt":"","text":"题目 Given two non-negative numbers num1 and num2 represented as string, return the sum of num1 and num2. Note: The length of both num1 and num2 is &lt; 5100. Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero. You must not use any built-in BigInteger library or convert the inputs to integer directly. 解决方案12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Solution &#123; public String addStrings(String num1, String num2) &#123; int len1 = num1.length(); int len2 = num2.length(); int delta = Math.abs(len1 - len2); int max = Math.max(len1, len2); int[] intVal1 = new int[max]; int[] intVal2 = new int[max]; if(len1 &gt;= len2)&#123; for(int i = 0; i &lt; max; i++)&#123; intVal1[i] = Integer.parseInt(String.valueOf(num1.charAt(i))); &#125; for(int j = 0; j &lt; max; j++)&#123; if(j &lt; delta)&#123; intVal2[j] = 0; &#125; else &#123; intVal2[j] = Integer.parseInt(String.valueOf(num2.charAt(j - delta))); &#125; &#125; &#125; else &#123; for(int i = 0; i &lt; max; i++)&#123; intVal1[i] = Integer.parseInt(String.valueOf(num2.charAt(i))); &#125; for(int j = 0; j &lt; max; j++)&#123; if(j &lt; delta)&#123; intVal2[j] = 0; &#125; else &#123; intVal2[j] = Integer.parseInt(String.valueOf(num1.charAt(j - delta))); &#125; &#125; &#125; StringBuilder builder = new StringBuilder(\"\"); handle(max, 0, intVal1, intVal2, builder); return builder.reverse().toString(); &#125; private static void handle(int max, int more, int[] val1, int[] val2, StringBuilder builder)&#123; int temp = 0; if(max &gt;= 1)&#123; temp = val1[max - 1] + val2[max - 1] + more; &#125; else &#123; temp = val1[0] + val2[0] + more; &#125; if(max-1 &gt; 0)&#123; if(temp &lt;= 9)&#123; builder.append(Integer.toString(temp)); handle(--max, 0, val1, val2, builder); &#125; else &#123; builder.append(Integer.toString(temp % 10)); handle(--max, 1, val1, val2, builder); &#125; &#125; else &#123; if(temp &lt;= 9)&#123; builder.append(Integer.toString(temp)); &#125; else &#123; builder.append(Integer.toString(temp % 10)); builder.append(\"1\"); &#125; &#125; &#125;&#125; 注意事项 不能考虑任何直接转向整型进行求和的方法。字符串最多达到5099位，这不是常规数据类型能够表示的，同时又不能使用大整数的库。那么，就要将问题化简为最简的情况进行处理—考虑两个1位数求和的情况，结合进位情况，递归考虑下去。 为了简便，在进行递归处理前，先做了一系列处理： a. 无论两个字符串各自多长，统一处理成较长长度的数组。b. 遍历每个位置的字符，直接构建整型数组而不是字符串数组。c. 始终保证intVal1[]存储的是本来较长的字符串转换的数组；而intVal2[]存储的是经过高位补零构成的数组。 经过以上处理，开始递归。注意进位状况，跳出递归的条件是遍历到达了数组的最低位（亦即“数字”的最高位）。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#400]","slug":"leetcode-400","date":"2016-07-13T03:26:39.000Z","updated":"2018-12-12T16:08:01.456Z","comments":true,"path":"2016/07/13/leetcode-400/","link":"","permalink":"http://www.gcidea.info/2016/07/13/leetcode-400/","excerpt":"","text":"题目 Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, … Example1:Input:3 Output:3 Example2:Input:11 Output:0 Explanation:The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, … is a 0, which is part of the number 10. Note:n is positive and will fit within the range of a 32-bit signed integer (n &lt; 231). 解决方案123456789101112131415161718192021222324252627282930313233public class Solution &#123; public int findNthDigit(int n) &#123; int k = 0; int temp = n; while(temp &gt; 9 * Math.pow(10, k) * (k + 1))&#123; temp = temp - 9 * (int)Math.pow(10, k) * (k + 1); k++; &#125; int result = 0; int division = temp / (k+1); if(n &lt;= 9)&#123; result = n; &#125; else &#123; int mode = temp % (k+1); if(mode != 0)&#123; int curr = (int)Math.pow(10, k) + division; int p = curr; int[] digitArr = new int[k+1]; int m = k; while(p &gt; 0)&#123; digitArr[m] = p % 10; p = p / 10; m--; &#125; result = digitArr[mode - 1]; &#125; else &#123; int curr = (int)Math.pow(10, k) + division - 1; result = curr % 10; &#125; &#125; return result; &#125;&#125; 注意事项 是一道数学规律题目。给出从1开始递增1的无限整数序列。要求返回第n位的数字。这个数字可能是整数序列中某个数的某一位。 主要规律如下：从1开始的整数： 位数为1的： 1 ~9 ， 共9 个；位数为2的： 10 ~99， 共99个；位数为3的： 100 ~999 ，共999个；位数为4的： 1000~9999，共9999个；… … 根据如上规律对所有数字进行分组，也就是位数相同的整数在一组。给定一个数，先通过while循环判断在哪个组里。之后在这个组中，判断它属于哪个数字。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#396]","slug":"leetcode-396","date":"2016-07-12T09:26:39.000Z","updated":"2018-12-12T16:08:01.845Z","comments":true,"path":"2016/07/12/leetcode-396/","link":"","permalink":"http://www.gcidea.info/2016/07/12/leetcode-396/","excerpt":"","text":"题目 Given an array of integers A and let n to be its length. Assume Bk to be an array obtained by rotating the array A k positions clock-wise, we define a “rotation function” F on A as follow: F(k) = 0 * Bk[0] + 1 * Bk[1] + … + (n-1) * Bk[n-1]. Calculate the maximum value of F(0), F(1), …, F(n-1). Example:A = [4, 3, 2, 6] F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26 So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26. Note: n is guaranteed to be less than 10^5. 解决方案12345678910111213141516171819202122public class Solution &#123; public int maxRotateFunction(int[] A) &#123; int N = A.length; if(A == null || N == 0) return 0; int sum = 0; int f0 = 0; for(int t = 0; t &lt; N; t++)&#123; sum += A[t]; f0 += t * A[t]; &#125; int max = f0; for(int p = 1; p &lt; N; p++)&#123; f0 = f0 - sum + N * A[p-1]; max = f0 &gt; max ? f0 : max; &#125; return max; &#125;&#125; 注意事项1.使用如下方法会超时：1234567891011121314151617public static int maxRotateFunction(int[] A) &#123; if(A == null || A.length == 0) return 0; int N = A.length; int[] F = new int[N]; for(int k = 0; k &lt; N; k++)&#123; F[k] = 0; for(int j = 0; j &lt; N; j++)&#123; int index = ((N-k) % N + j) &lt; N ? ((N-k) % N + j) : (((N-k) % N + j) % N); F[k] = F[k] + j * A[index]; &#125; &#125; Arrays.sort(F); return F[N-1];&#125; 该方法只是严格按照运算规则逐一进行了运算，但没有找到实际规律，导致大量无用的计算。 2.应该采用的做法中，找到了F函数相邻两项的规律，即：后一项F(i)是在前一项F(i-1)的基础上，减去输入数组之和sum，再加上数组长度N乘以A[i-1]。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#394]","slug":"leetcode-394","date":"2016-07-11T09:26:39.000Z","updated":"2018-12-12T16:08:02.276Z","comments":true,"path":"2016/07/11/leetcode-394/","link":"","permalink":"http://www.gcidea.info/2016/07/11/leetcode-394/","excerpt":"","text":"题目 Given an encoded string, return it’s decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4]. Example:s = “3[a]2[bc]”, return “aaabcbc”.s = “3[a2[c]]”, return “accaccacc”.s = “2[abc]3[cd]ef”, return “abcabccdcdcdef”. 解决方案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Solution &#123; public String decodeString(String s) &#123; if(s.length() == 0 || s.indexOf(\"[\") == -1) return s; Stack&lt;Integer&gt; kStack = new Stack&lt;&gt;(); Stack&lt;String&gt; strStack = new Stack&lt;&gt;(); String lastSec = s.substring(s.lastIndexOf(']') + 1); String firstSec = \"\"; String lastBracket = \"\"; int lastCharIndex = -1; Boolean firstNotLetter = false; int firstNotLetterIndex = -1; StringBuilder res = new StringBuilder(); for(int i = 0; i &lt; s.length(); i++)&#123; if(s.charAt(i) &gt;= 'a' &amp;&amp; s.charAt(i) &lt;= 'z')&#123; lastCharIndex = i; &#125; else if(s.charAt(i) == '[')&#123; String tmpNum = s.substring(lastCharIndex + 1, i); kStack.push(Integer.valueOf(tmpNum)); int m = i + 1; while(s.charAt(m) &gt;= 'a' &amp;&amp; s.charAt(m) &lt;= 'z') m++; String tmpStr = s.substring(i + 1, m); strStack.push(tmpStr); lastCharIndex = i; lastBracket = \"[\"; &#125; else if(s.charAt(i) == ']')&#123; StringBuilder x = new StringBuilder(); String topStr = strStack.pop(); Integer topNum = kStack.pop(); if(lastBracket.equals(\"[\"))&#123; for(int k = 0; k &lt; topNum; k++) x.append(topStr); res = res.append(x); &#125; else &#123; StringBuilder tmp = new StringBuilder(); tmp.append(topStr); tmp.append(res); for(int k = 0; k &lt; topNum; k++) x.append(tmp); res = x; &#125; int m = i+1; while (m &lt; s.length() &amp;&amp; s.charAt(m) &gt;= 'a' &amp;&amp; s.charAt(m) &lt;= 'z')&#123; res = res.append(s.charAt(m)); m++; &#125; if(m == s.length()) lastSec = \"\"; lastCharIndex = i; lastBracket = \"]\"; &#125; else &#123; if(firstNotLetter == false)&#123; firstNotLetterIndex = i; firstNotLetter = true; &#125; &#125; &#125; firstSec = s.substring(0, firstNotLetterIndex); return firstSec + res.toString() + lastSec; &#125;&#125; 注意事项 先考虑特殊情况，对于长度为零的或者没有方括号的输入字符串，直接返回。 需要两个栈，一个保存倍数K，一个保存字符串片段。 firstSec表示第一个字符串片段（不包含数字，方括号），这部分作为结果的开头部分直接返回。firstNotLetter标志位就是用于找到第一个不为数字的地方，从而firstNotLetterIndex就是其对应的下标，截取后可得到firstSec。 lastBracket表示上一个方括号是左括号还是右括号，用于判断是嵌套方括号还是并列方括号。 lastCharIndex表示最近遇到的字母的下标，用于做字符串截取从而获得K值（具体意义见遍历过程） 遍历字符串：6.1 如果遇到字母，更新lastCharIndex即可；6.2 如果遇到左方括号： 6.2.1 截取左方括号左边的紧邻的数字字符串片段，压入kStack，作为K值； 6.2.2 截取左方括号右边的紧邻的字母字符串片段，压入strStack，作为str值； 6.2.3 更新lastCharIndex，指向当前下标； 6.2.4 更新lastBracket，为”[“。6.3 如果遇到右方括号： 6.3.1 strStack弹出一个元素topStr，kStack弹出一个元素topNum 6.3.2 根据lastBracket的情况，决定是否拼接上当前结果res再进行倍增（即考虑是否有括号嵌套的问题） 6.3.2.1 如果lastBracket是”[“，说明当前右方括号内部不是嵌套的，因此直接将topStr倍乘topNum次即可； 6.3.2.2 如果lastBracket是”]”，说明当前右方括号内部有嵌套的，因此需要将topStr和当前res结合在一起进行倍乘 6.3.3 处理完倍乘后，考虑右方括号右面可能存在的字母（无数字k，即单倍的），这些显然也有拼接进res中； 6.3.4 更新lastBracket，为”]”。6.4 对于遇到的第一个数字字符，要根据其下标决定firstSec的内容。6.5 最后，将firstSec和res拼接在一起返回，即为最后的结果。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#383]","slug":"leetcode-383","date":"2016-07-10T10:26:39.000Z","updated":"2018-12-12T16:08:03.066Z","comments":true,"path":"2016/07/10/leetcode-383/","link":"","permalink":"http://www.gcidea.info/2016/07/10/leetcode-383/","excerpt":"","text":"题目 Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. Example:canConstruct(“a”, “b”) -&gt; falsecanConstruct(“aa”, “ab”) -&gt; falsecanConstruct(“aa”, “aab”) -&gt; true Note:You may assume that both strings contain only lowercase letters. 解决方案12345678910111213141516171819public class Solution &#123; public boolean canConstruct(String ransomNote, String magazine) &#123; int len1 = ransomNote.length(); int len2 = magazine.length(); if(len1 &gt; len2) return false; boolean result = true; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(int k = 0; k &lt; len2; k++)&#123; list.add(String.valueOf(magazine.charAt(k))); &#125; for(int i = 0; i &lt; len1; i++)&#123; if(!list.remove(String.valueOf(ransomNote.charAt(i))))&#123; result = false; break; &#125; &#125; return result; &#125;&#125; 注意事项 先判断特殊情况，如果magazine的长度比ransomNote小，那么一定不能组成结果。 将magazine的每个字符存入list备用。 遍历ransomNote，将每个字符从list中弹出，如果成功，证明list中有这个字符，也就是能作为构成ransomNote的一个字符，如果弹出失败，说明没有这个字符，返回false即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#389]","slug":"leetcode-389","date":"2016-07-10T06:26:39.000Z","updated":"2018-12-12T16:08:02.670Z","comments":true,"path":"2016/07/10/leetcode-389/","link":"","permalink":"http://www.gcidea.info/2016/07/10/leetcode-389/","excerpt":"","text":"题目 Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. Example:Input:s = “abcd”t = “abcde” Output:e Explanation:‘e’ is the letter that was added. 解决方案12345678910public class Solution &#123; public char findTheDifference(String s, String t) &#123; if ((s.length() == 0)) return t.charAt(0); char result = 'a'; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; t.length(); i++) list.add(t.charAt(i)); for(int j = 0; j &lt; s.length(); j++) list.remove((Character) s.charAt(j)); return list.get(0); &#125;&#125; 注意事项 将t的每个字符加入arraylist。 遍历s，将s的每个字符从list中取出，剩下的就是新增的。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#374]","slug":"leetcode-374","date":"2016-07-09T09:26:49.000Z","updated":"2018-12-12T16:08:03.825Z","comments":true,"path":"2016/07/09/leetcode-374/","link":"","permalink":"http://www.gcidea.info/2016/07/09/leetcode-374/","excerpt":"","text":"题目 We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I’ll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): -1 : My number is lower 1 : My number is higher 0 : Congrats! You got it! Example:n = 10, I pick 6. Return 6. 解决方案123456789101112131415161718192021/* The guess API is defined in the parent class GuessGame. @param num, your guess @return -1 if my number is lower, 1 if my number is higher, otherwise return 0 int guess(int num); */public class Solution extends GuessGame &#123; public int guessNumber(int n) &#123; int i = 1, j = n; while(i &lt; j) &#123; int mid = i + (j - i) / 2; if(guess(mid) == 0) &#123; return mid; &#125; else if(guess(mid) == 1) &#123; i = mid + 1; &#125; else &#123; j = mid - 1; &#125; &#125; return i; &#125;&#125; 注意事项 要清楚理解题意。待实现方法guessNumber()需要一个参数：即1~n的n，但是整个功能需要传入两个参数：数据范围、出题人选择的数字。其中，n传递给guessNumber()，而选择的数字pick则在solution类实例化时通过在其构造函数中调用父类构造函数来传入。因此，在本地测试时要加上guess()方法的实现，整体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package task374;/** * Created by gaochang on 2016/11/24. */public class solution extends GuessGame&#123; public solution(int pick)&#123; super(pick); &#125; public int guessNumber(int n) &#123; int i = 1, j = n; while(i &lt; j) &#123; int mid = i + (j - i) / 2; if(guess(mid) == 0) &#123; return mid; &#125; else if(guess(mid) == 1) &#123; i = mid + 1; &#125; else &#123; j = mid - 1; &#125; &#125; return i; &#125; public static void main(String[] args)&#123; int pick = 6; int n = 10; solution s = new solution(pick); int re = s.guessNumber(n); System.out.println(re); &#125;&#125;class GuessGame &#123; private int res; public GuessGame(int val)&#123; this.res = val; &#125; public int guess(int num) &#123; if(res &gt; num) &#123; return 1; &#125; else if(res == num)&#123; return 0; &#125; else &#123; return -1; &#125; &#125;&#125; 在1~n的范围内，对pick进行二分查找即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#36]","slug":"leetcode-36","date":"2016-07-09T03:26:39.000Z","updated":"2018-12-12T16:08:04.225Z","comments":true,"path":"2016/07/09/leetcode-36/","link":"","permalink":"http://www.gcidea.info/2016/07/09/leetcode-36/","excerpt":"","text":"题目 解决方案12 注意事项 以下方法是错误的：12345678910111213141516171819202122import java.util.HashSet;public class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; for(int i = 0; i &lt; 9; i++)&#123; HashSet&lt;Character&gt; set = new HashSet&lt;&gt;(); for(int j = 0; j &lt; 9; j++) if(!set.add(board[i][j]) &amp;&amp; board[i][j] != &apos;.&apos;) return false; &#125; for(int i = 0; i &lt; 9; i += 3)&#123; HashSet&lt;Character&gt; set = new HashSet&lt;&gt;(); for(int j = i; j &lt; i+3; j++)&#123; for(int k = 0; k &lt; 3; k++) if(!set.add(board[j][k]) &amp;&amp; board[j][k] != &apos;.&apos;) return false; &#125; &#125; for(int i = 0; i &lt; 3; i++)&#123; HashSet&lt;Character&gt; set = new HashSet&lt;&gt;(); for(int j = i; j &lt; 9; j += 3)&#123; for(int k = 0; k &lt; 9; k += 3) if(!set.add(board[j][k]) &amp;&amp; board[j][k] != &apos;.&apos;) return false; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#38]","slug":"leetcode-38","date":"2016-07-09T02:26:39.000Z","updated":"2018-12-12T16:08:03.436Z","comments":true,"path":"2016/07/09/leetcode-38/","link":"","permalink":"http://www.gcidea.info/2016/07/09/leetcode-38/","excerpt":"","text":"题目 The count-and-say sequence is the sequence of integers beginning as follows:1, 11, 21, 1211, 111221, … 1 is read off as “one 1” or 11.11 is read off as “two 1s” or 21.21 is read off as “one 2, then one 1” or 1211.Given an integer n, generate the nth sequence. Note:The sequence of integers will be represented as a string. 解决方案123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126public class Solution &#123; public String countAndSay(int n) &#123; int flag = 0; String str = \"1\"; StringBuilder temp = new StringBuilder(); temp.append(\"1\"); while (flag &lt; n-1)&#123; int i = 0; StringBuilder builder = new StringBuilder(); while (i &lt; temp.length())&#123; if(temp.charAt(i) == '1')&#123; if(i == temp.length() - 1)&#123; builder.append(\"11\"); i += 1; continue; &#125; else if(i == temp.length() - 2)&#123; if(temp.charAt(i+1) == '1')&#123; builder.append(\"21\"); &#125; else if(temp.charAt(i+1) == '2')&#123; builder.append(\"1112\"); &#125; else &#123; builder.append(\"1113\"); &#125; i += 2; continue; &#125; else &#123; if(temp.charAt(i+1) == '1')&#123; if(temp.charAt(i+2) == '1')&#123; builder.append(\"31\"); i += 3; continue; &#125; else &#123; builder.append(\"21\"); i += 2; continue; &#125; &#125; else if(temp.charAt(i+1) == '2')&#123; if(temp.charAt(i+2) == '2')&#123; builder.append(\"11\"); i += 1; &#125; else &#123; builder.append(\"1112\"); i += 2; &#125; continue; &#125; else &#123; if(temp.charAt(i+2) == '3')&#123; builder.append(\"11\"); i += 1; &#125; else &#123; builder.append(\"1113\"); i += 2; &#125; continue; &#125; &#125; &#125; else if(temp.charAt(i) == '2')&#123; if(i == temp.length() - 1)&#123; builder.append(\"12\"); i += 1; continue; &#125; else if(i == temp.length() - 2)&#123; if(temp.charAt(i+1) == '2')&#123; builder.append(\"22\"); i += 2; continue; &#125; else &#123; builder.append(\"12\"); i += 1; continue; &#125; &#125; else &#123; if(temp.charAt(i+1) == '2')&#123; if(temp.charAt(i+2) == '2')&#123; builder.append(\"32\"); i += 3; continue; &#125; else &#123; builder.append(\"22\"); i += 2; continue; &#125; &#125; else &#123; builder.append(\"12\"); i += 1; continue; &#125; &#125; &#125; else &#123; if(i == temp.length() - 1)&#123; builder.append(\"13\"); i += 1; continue; &#125; else if(i == temp.length() - 2)&#123; if(temp.charAt(i+1) == '3')&#123; builder.append(\"23\"); i += 2; &#125; else &#123; builder.append(\"13\"); i += 1; &#125; continue; &#125; else &#123; if(temp.charAt(i+1) == '3')&#123; if(temp.charAt(i+2) == '3')&#123; builder.append(\"33\"); i += 3; &#125; else &#123; builder.append(\"23\"); i += 2; &#125; continue; &#125; else &#123; builder.append(\"13\"); i += 1; continue; &#125; &#125; &#125; &#125; temp = builder; flag++; &#125; return temp.toString(); &#125;&#125; 注意事项 本题重在找到数字序列的变化规律。第n代的结果一定是偶数个元素，因为每个数字都会被表示成“几个几”的形式。结果序列是由一系列1,2,3构成的。 状态转移图如下： &nbsp;&nbsp;1 -&gt; 11&nbsp;&nbsp;2 -&gt; 12&nbsp;&nbsp;3 -&gt; 13&nbsp;11 -&gt; 21&nbsp;12 -&gt; 1112&nbsp;13 -&gt; 1113&nbsp;22 -&gt; 22&nbsp;33 -&gt; 23111 -&gt; 31222 -&gt; 32333 -&gt; 33 根据上述状态转移图，遍历每次生成的字符串（此处是StringBuilder），决定下一次输出的是什么。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#350]","slug":"leetcode-350","date":"2016-07-08T09:26:39.000Z","updated":"2018-12-12T16:08:04.605Z","comments":true,"path":"2016/07/08/leetcode-350/","link":"","permalink":"http://www.gcidea.info/2016/07/08/leetcode-350/","excerpt":"","text":"题目 Given two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. 解决方案1234567891011121314151617181920212223242526public class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; Arrays.sort(nums1); Arrays.sort(nums2); List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); int a = nums1.length; int b = nums2.length; int i=0,j=0; while(i&lt;a &amp;&amp; j&lt;b)&#123; if(nums1[i] == nums2[j])&#123; list.add(nums1[i]); i++; j++; &#125; else if(nums1[i] &lt; nums2[j])&#123; i++; &#125; else &#123; j++; &#125; &#125; int[] sect = new int[list.size()]; for(int k = 0;k &lt; list.size(); k++)&#123; sect[k] = list.get(k); &#125; return sect; &#125;&#125; 注意事项 使用Java的ArrayList，可能存储重复的对象。可通过get()方法获取元素。 将两个数组排序后，通过一遍对两个数组的比较，就可以获取所有相同的元素。这种方法的复杂度是由Arrays.sort()方法决定的，该方法的实现采用三向快速排序或者归并排序，保证了复杂度在o(nlogn)，相比于通过两层for循环嵌套进行暴力筛选要好很多。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#35]","slug":"leetcode-35","date":"2016-07-08T03:26:39.000Z","updated":"2018-12-12T16:08:05.003Z","comments":true,"path":"2016/07/08/leetcode-35/","link":"","permalink":"http://www.gcidea.info/2016/07/08/leetcode-35/","excerpt":"","text":"题目 Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example:[1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0 解决方案12345678910111213141516171819202122232425262728public class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int N = nums.length; int result = 0; if(N == 0) return result; for(int i = 0; i &lt; N; i++)&#123; if(nums[i] == target)&#123; result = i; break; &#125; else if(nums[i] &gt; target) &#123; if(i == 0)&#123; result = 0; break; &#125; else &#123; result = i; break; &#125; &#125; else &#123; if(i == N - 1)&#123; result = N; break; &#125; &#125; &#125; return result; &#125;&#125; 注意事项 遍历数组，如果找到，返回下标；否则，一律在当前元素大于target的情况下确定插入位置，如果当前元素小于target则继续向后判断，但要注意是否到了末尾。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#349]","slug":"leetcode-349","date":"2016-07-08T02:26:39.000Z","updated":"2018-12-12T16:08:05.395Z","comments":true,"path":"2016/07/08/leetcode-349/","link":"","permalink":"http://www.gcidea.info/2016/07/08/leetcode-349/","excerpt":"","text":"题目 Given two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2]. Note: Each element in the result must be unique. The result can be in any order. 解决方案123456789101112131415161718192021222324252627public class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; Arrays.sort(nums1); Arrays.sort(nums2); HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); int a = nums1.length; int b = nums2.length; int i=0,j=0; while(i&lt;a &amp;&amp; j&lt;b)&#123; if(nums1[i] == nums2[j])&#123; set.add(nums1[i]); i++; j++; &#125; else if(nums1[i] &lt; nums2[j])&#123; i++; &#125; else &#123; j++; &#125; &#125; int[] sect = new int[set.size()]; Iterator ir = set.iterator(); for(int k = 0; ir.hasNext(); k++)&#123; sect[k] = (int) ir.next(); &#125; return sect; &#125;&#125; 注意事项 使用Java的HashSet，HashSet是通过HashMap实现的，是存在于java.util包中的类。该容器中只能存储不重复的对象。不能通过get()方法获取元素，可通过实现Iterable接口迭代获取所有元素。 将两个数组排序后，通过一遍对两个数组的比较，就可以获取所有相同的元素（并且重复的只存储了一次）。这种方法的复杂度是由Arrays.sort()方法决定的，该方法的实现采用三向快速排序或者归并排序，保证了复杂度在o(nlogn)，相比于通过两层for循环嵌套进行暴力筛选要好很多。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#344]","slug":"leetcode-345","date":"2016-07-07T09:26:39.000Z","updated":"2018-12-12T16:08:05.774Z","comments":true,"path":"2016/07/07/leetcode-345/","link":"","permalink":"http://www.gcidea.info/2016/07/07/leetcode-345/","excerpt":"","text":"题目 Write a function that takes a string as input and reverse only the vowels of a string. Example:Given s = “hello”, return “holle”.Given s = “leetcode”, return “leotcede”. Note:The vowels does not include the letter “y”. 解决方案12345678910111213141516171819202122232425262728293031public class Solution &#123; public String reverseVowels(String s) &#123; int N = s.length(); if(s == null || N == 0) return \"\"; StringBuilder builderVowel = new StringBuilder(); for(int i = 0; i &lt; N; i++)&#123; if(isVowel(s.charAt(i)))&#123; builderVowel.append(s.charAt(i)); &#125; &#125; int k = builderVowel.length()-1; StringBuilder builder = new StringBuilder(); for(int i = 0; i &lt; N; i++)&#123; if(!isVowel(s.charAt(i)))&#123; builder.append(s.charAt(i)); &#125; else &#123; builder.append(builderVowel.charAt(k)); k--; &#125; &#125; return builder.toString(); &#125; private static boolean isVowel(char input)&#123; if('a' == input || 'e' == input || 'i' == input || 'o' == input || 'u' == input || 'A' == input || 'E' == input || 'I' == input || 'O' == input || 'U' == input)&#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; 注意事项 元音字母为a,e,i,o,u，同时要考虑到大写。 第一次遍历找到所有元音字母并按顺序保存到一个builderVowel中。第二次遍历，如果当前为不是原因，直接添加到结果builder中，如果当前位是元音字母，则从builderVowel尾部取出一个字符添加到builder中。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#344]","slug":"leetcode-344","date":"2016-07-06T09:26:39.000Z","updated":"2018-12-12T16:08:06.176Z","comments":true,"path":"2016/07/06/leetcode-344/","link":"","permalink":"http://www.gcidea.info/2016/07/06/leetcode-344/","excerpt":"","text":"题目 Write a function that takes a string as input and returns the string reversed. Example:Given s = “hello”, return “olleh”. 解决方案1234567public class Solution &#123; public String reverseString(String s) &#123; StringBuilder handler = new StringBuilder(s); handler.reverse(); return handler.toString(); &#125;&#125; 注意事项以下这种写法可以得到正确答案，但是会超时，无法通过。原因是String一旦创建就不可修改，因此遍历中每次为result衔接新增的部分都会创建新对象并将引用指向result，增大了开销。123456789101112public class Solution &#123; Stack stack = new Stack(); int length = s.length(); for(int i = 0; i &lt; length; i++)&#123; stack.push(s.charAt(i)); &#125; String result = \"\"; while(!stack.empty())&#123; result += stack.pop(); &#125; return result;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#299]","slug":"leetcode-299","date":"2016-07-05T14:13:34.000Z","updated":"2018-12-12T16:08:07.322Z","comments":true,"path":"2016/07/05/leetcode-299/","link":"","permalink":"http://www.gcidea.info/2016/07/05/leetcode-299/","excerpt":"","text":"题目 You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number. Example:Secret number: “1807”Friend’s guess: “7810”Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return “1A3B”. Note:Please note that both secret number and friend’s guess may contain duplicate digits, for example: Secret number: “1123”Friend’s guess: “0111”In this case, the 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return “1A1B”.You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal. 解决方案12345678910111213141516import java.util.Hashtable;public class Solution &#123; public String getHint(String secret, String guess) &#123; int bulls = 0; int cows = 0; int[] numbers = new int[10]; for (int i = 0; i&lt;secret.length(); i++) &#123; if (secret.charAt(i) == guess.charAt(i)) bulls++; else &#123; if (numbers[secret.charAt(i)-'0']++ &lt; 0) cows++; if (numbers[guess.charAt(i)-'0']-- &gt; 0) cows++; &#125; &#125; return bulls + \"A\" + cows + \"B\"; &#125;&#125; 注意事项 如果对应位字符相同，则bull加一。 如果不同，使用一个长度为10的数组（0-9是10个数字）来分析secret和guess中数字字符的情况。数组各元素初始化为0。secret和guess的当前位不同，在数组numbers中，以secret所代表数字为下标的元素如果小于零，那么说明有一个cow出现，cows++，判断完成后，给numbers数组当前位加一；以guess所代表数字为下标的元素如果大于零，那么说明有一个cow出现，cows++，判断完成后，给numbers数组当前位减一。 数组的作用是：如果数组中secret当前字符对应数字为下标的元素小于零，说明在这之前的操作中，guess中出现过若干次这个数字（这样才会被减了若干个1，才会导致小于零），且肯定是在其他位置上（不会与secret当前字符对应数字所代表下标一样），那么就符合了“cow”的要求—值相同，位置不同。这样统计一次（cows++）后，将对应数组元素加一，抵消掉这次的作用，接下来继续统计。同理，如果数组中guess当前字符对应数字为下标的元素大于零，说明在这之前的操作中，secret中出现过若干次这个数字（这样才会被加了若干个1，才会导致大于零），且肯定是在其他位置上（不会与guess当前字符对应数字所代表下标一样），那么也就符合了“cow”的要求—值相同，位置不同。这样统计一次（cows++）后，将对应数组元素减一，抵消掉这次的作用，接下来继续统计。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#341]","slug":"leetcode-341","date":"2016-07-05T09:26:39.000Z","updated":"2018-12-12T16:08:06.547Z","comments":true,"path":"2016/07/05/leetcode-341/","link":"","permalink":"http://www.gcidea.info/2016/07/05/leetcode-341/","excerpt":"","text":"题目 Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list – whose elements may also be integers or other lists. Example:Given the list [[1,1],2,[1,1]], By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. Given the list [1,[4,[6]]], By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. 解决方案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * public interface NestedInteger &#123; * * // @return true if this NestedInteger holds a single integer, rather than a nested list. * public boolean isInteger(); * * // @return the single integer that this NestedInteger holds, if it holds a single integer * // Return null if this NestedInteger holds a nested list * public Integer getInteger(); * * // @return the nested list that this NestedInteger holds, if it holds a nested list * // Return null if this NestedInteger holds a single integer * public List&lt;NestedInteger&gt; getList(); * &#125; */public class NestedIterator implements Iterator&lt;Integer&gt; &#123; private List&lt;NestedInteger&gt; list = new ArrayList&lt;&gt;(); private Stack&lt;Integer&gt; num = new Stack&lt;&gt;(); public NestedIterator(List&lt;NestedInteger&gt; nestedList) &#123; this.list = nestedList; getFlatternInteger(list); &#125; private void getFlatternInteger(List&lt;NestedInteger&gt; nest)&#123; for(int k = nest.size() - 1; k &gt;= 0; k--)&#123; if(nest.get(k).isInteger())&#123; num.push(nest.get(k).getInteger()); &#125; else &#123; List&lt;NestedInteger&gt; nestList = nest.get(k).getList(); getFlatternInteger(nestList); &#125; &#125; &#125; @Override public Integer next() &#123; return num.pop(); &#125; @Override public boolean hasNext() &#123; return !num.isEmpty(); &#125;&#125;/** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i = new NestedIterator(nestedList); * while (i.hasNext()) v[f()] = i.next(); */ 注意事项 接口NestedInteger无需实现，可以直接调用相应方法。 私有方法getFlatternInteger用于对输入的List nestedList做展开并存入一个堆栈。对于是数字的项，直接存入堆栈，对于是List类型的元素，递归调用该方法。 next()和hasNext()方法对栈做弹出和判空即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#326]","slug":"leetcode-326","date":"2016-07-05T06:26:39.000Z","updated":"2018-12-12T16:08:06.935Z","comments":true,"path":"2016/07/05/leetcode-326/","link":"","permalink":"http://www.gcidea.info/2016/07/05/leetcode-326/","excerpt":"","text":"题目 Given an integer, write a function to determine if it is a power of three. Follow up:Could you do it without using any loop / recursion? 解决方案12345678910111213public class Solution &#123; public boolean isPowerOfThree(int n) &#123; if(n == 0) return false; if(n == 1) return true; boolean result = false; String str = Integer.toString(n); int len = str.length(); if(n == Math.pow(3, (2 * len - 1)) || n == Math.pow(3, (2 * len)))&#123; result = true; &#125; return result; &#125;&#125; 注意事项 题目要求不要用任何循环或者递归。 找到3的所有次幂的规律（除去0次幂）： 3^1 = 3, 3^2 = 9： 结果长度1位；3^3 = 27, 3^4 = 81： 结果长度2位；3^5 = 243, 3^6 = 729： 结果长度3位；3^7 = 2187, 3^8 = 6561： 结果长度4位；3^9 = 19683, 3^10 = 59049： 结果长度5位；3^11 = 177147, 3^12 = 531441：结果长度6位；… …3^(2*k-1) = … , 3^(2*k) = … ：结果长度k位； 因此，拿到一个整数，先判断其长度，在长度已知的情况下，该数是3的某次幂只可能有两种情况，判断是否是二者之一即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#290]","slug":"leetcode-290","date":"2016-07-04T14:13:34.000Z","updated":"2018-12-12T16:08:08.042Z","comments":true,"path":"2016/07/04/leetcode-290/","link":"","permalink":"http://www.gcidea.info/2016/07/04/leetcode-290/","excerpt":"","text":"题目 Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. Example: pattern = “abba”, str = “dog cat cat dog” should return true. pattern = “abba”, str = “dog cat cat fish” should return false. pattern = “aaaa”, str = “dog cat cat dog” should return false. pattern = “abba”, str = “dog dog dog dog” should return false. Note:You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space. 解决方案12345678910111213141516171819202122232425import java.util.Hashtable;public class Solution &#123; public boolean wordPattern(String pattern, String str) &#123; String[] arr = str.split(\" \"); int len1 = pattern.length(); int len2 = arr.length; if(len1 != len2) return false; Hashtable&lt;Character, String&gt; table = new Hashtable&lt;&gt;(); for(int i = 0; i &lt; len1; i++)&#123; if(!table.containsKey(pattern.charAt(i)))&#123; if(!table.containsValue(arr[i]))&#123; table.put(pattern.charAt(i), arr[i]); &#125; else &#123; return false; &#125; &#125; else &#123; if(!table.get(pattern.charAt(i)).equals(arr[i]))&#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 注意事项1.使用一个Hashtable，key为模式字符串，value为待检测字符串。遍历两个输入字符串，如果key值pattern.charAt(i)不存在，且arr[i]的值在table中不存在，则可以将pattern.charAt(i)和arr[i]对应起来，存入table。 如果key值pattern.charAt(i)存在，则将其value值和当前arr[i]比较，如不同，说明模式未能正确匹配，返回false。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#292]","slug":"leetcode-292","date":"2016-07-04T14:13:34.000Z","updated":"2018-12-12T16:08:07.689Z","comments":true,"path":"2016/07/04/leetcode-292/","link":"","permalink":"http://www.gcidea.info/2016/07/04/leetcode-292/","excerpt":"","text":"题目 You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend. 解决方案1234567public static boolean canWinNim(int n)&#123; if (n % 4 != 0)&#123; return true; &#125; else &#123; return false; &#125;&#125; 注意事项 思路是递归，弱化问题，考虑：如果石子数量少1个会输的话，那么现在一定会赢（通过先取走1个石子的办法）；如果石子数量少2个会输的话，那么现在一定会赢（通过先取走2个石子的办法）；如果石子数量少3个会输的话，那么现在一定会赢（通过先取走3个石子的办法）。 故也可以如下实现：12345678public static boolean canWinNim(int n)&#123; if(n==1 || n==2 || n==3)&#123; return true; &#125; else &#123; if(!canWinNim(n-1) || !canWinNim(n-2) || !canWinNim(n-3)) return true; return false; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#283]","slug":"leetcode-283","date":"2016-07-03T14:59:28.000Z","updated":"2018-12-12T16:08:08.393Z","comments":true,"path":"2016/07/03/leetcode-283/","link":"","permalink":"http://www.gcidea.info/2016/07/03/leetcode-283/","excerpt":"","text":"题目 Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. Example:given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. 解决方案12345678910111213141516public class Solution &#123; public void moveZeroes(int[] nums) &#123; int N = 0; for(int k = 0;k &lt; nums.length; k++)&#123; if(nums[k] == 0)&#123; N++; continue; &#125; else &#123; if(N &gt; 0)&#123; nums[k-N] = nums[k]; nums[k] = 0; &#125; &#125; &#125; &#125;&#125; 注意事项 遍历一遍数组，遇到0，就给零值计数器加一。 遇到非零，如果前面至少有一个零（N&gt;1），则将当前值前移N位，并给当前位赋值为0。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#278]","slug":"leetcode-278","date":"2016-07-02T04:20:31.000Z","updated":"2018-12-12T16:08:09.115Z","comments":true,"path":"2016/07/02/leetcode-278/","link":"","permalink":"http://www.gcidea.info/2016/07/02/leetcode-278/","excerpt":"","text":"题目 You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. 解决方案12345678910111213141516171819/* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; int i = 1; int j = n; if(isBadVersion(1)) return 1; while (i &lt; j)&#123; int mid = i + (j - i) / 2; if(!isBadVersion(mid))&#123; i = mid + 1; &#125; else &#123; j = mid - 1; &#125; &#125; return isBadVersion(i) ? i : i+1; &#125;&#125; 注意事项 要清楚理解题意。待实现方法firstBadVersion()需要一个参数：即1~n的n，但是整个功能需要传入两个参数：数据范围、第一个出错版本的版本号。其中，n传递给firstBadVersion()，而第一个出错版本的版本号bad则在solution类实例化时通过在其构造函数中调用父类构造函数来传入。因此，在本地测试时要加上isBadVersion()方法的实现，整体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243package task278;/** * Created by gaochang on 2016/11/25. */public class solution extends VersionControl&#123; public solution(int pick)&#123; super(pick); &#125; public int firstBadVersion(int n) &#123; int i = 1; int j = n; if(isBadVersion(1)) return 1; while (i &lt; j)&#123; int mid = i + (j - i) / 2; if(!isBadVersion(mid))&#123; i = mid + 1; &#125; else &#123; j = mid - 1; &#125; &#125; return isBadVersion(i) ? i : i+1; &#125; public static void main(String[] args)&#123; int n = 3; int bad = 2; solution s = new solution(bad); int re = s.firstBadVersion(n); System.out.println(re); &#125;&#125;class VersionControl &#123; private int res; public VersionControl(int val)&#123; this.res = val; &#125; public boolean isBadVersion(int version)&#123; return version &gt;= res ? true : false; &#125;&#125; 与使用二分查找某一具体元素稍有不同的是，本题是要在数组中找到第一个false（即第一个出错版本的版本号），二分查找，每次判断中间mid元素的正确性。如果正确，则在当前的后半段继续查找，如果错误，则在当前的前半段继续查找，跳出条件是头索引小于尾索引。这样，调出后的i并不一定指向的是第一个错误版本的序号，有可能是第一个错误版本的序号的前一个。因此最后返回的时候要再对i对应版本的正确性进行一次判断。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#28]","slug":"leetcode-28","date":"2016-07-02T00:26:39.000Z","updated":"2018-12-12T16:08:08.743Z","comments":true,"path":"2016/07/02/leetcode-28/","link":"","permalink":"http://www.gcidea.info/2016/07/02/leetcode-28/","excerpt":"","text":"题目 Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. 解决方案123456789101112131415161718192021222324252627282930public class Solution &#123; public int strStr(String haystack, String needle) &#123; int result = -1; int lenHaystack = haystack.length(); int lenHayNeedle = needle.length(); if(lenHayNeedle &gt; lenHaystack) return -1; if(lenHayNeedle == 0) return 0; char[] str = haystack.toCharArray(); char[] sub = needle.toCharArray(); for(int n = 0; n &lt; lenHaystack - lenHayNeedle + 1; n++)&#123; boolean flag = false; int num = 0; for(int m = 0; m &lt; lenHayNeedle; m++)&#123; if(str[m + n] == sub[m])&#123; num++; if(num == lenHayNeedle)&#123; result = n; flag = true; break; &#125; &#125; &#125; if(flag)&#123; break; &#125; &#125; return result; &#125;&#125; 注意事项 实现查询子字符串开始位置下标的方法，在java中即indexOf()，当然不能直接使用这个方法。 将两个字符串均转化成字符数组。 对父字符串只需要遍历0~lenHaystack - lenHayNeedle这一段，因为如果包含子字符串，那么开始下标一定位于这一段。 内层遍历子字符串，和父字符串当前段逐一比较即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#263]","slug":"leetcode-263","date":"2016-07-01T08:20:31.000Z","updated":"2018-12-12T16:08:10.211Z","comments":true,"path":"2016/07/01/leetcode-263/","link":"","permalink":"http://www.gcidea.info/2016/07/01/leetcode-263/","excerpt":"","text":"题目 Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. ExampleFor example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number. 解决方案123456789101112public class Solution &#123; public boolean isUgly(int num) &#123; if(num &lt;= 0) return false; if(num == 1) return true; for (int i = 2; i &lt;= 5 &amp;&amp; num &gt; 0; i++)&#123; while (num % i == 0)&#123; num /= i; &#125; &#125; return num == 1; &#125;&#125; 注意事项 以下暴力方法会超时，不可用： 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public boolean isUgly(int num) &#123; if(num &lt;= 0) return false; if(num == 1) return true; if(isPrime(num))&#123; if(!(num == 2 || num == 3 || num == 5))&#123; return false; &#125; &#125; boolean result = true; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 2; i &lt;= num; i++)&#123; if(num % i == 0)&#123; list.add(i); &#125; &#125; for(int j = 0;j&lt;list.size();j++)&#123; if(isPrime(list.get(j)))&#123; if(!(list.get(j) == 2 || list.get(j) == 3 || list.get(j) == 5))&#123; result = false; break; &#125; &#125; &#125; return result; &#125; private static boolean isPrime(int num)&#123; for(int i = 2; i &lt;= Math.sqrt(num); i++)&#123; if(num % i == 0)&#123; return false; &#125; &#125; if(num == 1) return false; return true; &#125;&#125; 解决方案中的方法非常灵活巧妙。对于给定的数num，不断将其除以2,3,4,5（前提条件是能整除），该过程结束后，如果结果为1，说明num是由若干个2,3,5相乘得到的，这就满足ugly number的条件；而如果还未达到1，说明有其他不能被2,3,4,5整除的因子，也就是发现了不为2,3,5的质因子。 除以4就相当于除以2，这里是为了循环条件连贯代码结构完整。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#268]","slug":"leetcode-268","date":"2016-07-01T07:20:31.000Z","updated":"2018-12-12T16:08:09.838Z","comments":true,"path":"2016/07/01/leetcode-268/","link":"","permalink":"http://www.gcidea.info/2016/07/01/leetcode-268/","excerpt":"","text":"题目 Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array. For example: Given nums = [0, 1, 3] return 2. NoteYour algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? 解决方案123456789101112131415161718192021public class Solution &#123; public int missingNumber(int[] nums) &#123; int N = nums.length; if(N == 0) return 0; int result = 0; Arrays.sort(nums); if(nums[N-1] != N)&#123; result = N; &#125; else if(nums[0] != 0)&#123; result = 0; &#125; else &#123; for(int i = 0; i &lt; N-1; i++)&#123; if(nums[i+1] - nums[i] != 1)&#123; result = i+1; break; &#125; &#125; &#125; return result; &#125;&#125; 注意事项 先考虑长度为0的特殊情况。 将数组排序。 考虑两端情况。 遍历考虑中间情况。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#26]","slug":"leetcode-26","date":"2016-07-01T01:26:39.000Z","updated":"2018-12-12T16:08:10.596Z","comments":true,"path":"2016/07/01/leetcode-26/","link":"","permalink":"http://www.gcidea.info/2016/07/01/leetcode-26/","excerpt":"","text":"题目 Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. Example:Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length. 解决方案12345678910111213141516171819202122232425262728public class Solution &#123; public int removeDuplicates(int[] nums) &#123; int N = nums.length; if(N == 0) return 0; int diff = N; for(int i =0; i &lt; N-1; i++)&#123; if(nums[i] == nums[i+1])&#123; diff--; &#125; &#125; for(int i =0; i &lt; N-1; i++)&#123; if(nums[i] == nums[i+1])&#123; if(i &lt; diff-1)&#123; handle(nums, i, N); &#125; &#125; &#125; return diff; &#125; private static void handle(int[] a, int index, int N)&#123; for(int m = 0; m &lt;= N-index-3; m++)&#123; a[index+1+m] = a[index+2+m]; &#125; if(a[index] == a[index+1])&#123; handle(a, index, N); &#125; &#125;&#125; 注意事项 要求不能开辟新的数组，使用常量空间原地完成。 遍历一遍得到不相同元素个数。 再遍历，如果当前元素等于下一元素且当前元素下标小于(diff-1)，做如下处理：将下一元素后一个元素开始的值依次向前复制；如果移动后当前元素还等于下一元素，递归调用继续处理。 该方法效率不好，discuss中vote较高的方案是：123456789101112public class Solution &#123; public int removeDuplicates(int[] nums) &#123; int N = nums.length; int p = 0; for(int i = 0; i &lt; N; i++)&#123; if(p == 0 || nums[i] &gt; nums[p-1])&#123; nums[p++] = nums[i]; &#125; &#125; return p; &#125;&#125; 该方案没有单独用一次遍历来获取不相同元素个数。只遍历一次，定义了一个下标p，它始终指向当前遍历过的元素中互不相同的元素的最后一个，同时，p++也就是不相同元素的个数。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#27]","slug":"leetcode-27","date":"2016-07-01T00:26:39.000Z","updated":"2018-12-12T16:08:09.479Z","comments":true,"path":"2016/07/01/leetcode-27/","link":"","permalink":"http://www.gcidea.info/2016/07/01/leetcode-27/","excerpt":"","text":"题目 Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example:Given input array nums = [3,2,2,3], val = 3 Your function should return length = 2, with the first two elements of nums being 2. 解决方案123456789101112131415161718192021222324252627public class Solution &#123; public int removeElement(int[] nums, int val) &#123; int N = nums.length; Arrays.sort(nums); int equal = 0; for(int k = 0; k &lt; N; k++)&#123; if(nums[k] == val) &#123; equal++; &#125; &#125; int result = N - equal; if(equal == N) return 0; for(int h = 0; h &lt; N; h++)&#123; if(nums[h] == val) &#123; if(h &lt; result) &#123; for(int m = 0; m &lt; result; m++)&#123; if(h + equal + m &lt; N)&#123; nums[h + m] = nums[h + equal + m]; &#125; &#125; &#125; break; &#125; &#125; return result; &#125;&#125; 注意事项 要求不能开辟新的数组，使用常量空间原地完成。 先对数组排序，并统计出要删除元素的个数。 之后的工作就是进行遍历，并对某些位置元素进行移动。当equal == N，表明数组中全部元素都要删除，可以直接返回0。 当第一个待删除元素的下标大于新数组长度result，不需任何操作（指移动元素）；否则，从第一个待删除元素的下标开始，将间隔（待删除元素个数equal）的元素依次移动到当前位置，注意不要数组越界。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#258]","slug":"leetcode-258","date":"2016-06-30T15:20:31.000Z","updated":"2018-12-12T16:08:10.976Z","comments":true,"path":"2016/06/30/leetcode-258/","link":"","permalink":"http://www.gcidea.info/2016/06/30/leetcode-258/","excerpt":"","text":"题目 Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. For example: Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. 解决方案12345678910111213141516public class Solution &#123; public int addDigits(int num) &#123; int result; if (num &lt; 10) &#123; result = num; &#125; else &#123; String num2str = Integer.toString(num); int newNum = 0; for(int k = 0; k&lt; num2str.length(); k++)&#123; newNum += Integer.parseInt(String.valueOf(num2str.charAt(k))); &#125; result = addDigits(newNum); &#125; return result; &#125;&#125; 注意事项 判断数字是否小于10（即是否是1位的数字），如果不是，将数字转为字符串，遍历取出每个字符，再转为对应数字，求和后用得到的结果递归调用addDigits()方法。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#242]","slug":"leetcode-242","date":"2016-06-29T09:26:39.000Z","updated":"2018-12-12T16:08:11.349Z","comments":true,"path":"2016/06/29/leetcode-242/","link":"","permalink":"http://www.gcidea.info/2016/06/29/leetcode-242/","excerpt":"","text":"题目 Given two strings s and t, write a function to determine if t is an anagram of s. Example:s = “anagram”, t = “nagaram”, return true.s = “rat”, t = “car”, return false. Note:You may assume the string contains only lowercase alphabets. 解决方案123456789101112131415161718192021222324252627282930public class Solution &#123; public static boolean isAnagram(String s, String t) &#123; boolean result = true; int sLen = s.length(); int tLen = t.length(); if(sLen != tLen)&#123; result = false; &#125; else &#123; char[] arrayS = sortStr(s); char[] arrayT = sortStr(t); for(int i = 0 ; i &lt; arrayS.length ; i++)&#123; if(arrayS[i] != arrayT[i])&#123; result = false; break; &#125; &#125; &#125; return result; &#125; private static char[] sortStr(String str)&#123; int N = str.length(); char[] a = new char[N]; for(int k=0; k&lt;N; k++)&#123; a[k] = str.charAt(k); &#125; Arrays.sort(a); return a; &#125;&#125; 注意事项 两个字符串互为字谜，首先长度要一样。 将两个字符串排序，只要对应位不一样，则肯定不是互为字谜。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#24]","slug":"leetcode-24","date":"2016-06-28T07:26:39.000Z","updated":"2018-12-12T16:08:11.738Z","comments":true,"path":"2016/06/28/leetcode-24/","link":"","permalink":"http://www.gcidea.info/2016/06/28/leetcode-24/","excerpt":"","text":"题目 Given a linked list, swap every two adjacent nodes and return its head. Example:Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Note:Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 解决方案123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head == null) return null; ListNode p = head; while(p != null &amp;&amp; p.next != null)&#123; int temp = p.next.val; p.next.val = p.val; p.val = temp; p = p.next.next; &#125; return head; &#125;&#125; 注意事项 默认链表有偶数个元素。 遍历整个链表，每两个做交换即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#237]","slug":"leetcode-238","date":"2016-06-27T15:17:13.000Z","updated":"2018-12-12T16:08:12.114Z","comments":true,"path":"2016/06/27/leetcode-238/","link":"","permalink":"http://www.gcidea.info/2016/06/27/leetcode-238/","excerpt":"","text":"题目 Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Solve it without division and in O(n). Notegiven [1,2,3,4], return [24,12,8,6]. 解决方案123456789101112131415161718192021222324252627282930313233public class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int N = nums.length; int[] output = new int[N]; int zero = 0; int total = 1; for(int i = 0; i &lt; N; i++)&#123; if(nums[i] == 0)&#123; zero++; &#125; else &#123; total *= nums[i]; &#125; &#125; if(zero &gt;= 2)&#123; for(int i=0;i&lt;N;i++)&#123; output[i] = 0; &#125; &#125; else if(zero == 1)&#123; for(int i=0;i&lt;N;i++)&#123; if(nums[i] == 0)&#123; output[i] = total; &#125; else &#123; output[i] = 0; &#125; &#125; &#125; else &#123; for(int i = 0; i &lt; N; i++)&#123; output[i] = total / nums[i]; &#125; &#125; return output; &#125;&#125; 注意事项 考虑了0的个数进行单独处理。 上述方法使用了除法，不符合题目要求，discuss中vote较高的回答为：123456789101112public int[] productExceptSelf(int[] nums) &#123; int[] result = new int[nums.length]; for (int i = 0, tmp = 1; i &lt; nums.length; i++) &#123; result[i] = tmp; tmp *= nums[i]; &#125; for (int i = nums.length - 1, tmp = 1; i &gt;= 0; i--) &#123; result[i] *= tmp; tmp *= nums[i]; &#125; return result;&#125; 该方法很巧妙，第一遍遍历算出了每个元素左边的值的乘积，保留该结果。再反向遍历，在刚才乘积结果的基础上再累成每个元素右边的值，最后就得到了答案。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#237]","slug":"leetcode-237","date":"2016-06-27T15:17:13.000Z","updated":"2018-12-12T16:08:12.504Z","comments":true,"path":"2016/06/27/leetcode-237/","link":"","permalink":"http://www.gcidea.info/2016/06/27/leetcode-237/","excerpt":"","text":"题目 Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function. 解决方案1234567891011121314/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next; &#125;&#125; 注意事项 思路很简单，既然要删除node节点，只要把node节点后面的节点的值赋给node节点，并且将node节点的next指向node节点后面的后面的节点。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#234]","slug":"leetcode-234","date":"2016-06-27T09:17:13.000Z","updated":"2018-12-12T16:08:12.889Z","comments":true,"path":"2016/06/27/leetcode-234/","link":"","permalink":"http://www.gcidea.info/2016/06/27/leetcode-234/","excerpt":"","text":"题目 Given a singly linked list, determine if it is a palindrome. 解决方案1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isPalindrome(ListNode head) &#123; boolean result = true; if(head == null) return result; ListNode p = head; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (p != null)&#123; list.add(p.val); p = p.next; &#125; p = head; for(int i = list.size()-1; i &gt;= 0; i--)&#123; if(list.get(i) != p.val)&#123; result = false; break; &#125; p = p.next; &#125; return result; &#125;&#125; 注意事项 一共遍历了两遍，第一遍把所有值存起来；第二遍将存起来的值倒序和链表中每个值比较。 该方法效率较低，更好的方法如下：123456789101112131415161718192021222324252627public boolean isPalindrome(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while(fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; &#125; if(fast != null) slow = slow.next; slow = reverse(slow); while(slow != null &amp;&amp; head.val == slow.val) &#123; head = head.next; slow = slow.next; &#125; return slow == null;&#125;private ListNode reverse(ListNode head) &#123; ListNode prev = null; while(head != null) &#123; ListNode next = head.next; head.next = prev; prev = head; head = next; &#125; return prev;&#125; 该方法中包含了很常用的链表翻转方法：12345678910private ListNode reverse(ListNode head) &#123; ListNode prev = null; while(head != null) &#123; ListNode next = head.next; head.next = prev; prev = head; head = next; &#125; return prev;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#232]","slug":"leetcode-232","date":"2016-06-25T02:17:13.000Z","updated":"2018-12-12T16:08:13.268Z","comments":true,"path":"2016/06/25/leetcode-232/","link":"","permalink":"http://www.gcidea.info/2016/06/25/leetcode-232/","excerpt":"","text":"题目 Implement the following operations of a queue using stacks. push(x) – Push element x to the back of queue. pop() – Removes the element from in front of queue. peek() – Get the front element. empty() – Return whether the queue is empty. Note You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). 解决方案12345678910111213141516171819202122232425262728293031323334353637class MyQueue &#123; private Stack&lt;Integer&gt; stack1 = new Stack&lt;&gt;(); private Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;(); // Push element x to the back of queue. public void push(int x) &#123; stack1.push(x); &#125; // Removes the element from in front of queue. public void pop() &#123; while (!stack1.empty())&#123; stack2.push(stack1.pop()); &#125; stack2.pop(); while (!stack2.empty())&#123; stack1.push(stack2.pop()); &#125; &#125; // Get the front element. public int peek() &#123; while (!stack1.empty())&#123; stack2.push(stack1.pop()); &#125; int res = stack2.peek(); while (!stack2.empty())&#123; stack1.push(stack2.pop()); &#125; return res; &#125; // Return whether the queue is empty. public boolean empty() &#123; return stack1.empty() ? true : false; &#125;&#125; 注意事项 使用两个栈来实现队列。 思路是，对于push()操作，直接向第一个栈push即可；对于pop()操作，将第一个栈所有元素弹出并压入第二个栈，弹出第二个栈的栈顶元素，再把剩下的元素依次弹出并压回第一个栈；对于peek()操作，将第一个栈所有元素弹出并压入第二个栈，查看第二个栈的栈顶元素（只是查看），之后将第二个栈的所有元素依次弹出并压回第一个栈。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#231]","slug":"leetcode-231","date":"2016-06-23T02:17:13.000Z","updated":"2018-12-12T16:08:13.652Z","comments":true,"path":"2016/06/23/leetcode-231/","link":"","permalink":"http://www.gcidea.info/2016/06/23/leetcode-231/","excerpt":"","text":"题目 Given an integer, write a function to determine if it is a power of two. 解决方案1234567891011public class Solution &#123; public boolean isPowerOfTwo(int n) &#123; if(n &lt; 0) return false; if(n == 1) return true; double n1 = (double) n; while (n1 / 2.0 &gt;= 1.0) &#123; n1 = n1 / 2.0; &#125; return n1 == 1.0 ? true : false; &#125;&#125; 注意事项 先处理特殊情况。 将n转换为double型，不断除以2，直到结果小于1.0.此时根据n1的结果即可确定。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#219]","slug":"leetcode-219","date":"2016-06-22T12:26:39.000Z","updated":"2018-12-12T16:08:15.613Z","comments":true,"path":"2016/06/22/leetcode-219/","link":"","permalink":"http://www.gcidea.info/2016/06/22/leetcode-219/","excerpt":"","text":"题目 Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k. 解决方案12345678910111213public class Solution &#123; public boolean containsNearbyDuplicate(int[] nums, int k) &#123; int N = nums.length; if(nums == null || N == 0) return false; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; if(i &gt; k) set.remove(nums[i-k-1]); if(!set.add(nums[i])) return true; &#125; return false; &#125;&#125; 注意事项 以下方法不稳定，在不同提交时，有时会通过，有时会超时，效率不高，不是好方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;public class Solution &#123; public boolean containsNearbyDuplicate(int[] nums, int k) &#123; int N = nums.length; if(nums == null || N == 0) return false; int[] index = new int[N]; int[] cpy = new int[N]; for(int p = 0; p &lt; N; p++)&#123; cpy[p] = nums[p]; &#125; final Hashtable&lt;Integer, Integer&gt; ht = new Hashtable&lt;Integer, Integer&gt;(); for(int i = 0; i &lt; N; i++)&#123; ht.put(i, nums[i]); &#125; List&lt;Integer&gt; v = new ArrayList&lt;Integer&gt;(ht.keySet()); Collections.sort(v,new Comparator&lt;Object&gt;()&#123; public int compare(Object arg0,Object arg1)&#123; return ht.get(arg1) - ht.get(arg0); &#125; &#125; ); int t = N-1; for (Integer i : v) &#123; index[t--] = i; &#125; Arrays.sort(nums); boolean result = false; for(int i = 0; i &lt; N-1; i++)&#123; if(nums[i] - nums[i+1] == 0)&#123; if(index[i+1] - index[i] &lt;= k)&#123; result = true; break; &#125; &#125; &#125; return result; &#125;&#125; 解决方案中借鉴了discuss中的优秀回答，这种方法比较巧妙地维护了一个长度为k的HashSet。复杂度为o(n)。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#226]","slug":"leetcode-226","date":"2016-06-22T12:17:13.000Z","updated":"2018-12-12T16:08:14.044Z","comments":true,"path":"2016/06/22/leetcode-226/","link":"","permalink":"http://www.gcidea.info/2016/06/22/leetcode-226/","excerpt":"","text":"题目 解决方案1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if(root != null) &#123; TreeNode tmp = root.left; root.left = root.right; root.right = tmp; invertTree(root.left); invertTree(root.right); return root; &#125;else &#123; return null; &#125; &#125;&#125; 注意事项 从根节点开始，查找每个节点的左、右子节点（无论是否存在），将之交换，并分别递归调用翻转方法invertTree()。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#226]","slug":"leetcode-223","date":"2016-06-22T07:17:13.000Z","updated":"2018-12-12T16:08:14.848Z","comments":true,"path":"2016/06/22/leetcode-223/","link":"","permalink":"http://www.gcidea.info/2016/06/22/leetcode-223/","excerpt":"","text":"题目 解决方案12345678910111213public class Solution &#123; public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; int s1 = (C - A) * (D - B); int s2 = (G - E) * (H - F); int left = Math.max(A, E); int right = Math.min(G, C); int top = Math.min(D, H); int bottom = Math.max(B, F); int common = 0; if(right &gt; left &amp;&amp; top &gt; bottom) common = (right - left) * (top - bottom); return s1 + s2 - common; &#125;&#125; 注意事项 不要尝试分类讨论所有情况，两个长方形的位置关系的可能性过于复杂。 先计算出各自面积。 关于公共重叠面积，假设有重叠，那么重叠的左边界由AE的较大者确定，右边界由GC的较小者确定，上边界由DH的较小者确定，下边界由BF的较大者确定。由此计算重叠面积。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#225]","slug":"leetcode-225","date":"2016-06-22T07:17:13.000Z","updated":"2018-12-12T16:08:14.466Z","comments":true,"path":"2016/06/22/leetcode-225/","link":"","permalink":"http://www.gcidea.info/2016/06/22/leetcode-225/","excerpt":"","text":"题目 Implement the following operations of a stack using queues. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. empty() – Return whether the stack is empty. Note You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack). 解决方案123456789101112131415161718192021222324252627282930313233343536373839404142class MyStack &#123; private LinkedList&lt;Integer&gt; list1 = new LinkedList&lt;&gt;(); private LinkedList&lt;Integer&gt; list2 = new LinkedList&lt;&gt;(); // Push element x onto stack. public void push(int x) &#123; list1.addLast(x); &#125; // Removes the element on top of the stack. public void pop() &#123; while (list1.size() &gt; 1)&#123; list2.addLast(list1.poll()); &#125; list1.poll(); while (!list2.isEmpty())&#123; list1.addLast(list2.poll()); &#125; &#125; // Get the top element. public int top() &#123; int res = 0; while (!list1.isEmpty())&#123; if(list1.size() == 1)&#123; res = list1.poll(); list2.addLast(res); &#125; else &#123; list2.addLast(list1.poll()); &#125; &#125; while (!list2.isEmpty())&#123; list1.addLast(list2.poll()); &#125; return res; &#125; // Return whether the stack is empty. public boolean empty() &#123; return list1.isEmpty() ? true : false; &#125;&#125; 注意事项 使用两个队列实现栈。 思路是：对于push()操作，直接向第一个队列push即可；对于pop()操作，如果第一个队列的大小大于1，则将第一个队列的元素弹出并压入第二个队列，否则，也就是第一个队列只剩下一个元素的时候，直接将其弹出（但不压入第二个队列），最后再把第二个队列所有元素放回第一个队列；对于peek()操作，类似pop()，当第一个队列大小为1的时候，将这个元素的值赋给res，最后把第二个队列所有元素放回第一个队列。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#22]","slug":"leetcode-22","date":"2016-06-22T02:26:39.000Z","updated":"2018-12-12T16:08:15.232Z","comments":true,"path":"2016/06/22/leetcode-22/","link":"","permalink":"http://www.gcidea.info/2016/06/22/leetcode-22/","excerpt":"","text":"题目 Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: [ “((()))”, “(()())”, “(())()”, “()(())”, “()()()”] 解决方案123456789101112131415public class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); recursivelyGetParenthesis(res, \"\", 0, 0, n); return res; &#125; private static void recursivelyGetParenthesis(List&lt;String&gt; list, String s, int left, int right, int n)&#123; if(s.length() == n * 2) &#123; list.add(s); return; &#125; if(left &lt; n) recursivelyGetParenthesis(list, s + \"(\", left + 1, right, n); if(right &lt; left) recursivelyGetParenthesis(list, s + \")\", left, right + 1, n); &#125;&#125; 注意事项 不应该从找规律的角度入手，这样即便得到可能情况的总数，但生成具体字符串时还比较麻烦。 recursivelyGetParenthesis()方法的作用是，逐步生成结果字符串，当长度满足时就作为一个符合要求的结果返回，否则，在当前片段的基础上递归调用自身，生成新的结果。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#217]","slug":"leetcode-217","date":"2016-06-21T12:26:39.000Z","updated":"2018-12-12T16:08:15.999Z","comments":true,"path":"2016/06/21/leetcode-217/","link":"","permalink":"http://www.gcidea.info/2016/06/21/leetcode-217/","excerpt":"","text":"题目 Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. 解决方案123456789101112131415public class Solution &#123; public boolean containsDuplicate(int[] nums) &#123; int N = nums.length; if(nums == null || N == 0) return false; Arrays.sort(nums); boolean result = false; for(int k = 0; k &lt; N-1; k++)&#123; if(nums[k] - nums[k+1] == 0)&#123; result = true; &#125; &#125; return result; &#125;&#125; 注意事项 将数组排序，遍历，如果有相邻两项相同，说明有相同元素。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#21]","slug":"leetcode-21","date":"2016-06-19T02:26:39.000Z","updated":"2018-12-12T16:08:16.386Z","comments":true,"path":"2016/06/19/leetcode-21/","link":"","permalink":"http://www.gcidea.info/2016/06/19/leetcode-21/","excerpt":"","text":"题目 Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 解决方案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null &amp;&amp; l2 == null) &#123; return null; &#125; else if(l1 == null) &#123; return l2; &#125; else if(l2 == null)&#123; return l1; &#125; ListNode h1 = l1; ListNode h2 = l2; ListNode result = new ListNode(0); ListNode cur = result; while(h1 != null || h2 != null)&#123; if(h1 != null &amp;&amp; h2 != null)&#123; if(h1.val &lt;= h2.val)&#123; cur.val = h1.val; h1 = h1.next; &#125; else &#123; cur.val = h2.val; h2 = h2.next; &#125; &#125; else if(h1 == null) &#123; cur.val = h2.val; h2 = h2.next; &#125; else &#123; cur.val = h1.val; h1 = h1.next; &#125; if(h1 == null &amp;&amp; h2 == null)&#123; cur.next = null; break; &#125; else &#123; cur.next = new ListNode(0); cur = cur.next; &#125; &#125; return result; &#125;&#125; 注意事项 从结果来看，题目默认的是升序排序。 两个有序链表合并，可以看到归并排序算法的影子，按照归并排序的算法进行处理即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#206]","slug":"leetcode-206","date":"2016-06-18T12:26:39.000Z","updated":"2018-12-12T16:08:16.776Z","comments":true,"path":"2016/06/18/leetcode-206/","link":"","permalink":"http://www.gcidea.info/2016/06/18/leetcode-206/","excerpt":"","text":"题目 Reverse a singly linked list. 解决方案123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head == null || head.next == null) return head; ArrayList&lt;Integer&gt; valList = new ArrayList&lt;Integer&gt;(); ListNode p = head; while (p != null)&#123; valList.add(p.val); p = p.next; &#125; ListNode newHead = new ListNode(0); ListNode q = newHead; for(int k = valList.size()-1; k &gt;= 0; k--)&#123; q.val = valList.get(k); if(k == 0)&#123; q.next = null; &#125; else &#123; q.next = new ListNode(0); &#125; q = q.next; &#125; return newHead; &#125;&#125; 注意事项 翻转链表。获取所有元素，倒序构建新链表。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#204]","slug":"leetcode-204","date":"2016-06-18T10:26:39.000Z","updated":"2018-12-12T16:08:17.511Z","comments":true,"path":"2016/06/18/leetcode-204/","link":"","permalink":"http://www.gcidea.info/2016/06/18/leetcode-204/","excerpt":"","text":"题目 Count the number of prime numbers less than a non-negative number, n. 解决方案12345678910111213141516171819public class Solution &#123; public int countPrimes(int n) &#123; if(n &lt;= 2) return 0; int count = 0; boolean[] primeNum = new boolean[n+1]; for(int k = 2; k &lt;= n; k++) primeNum[k] = true; for(int i = 2; i &lt;= Math.sqrt(n); i++)&#123; if(!primeNum[i]) continue; for(int j = i * i; j &lt; n; j += i)&#123; primeNum[j] = false; &#125; &#125; for(int m = 2; m &lt; n; m++)&#123; if(primeNum[m]) count++; &#125; return count; &#125;&#125; 注意事项 以下方法复杂度高会超时： 12345678910111213141516public class Solution &#123; public int countPrimes(int n) &#123; if(n &lt;= 2) return 0; int count = 0; int k = 2; while(k &lt; n) &#123; if(isPrime(k)) count++; k++; &#125; return count; &#125; private static boolean isPrime(int m)&#123; for(int i = 2; i &lt;= Math.sqrt(m); i++) if(m % i == 0) return false; return true; &#125;&#125; 思路是：对于给定n,判断小于n的每个正是是质数还是合数，在统计质数个数之和。要提高判断质数/合数的效率：创建一个数组，长度为n+1，数组元素值true/false代表对应下标的数字是质数还是合数，初始化认为每个元素都是true。整个遍历过程是一个标记的过程：标记从2开始小于根号n的所有整数的平方以及从平方开始的各个倍数，这些显然都是合数，且覆盖了全部合数的可能性。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#205]","slug":"leetcode-205","date":"2016-06-18T03:26:39.000Z","updated":"2018-12-12T16:08:17.131Z","comments":true,"path":"2016/06/18/leetcode-205/","link":"","permalink":"http://www.gcidea.info/2016/06/18/leetcode-205/","excerpt":"","text":"题目 Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. ExampleGiven “egg”, “add”, return true. Given “foo”, “bar”, return false. Given “paper”, “title”, return true. NoteYou may assume both s and t have the same length. 解决方案123456789101112131415161718import java.util.Hashtable;public class Solution &#123; public boolean isIsomorphic(String s, String t) &#123; Hashtable&lt;Character, Character&gt; table = new Hashtable&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++)&#123; if(!table.containsKey(s.charAt(i)))&#123; if(!table.containsValue(t.charAt(i)))&#123; table.put(s.charAt(i), t.charAt(i)); &#125; else &#123; return false; &#125; &#125; else &#123; if(table.get(s.charAt(i)) != t.charAt(i)) return false; &#125; &#125; return true; &#125;&#125; 注意事项 思路类似290题，模式匹配，已存在的键必须对应相同的value，不同的键不能有相同的value。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#203]","slug":"leetcode-203","date":"2016-06-17T03:26:39.000Z","updated":"2018-12-12T16:08:17.928Z","comments":true,"path":"2016/06/17/leetcode-203/","link":"","permalink":"http://www.gcidea.info/2016/06/17/leetcode-203/","excerpt":"","text":"题目 Remove all elements from a linked list of integers that have value val. Example:Given: 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6, val = 6Return: 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5 解决方案12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; if(head == null) return null; ListNode fakeHead = new ListNode(0); fakeHead.next = head; ListNode p = fakeHead; while (p != null &amp;&amp; p.next != null)&#123; if(p.next.val == val)&#123; p.next = p.next.next; continue; &#125; p = p.next; &#125; return fakeHead.next; &#125;&#125; 注意事项 使用“头指针”，去除头结点的特殊性。 如果当前节点的下一个节点是要删除的节点，将当前节点指向下一个节点之后的节点即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#202]","slug":"leetcode-202","date":"2016-06-17T03:26:39.000Z","updated":"2018-12-12T16:08:18.316Z","comments":true,"path":"2016/06/17/leetcode-202/","link":"","permalink":"http://www.gcidea.info/2016/06/17/leetcode-202/","excerpt":"","text":"题目 Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example:19 is a happy number 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 解决方案12345678910111213141516public class Solution &#123; public boolean isHappy(int n) &#123; StringBuilder builder = new StringBuilder(String.valueOf(n)); int sum = 0; for(int i = 0; i &lt; builder.length(); i++) sum += (builder.charAt(i) - '0') * (builder.charAt(i) - '0'); HashSet set = new HashSet(); set.add(sum); while(sum != 1)&#123; StringBuilder bu = new StringBuilder(String.valueOf(sum)); sum = 0; for(int i = 0; i &lt; bu.length(); i++) sum += (bu.charAt(i) - '0') * (bu.charAt(i) - '0'); if(!set.add(sum)) return false; &#125; return true; &#125;&#125; 注意事项 基本思路是：使用一个HashSet来存储每次求得的平方和，在和不为1的前提条件下，如果add方法失败，说明出现了重复值，即说明会有循环，不满足happy number条件，返回false。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#20]","slug":"leetcode-20","date":"2016-06-15T01:26:39.000Z","updated":"2018-12-12T16:08:18.732Z","comments":true,"path":"2016/06/15/leetcode-20/","link":"","permalink":"http://www.gcidea.info/2016/06/15/leetcode-20/","excerpt":"","text":"题目 Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not. 解决方案12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; public boolean isValid(String s) &#123; char[] sArr = s.toCharArray(); Stack&lt;String&gt; stack = new Stack&lt;&gt;(); boolean result = true; for(int i = 0; i &lt; sArr.length; i++)&#123; if(sArr[i] == '(' || sArr[i] == '[' || sArr[i] == '&#123;')&#123; stack.push(String.valueOf(sArr[i])); &#125; else &#123; if(stack.empty())&#123; result = false; break; &#125; else &#123; if(sArr[i] == ')')&#123; if(!\"(\".equals(stack.pop()))&#123; result = false; break; &#125; &#125; if(sArr[i] == ']')&#123; if(!\"[\".equals(stack.pop()))&#123; result = false; break; &#125; &#125; if(sArr[i] == '&#125;')&#123; if(!\"&#123;\".equals(stack.pop()))&#123; result = false; break; &#125; &#125; &#125; &#125; &#125; if(!stack.empty())&#123; result = false; &#125; return result; &#125;&#125; 注意事项 要求三种括号能够正确匹配。 使用数据结构栈来实现：每当遇到一组括号的“左部分”，压入堆栈；每当遇到“右部分”，堆栈弹出一个元素，与当前的“右部分”相比，看能否匹配。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#19]","slug":"leetcode-19","date":"2016-06-14T01:26:39.000Z","updated":"2018-12-12T16:08:19.128Z","comments":true,"path":"2016/06/14/leetcode-19/","link":"","permalink":"http://www.gcidea.info/2016/06/14/leetcode-19/","excerpt":"","text":"题目 Given a linked list, remove the nth node from the end of list and return its head. Example:Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note:Given n will always be valid.Try to do this in one pass. 解决方案12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; if(head == null) return null; ListNode p = head; int num = 0; while(p != null)&#123; num++; p = p.next; &#125; p = head; if(num - n ==0)&#123; head = head.next; return head; &#125; int temp = 0; while(p != null)&#123; temp++; if(temp == (num-n))&#123; if(p.next != null)&#123; p.next = p.next.next; &#125; &#125; p = p.next; &#125; return head; &#125;&#125; 注意事项 首先获取链表长度，之后删除指定节点就很简单。 但题目要求在一次遍历中解决问题，故如下方法更好：1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; if(head == null) return null; ListNode fakeHead = new ListNode(0); fakeHead.next = head; ListNode p = fakeHead; List&lt;ListNode&gt; list = new ArrayList&lt;&gt;(); while(p != null)&#123; list.add(p); if(list.size() &gt; (n+1))&#123; list.remove(0); &#125; p = p.next; &#125; list.get(0).next = list.get(1).next; return fakeHead.next; &#125;&#125; 其思路是： 使用了一个长度为(n+1)的ArrayList作为“滑动窗口”，这样遍历一遍链表，遍历结束时，list就会装着最后(n+1)个节点，所以要删除的是list中的第二个节点，因此只要将list中第一个节点指向第二个节点后面的内容即可（可能是null）。另外，还要注意使用了“头指针”，去除第一个节点的特殊性。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#189]","slug":"leetcode-189","date":"2016-06-13T23:26:39.000Z","updated":"2018-12-12T16:08:19.490Z","comments":true,"path":"2016/06/14/leetcode-189/","link":"","permalink":"http://www.gcidea.info/2016/06/14/leetcode-189/","excerpt":"","text":"题目 Rotate an array of n elements to the right by k steps. Example:with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. Note:Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. 解决方案123456789101112public class Solution &#123; public void rotate(int[] nums, int k) &#123; int len = nums.length; int[] result = new int[len]; for(int p = 0; p &lt; len; p++)&#123; result[p] = nums[(len - (k % len) + p) % len]; &#125; for(int q = 0; q &lt; len; q++) &#123; nums[q] = result[q]; &#125; &#125;&#125; 注意事项 找到下标规律，取相应元素即可。 该方法效率一般，更好的方法如下：12","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#179]","slug":"leetcode-179","date":"2016-06-13T09:26:39.000Z","updated":"2018-12-12T16:08:19.864Z","comments":true,"path":"2016/06/13/leetcode-179/","link":"","permalink":"http://www.gcidea.info/2016/06/13/leetcode-179/","excerpt":"","text":"题目 Given a list of non negative integers, arrange them such that they form the largest number. Example:Given [3, 30, 34, 5, 9], the largest formed number is 9534330. Note: The result may be very large, so you need to return a string instead of an integer. 解决方案123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public String largestNumber(int[] nums) &#123; //如果为空，直接返回空串 if(nums == null || nums.length == 0) return \"\"; //将数字数组转换为字符串数组，便于排序 String[] s_num = new String[nums.length]; for(int i = 0; i &lt; nums.length; i++)&#123; s_num[i] = String.valueOf(nums[i]); &#125; //实现Comparator接口用来定义排序规则 Comparator&lt;String&gt; comp = new Comparator&lt;String&gt;()&#123; @Override public int compare(String str1, String str2)&#123; String s1 = str1 + str2; String s2 = str2 + str1; return s2.compareTo(s1); &#125; &#125;; //数组排序 Arrays.sort(s_num, comp); //如果排序后数组第一个元素是0，则说明都是零，直接返回“0”即可 if(s_num[0].charAt(0) == '0')&#123; return \"0\"; &#125; //否则，使用StringBuilder将字符串数组中每一项连起来即可 StringBuilder sb = new StringBuilder(); for(String s: s_num)&#123; sb.append(s); &#125; return sb.toString(); &#125;&#125; 注意事项1.曾考虑以下想法： 对于两个要比较的数，将长度补齐，并且较短的末尾是用0补齐 对于两个要比较的数，将长度补齐，并且较短的末尾是用个位数补齐 这两种方法都需要考虑不少特殊情况再单独做出判断，不是很完整。 2.上述方法是借鉴discuss中vote较高的回答。核心是实现Comparator接口用来定义排序规则，用此规则使用Arrays.sort排序。 3.由于最后要做字符串拼接，因此务必使用StringBuilder而非String直接相连，大大提高性能。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#171]","slug":"leetcode-171","date":"2016-06-12T10:26:39.000Z","updated":"2018-12-12T16:08:20.637Z","comments":true,"path":"2016/06/12/leetcode-171/","link":"","permalink":"http://www.gcidea.info/2016/06/12/leetcode-171/","excerpt":"","text":"题目 Given a column title as appear in an Excel sheet, return its corresponding column number. Note:A -&gt; 1B -&gt; 2C -&gt; 3…Z -&gt; 26AA -&gt; 27AB -&gt; 28 解决方案1234567public class Solution &#123; public int titleToNumber(String s) &#123; double result = 0; for(int i = 0; i &lt; s.length(); i++) result += Math.pow(26, (s.length() - 1 - i)) * (s.charAt(i) - 'A' + 1); return (int) result; &#125;&#125; 注意事项 遍历字符串，每一位的权重是26的(s.length() - 1 - i)次幂，结果求和即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#172]","slug":"leetcode-172","date":"2016-06-12T09:26:39.000Z","updated":"2018-12-12T16:08:20.250Z","comments":true,"path":"2016/06/12/leetcode-172/","link":"","permalink":"http://www.gcidea.info/2016/06/12/leetcode-172/","excerpt":"","text":"题目 Given an integer n, return the number of trailing zeroes in n!. Note:Your solution should be in logarithmic time complexity. 解决方案12345678910public class Solution &#123; public int trailingZeroes(int n) &#123; int count = 0; while(n &gt; 0)&#123; count += n / 5; n = n / 5; &#125; return count; &#125;&#125; 注意事项 并不是单纯考察求解某个数的阶乘值，因此没有必要按照给定的n先求出n!是多少，这样的话复杂度也符合o(lgn)的要求。 n!值末尾有0，那么必然是2和5相乘得来的（不可能是0本身）。因此，n!末尾有几个0，取决于2的个数和5的个数的最小值。可以得到的结论是，由于2比5小，因此对于任意正整数来说，阶乘各项中5的个数一定小于等于2的个数。因此，问题转化为对于给定n，从1到n相乘一共可以分解出多少个5。那么，在n大于0的条件下，不断将n除以5，将所得商累加起来，就是5的个数。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#169]","slug":"leetcode-169","date":"2016-06-12T09:26:39.000Z","updated":"2018-12-12T16:08:21.022Z","comments":true,"path":"2016/06/12/leetcode-169/","link":"","permalink":"http://www.gcidea.info/2016/06/12/leetcode-169/","excerpt":"","text":"题目 Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 解决方案123456public class Solution &#123; public int majorityElement(int[] nums) &#123; Arrays.sort(nums); return nums[nums.length / 2]; &#125;&#125; 注意事项 将数组排序，返回下标为 N/2 的元素即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#168]","slug":"leetcode-168","date":"2016-06-11T07:26:39.000Z","updated":"2018-12-12T16:08:21.418Z","comments":true,"path":"2016/06/11/leetcode-168/","link":"","permalink":"http://www.gcidea.info/2016/06/11/leetcode-168/","excerpt":"","text":"题目 Given a positive integer, return its corresponding column title as appear in an Excel sheet. Example:1 -&gt; A2 -&gt; B3 -&gt; C…26 -&gt; Z27 -&gt; AA28 -&gt; AB 解决方案123456789101112131415161718public class Solution &#123; public String convertToTitle(int n) &#123; if(n &lt;= 0) return \"\"; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(n &gt; 0)&#123; if(n % 26 == 0) &#123; list.add(26); n = n / 26 - 1; &#125; else &#123; list.add(n % 26); n = n / 26; &#125; &#125; StringBuilder builder = new StringBuilder(); for(int i = list.size() - 1; i &gt;= 0; i--) builder.append((char) ('A' + list.get(i) - 1)); return builder.toString(); &#125;&#125; 注意事项 本题相当于将输入的数字转换成二十六进制数（只不过不是0-25，而是1-26），然后使用A-Z代表1-26这26个数字。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#167]","slug":"leetcode-167","date":"2016-06-10T07:26:39.000Z","updated":"2018-12-12T16:08:21.806Z","comments":true,"path":"2016/06/10/leetcode-167/","link":"","permalink":"http://www.gcidea.info/2016/06/10/leetcode-167/","excerpt":"","text":"题目 Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution. Example:Input: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2 解决方案12345678910111213141516171819202122232425262728public class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int N = numbers.length; if(numbers == null || N == 0) return numbers; int[] result = new int[2]; int last = N-1; for(int i = N-1; i &gt; 0; i--)&#123; if(numbers[i] &lt; target)&#123; last = i; break; &#125; &#125; int begin = 0; int end = N - 1; while(begin &lt; end)&#123; if(numbers[begin] + numbers[end] == target)&#123; result[0] = begin+1; result[1] = end+1; break; &#125; else if(numbers[begin] + numbers[end] &lt; target)&#123; begin++; &#125; else &#123; end--; &#125; &#125; return result; &#125;&#125; 注意事项 以下是暴力解法，会超时： 12345678910111213141516public class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int N = numbers.length; if(numbers == null || N == 0) return numbers; int[] result = new int[2]; for(int i = 0; i &lt; N; i++)&#123; for(int j = i+1; j &lt; N; j++)&#123; if(numbers[i] + numbers[j] == target)&#123; result[0] = i+1; result[1] = j+1; &#125; &#125; &#125; return result; &#125;&#125; 解决方案中，首先排除了那些大于target的元素值。对于剩下的所有元素，分别将两端的值相加，如果等于target，则返回下标即可；如果大于target，说明右端点应换做较小的值，即end--;;如果小于target，说明左端点应换做较大的值，即begin++;。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#165]","slug":"leetcode-165","date":"2016-06-10T02:26:39.000Z","updated":"2018-12-12T16:08:22.209Z","comments":true,"path":"2016/06/10/leetcode-165/","link":"","permalink":"http://www.gcidea.info/2016/06/10/leetcode-165/","excerpt":"","text":"题目 Compare two version numbers version1 and version2.If version1 &gt; version2 return 1, if version1 &lt; version2 return -1, otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character.The . character does not represent a decimal point and is used to separate number sequences.For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision. ExampleHere is an example of version numbers ordering:0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37 解决方案1234567891011121314151617181920212223242526272829303132333435363738public class Solution &#123; public int compareVersion(String version1, String version2) &#123; String[] arr1 = version1.split(\"\\\\.\"); String[] arr2 = version2.split(\"\\\\.\"); List&lt;String&gt; list1 = new ArrayList&lt;&gt;(); List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; arr1.length; i++)&#123; list1.add(arr1[i]); &#125; for(int i = 0; i &lt; arr2.length; i++)&#123; list2.add(arr2[i]); &#125; int b1 = list1.size(); int b2 = list2.size(); if(b1 &gt; b2)&#123; for(int k = 0; k &lt; (b1 - b2); k++)&#123; list2.add(\"0\"); &#125; &#125; if(b1 &lt; b2)&#123; for(int k = 0; k &lt; (b2 - b1); k++)&#123; list1.add(\"0\"); &#125; &#125; int result = 0; for(int m = 0; m &lt; list1.size(); m++)&#123; if(Integer.valueOf(list1.get(m)) &gt; Integer.valueOf(list2.get(m)))&#123; result = 1; break; &#125; if(Integer.valueOf(list1.get(m)) &lt; Integer.valueOf(list2.get(m)))&#123; result = -1; break; &#125; &#125; return result; &#125;&#125; 注意事项 先将字符串按“.”分割。 将分割后数组每个元素装入ArrayList并补齐长度。 依次比较两个list中的每个元素即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#155]","slug":"leetcode-155","date":"2016-06-09T15:26:39.000Z","updated":"2018-12-12T16:08:23.005Z","comments":true,"path":"2016/06/09/leetcode-155/","link":"","permalink":"http://www.gcidea.info/2016/06/09/leetcode-155/","excerpt":"","text":"题目 Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. ExampleMinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; Returns -3.minStack.pop();minStack.top(); –&gt; Returns 0.minStack.getMin(); –&gt; Returns -2. 解决方案123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MinStack &#123; private List&lt;Integer&gt; list; private int min = 2147483647; /** initialize your data structure here. */ public MinStack() &#123; list = new ArrayList&lt;&gt;(); &#125; public void push(int x) &#123; list.add(x); if(list.size() == 1) &#123; min = x; &#125; else &#123; if(x &lt; min) min = x; &#125; &#125; public void pop() &#123; list.remove(list.size() - 1); if(list.size() &gt; 0)&#123; int tmp = list.get(0); for(int i = 1; i &lt; list.size(); i++)&#123; if(list.get(i) &lt; tmp)&#123; tmp = list.get(i); &#125; &#125; min = tmp; &#125; &#125; public int top() &#123; return list.get(list.size() - 1); &#125; public int getMin() &#123; return list.size() == 0 ? 0 : min; &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 注意事项 按照堆栈的定义依次实现各方法。 push()操作时，压入元素的同时要更新min的值；getMin()操作时，直接返回min的值；pop()操作时，弹出元素的同时要记得更新min的值。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#160]","slug":"leetcode-160","date":"2016-06-09T02:26:39.000Z","updated":"2018-12-12T16:08:22.608Z","comments":true,"path":"2016/06/09/leetcode-160/","link":"","permalink":"http://www.gcidea.info/2016/06/09/leetcode-160/","excerpt":"","text":"题目 Write a program to find the node at which the intersection of two singly linked lists begins. Example:the following two linked lists:A: a1 → a2 ↘ c1 → c2 → c3 ↗B: b1 → b2 → b3 begin to intersect at node c1. 解决方案12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode result = null; if(headA == null || headB == null) return result; ListNode h1 = new ListNode(0); ListNode h2 = new ListNode(0); h1.next = headA; h2.next = headB; LinkedHashSet&lt;ListNode&gt; set = new LinkedHashSet&lt;&gt;(); while(h1 != null)&#123; set.add(h1); h1 = h1.next; &#125; while(h2 != null)&#123; if(set.add(h2) == false)&#123; result = h2; break; &#125; h2 = h2.next; &#125; return result; &#125;&#125; 注意事项 遍历其中任意一个链表，将所有元素都加入一个LinkedHashSet，再遍历另一个链表，也将每个元素依次加入该set，当add方法返回false时，说明该节点已经存在，也就是两个链表指向的公共节点，返回该节点即可。 以下方法理解起来更容易但并不可行，o(n^2)的复杂度会导致超时：1234567891011121314151617181920212223242526272829public static ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode result = null; if(headA == null || headB == null) return result; ListNode h1 = new ListNode(0); ListNode h2 = new ListNode(0); h1.next = headA; h2.next = headB; while (h1 != null)&#123; boolean intersection = false; while(h2 != null)&#123; if(h1.next == h2.next)&#123; intersection = true; result = h1.next; break; &#125; h2 = h2.next; &#125; if(intersection)&#123; break; &#125; h2 = new ListNode(0); h2.next = headB; h1 = h1.next; &#125; return result;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#142]","slug":"leetcode-142","date":"2016-06-07T10:26:39.000Z","updated":"2018-12-12T16:08:23.814Z","comments":true,"path":"2016/06/07/leetcode-142/","link":"","permalink":"http://www.gcidea.info/2016/06/07/leetcode-142/","excerpt":"","text":"题目 Given a linked list, return the node where the cycle begins. If there is no cycle, return null. 解决方案12345678910111213141516171819202122232425/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode p = head; HashSet&lt;ListNode&gt; arr = new HashSet&lt;&gt;(); while(p != null)&#123; if(arr.add(p) == false) &#123; return p; &#125; p = p.next; &#125; return null; &#125;&#125; 注意事项 在141题的基础上，这题就很简单了。141题中当arr.add(p)方法返回为false，说明该节点已经被记录过了，说明该节点被指向了2次，而这刚好正是循环的开始，那现在直接返回该节点即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#147]","slug":"leetcode-147","date":"2016-06-07T09:26:39.000Z","updated":"2018-12-12T16:08:23.400Z","comments":true,"path":"2016/06/07/leetcode-147/","link":"","permalink":"http://www.gcidea.info/2016/06/07/leetcode-147/","excerpt":"","text":"题目 Sort a linked list using insertion sort. 解决方案12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode insertionSortList(ListNode head) &#123; if(head == null) return head; //新建一个节点，指向头结点 ListNode root = new ListNode(0); root.next = head; ListNode p = head; ListNode q; ListNode r; while (p != null &amp;&amp; p.next != null) &#123; //如果顺序升序，则不作处理，P指针后移 if (p.val &lt;= p.next.val) &#123; p = p.next; &#125;else &#123; //否则断开当前节点后其后节点的连接，为p.next找到合适的位置并插入（方法是从头结点开始比大小） q = p.next; p.next = q.next; r = root; while (r.next.val &lt;= q.val) &#123; r = r.next; &#125; q.next = r.next; r.next = q; &#125; &#125; return root.next; &#125;&#125; 注意事项 数组的插入排序是很简单的，只需要两个循环进行遍历即可，常见的做法如下： 123456789101112public class Insertion&#123; public static void sort(a)&#123; int N = a.length; for(int i = 1; i&lt; N; i++)&#123; for(int j = i; j &gt; 0 &amp;&amp; a[j] &lt; a[j-1]; j--)&#123; int temp = a[j]; a[j] = a[j-1]; a[j-1] = temp; &#125; &#125; &#125;&#125; 而对于链表排序，由于链表不支持随机访问，因此这种“遍历”必须每次都从头结点开始，而不能逐一递减向前找合适的位置插入。 思路是：当发现两个大小关系异常的节点—前大A后小B，首先断开两个节点的链接，将前一个节点A指向后一个节点B之后的节点。然后从链表的头结点开始到较大节点A结束这段范围内（必然在这段范围），逐一和较小节点B进行比较，当发现某节点C的下一节点已经大于较小节点B，则将B插入到C后面即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#141]","slug":"leetcode-141","date":"2016-06-06T09:26:39.000Z","updated":"2018-12-12T16:08:24.209Z","comments":true,"path":"2016/06/06/leetcode-141/","link":"","permalink":"http://www.gcidea.info/2016/06/06/leetcode-141/","excerpt":"","text":"题目 Given a linked list, determine if it has a cycle in it. 解决方案12345678910111213141516171819202122232425/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode p = head; HashSet&lt;ListNode&gt; arr = new HashSet&lt;&gt;(); while(p != null)&#123; if(arr.add(p) == false) &#123; return true; &#125; p = p.next; &#125; return false; &#125;&#125; 注意事项 使用java中HashSet的特性：add(E e) 方法用于为指定的元素添加到这个组，如果它是不存在的，将新元素加入HashSet，并返回true；如果此set已经包含该元素，则调用设定不变，并返回false。 使用“双指针”的方法更快：1234567891011public boolean hasCycle(ListNode head) &#123; if(head==null) return false; ListNode walker = head; ListNode runner = head; while(runner.next!=null &amp;&amp; runner.next.next!=null) &#123; walker = walker.next; runner = runner.next.next; if(walker==runner) return true; &#125; return false;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#14]","slug":"leetcode-14","date":"2016-06-05T05:26:39.000Z","updated":"2018-12-12T16:08:24.604Z","comments":true,"path":"2016/06/05/leetcode-14/","link":"","permalink":"http://www.gcidea.info/2016/06/05/leetcode-14/","excerpt":"","text":"题目 Write a function to find the longest common prefix string amongst an array of strings. 解决方案1234567891011121314151617181920212223242526272829303132public class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; int N = strs.length; if(N == 0) return \"\"; if(N == 1) return strs[0]; StringBuilder builder = new StringBuilder(); for(int i = 0; i &lt; N - 1; i++)&#123; int len1 = strs[i].length(); int len2 = strs[i+1].length(); int commonLen = Math.min(len1,len2); StringBuilder temp = new StringBuilder(); for(int m = 0; m &lt; commonLen; m++)&#123; if(strs[i].charAt(m) == strs[i+1].charAt(m))&#123; temp.append(strs[i].charAt(m)); &#125; else &#123; break; &#125; &#125; int tempLen = temp.length(); int builderLen = builder.length(); if(i == 0)&#123; builder = temp; &#125; else &#123; if(tempLen &lt; builderLen)&#123; builder = builder.delete(tempLen, builderLen); &#125; &#125; &#125; return builder.toString(); &#125;&#125; 注意事项 依次比较数组中每两个元素的最长前缀。第一个和第二个元素的最长前缀默认保存入builder，从第二个和第三个元素的比较结果开始，如果最长前缀比builder长，则不做操作，因为更长的部分无法作为之前其他元素的前缀，对整体结果没有意义；如果最长前缀比builder短，则要将builder的长度缩短相应的位数，因为之前的最长前缀不能作为当前元素的前缀。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#13]","slug":"leetcode-13","date":"2016-06-04T14:26:39.000Z","updated":"2018-12-12T16:08:25.417Z","comments":true,"path":"2016/06/04/leetcode-13/","link":"","permalink":"http://www.gcidea.info/2016/06/04/leetcode-13/","excerpt":"","text":"题目 Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 解决方案12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Solution &#123; public int romanToInt(String s) &#123; int len = s.length(); int result = 0; if(s == null || len == 0) return 0; for(int i = 0; i &lt; len; i++)&#123; if(s.charAt(i) == 'M')&#123; result += 1000; &#125; else if(s.charAt(i) == 'V')&#123; result += 5; &#125; else if(s.charAt(i) == 'L')&#123; result += 50; &#125; else if(s.charAt(i) == 'D')&#123; result += 500; &#125; else if(s.charAt(i) == 'I')&#123; if(i == (len - 1))&#123; result += 1; &#125; else &#123; if(s.charAt(i+1) == 'I')&#123; result += 1; &#125; else &#123; result -= 1; &#125; &#125; &#125; else if(s.charAt(i) == 'X')&#123; if(i == (len - 1))&#123; result += 10; &#125; else &#123; if(s.charAt(i+1) == 'X' || s.charAt(i+1) == 'V' || s.charAt(i+1) == 'I')&#123; result += 10; &#125; else &#123; result -= 10; &#125; &#125; &#125; else if(s.charAt(i) == 'C')&#123; if(i == (len - 1))&#123; result += 100; &#125; else &#123; if(s.charAt(i+1) == 'C' || s.charAt(i+1) == 'L' || s.charAt(i+1) == 'X' || s.charAt(i+1) == 'V' || s.charAt(i+1) == 'I')&#123; result += 100; &#125; else &#123; result -= 100; &#125; &#125; &#125; &#125; return result; &#125;&#125; 注意事项 明确罗马数字表示方法： a. 共有I X C M V L D七种字符，分别代表1,10,100,1000,5,50,500b. 给定一串罗马数字，其代表的数字是各位数字求和，但有特殊情况：当数字为I,X,C时，如果后面的罗马数字代表的数据比当前位大，则当前位作为减数，否则正常作为加数。 根据上述规律遍历一遍字符串即可得到结果。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#125]","slug":"leetcode-125","date":"2016-06-04T01:26:39.000Z","updated":"2018-12-12T16:08:25.810Z","comments":true,"path":"2016/06/04/leetcode-125/","link":"","permalink":"http://www.gcidea.info/2016/06/04/leetcode-125/","excerpt":"","text":"题目 Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Example“A man, a plan, a canal: Panama” is a palindrome.“race a car” is not a palindrome. NoteHave you consider that the string might be empty? This is a good question to ask during an interview. For the purpose of this problem, we define empty string as valid palindrome. 解决方案12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public boolean isPalindrome(String s) &#123; int len = s.length(); if(s == null || s.length() == 0) return true; StringBuilder builder1 = new StringBuilder(); StringBuilder builder2 = new StringBuilder(); s = s.toLowerCase(); boolean result = true; for(int i = 0; i &lt; len; i++)&#123; if(isDigitOrLetter(s.charAt(i)))&#123; builder1.append(s.charAt(i)); &#125; &#125; for(int j = len-1 ; j &gt;= 0; j--)&#123; if(isDigitOrLetter(s.charAt(j)))&#123; builder2.append(s.charAt(j)); &#125; &#125; for(int k = 0; k &lt; builder1.length(); k++)&#123; if(builder1.charAt(k) != builder2.charAt(k))&#123; result = false; break; &#125; &#125; return result; &#125; private static boolean isDigitOrLetter(char s)&#123; if((s &gt;= 'a' &amp;&amp; s &lt;= 'z') || (s &gt;= 'A' &amp;&amp; s &lt;= 'Z') ||(s &gt;= '0' &amp;&amp; s &lt;= '9'))&#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; 注意事项 先处理特殊情况，字符串为空或者长度为零。 定义一个函数isDigitOrLetter()来判断某个字符是否是字母大小写+数字。 使用两个StringBuilder，分别从首尾遍历字符串，存储为字母大小写+数字的字符。 比较两个StringBuilder中内容是否一样即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#136]","slug":"leetcode-136","date":"2016-06-04T01:26:39.000Z","updated":"2018-12-12T16:08:25.000Z","comments":true,"path":"2016/06/04/leetcode-136/","link":"","permalink":"http://www.gcidea.info/2016/06/04/leetcode-136/","excerpt":"","text":"题目 Given an array of integers, every element appears twice except for one. Find that single one. 解决方案123456789101112131415161718import java.util.Hashtable;public class Solution &#123; public int singleNumber(int[] nums) &#123; int result = 0; Hashtable&lt;Integer, Integer&gt; table = new Hashtable&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; if(!table.containsKey(nums[i]))&#123; table.put(nums[i], 1); &#125; else &#123; table.put(nums[i], table.get(nums[i]) + 1); &#125; &#125; for(int k = 0; k &lt; nums.length; k++)&#123; if(table.get(nums[k]) == 1) result = nums[k]; &#125; return result; &#125;&#125; 注意事项 遍历数组，以数字元素为key，出现次数为value，构造Hashset，找出value为1的key即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#122]","slug":"leetcode-122","date":"2016-06-03T11:26:39.000Z","updated":"2018-12-12T16:08:26.189Z","comments":true,"path":"2016/06/03/leetcode-122/","link":"","permalink":"http://www.gcidea.info/2016/06/03/leetcode-122/","excerpt":"","text":"题目 Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 解决方案1234567891011121314public class Solution &#123; public int maxProfit(int[] prices) &#123; int N = prices.length; if(prices == null || N == 0) return 0; int max = 0; for(int i = 0; i &lt; N -1; i++)&#123; if(prices[i+1] &gt; prices[i])&#123; max += (prices[i+1] - prices[i]); &#125; &#125; return max; &#125;&#125; 注意事项 题目描述可以多次买入卖出，那自然也可以当天同时有买入和卖出。 要总获益最大，只要保证每组“买入卖出”都有收益，且有尽量多组“买入卖出”。所以遍历一遍，只要后一个元素比前一个元素大，就做“买入卖出”。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#121]","slug":"leetcode-121","date":"2016-06-03T09:26:39.000Z","updated":"2018-12-12T16:08:26.622Z","comments":true,"path":"2016/06/03/leetcode-121/","link":"","permalink":"http://www.gcidea.info/2016/06/03/leetcode-121/","excerpt":"","text":"题目 Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example1:Input: [7, 1, 5, 3, 6, 4]Output: 5 max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example1:Input: [7, 6, 4, 3, 1]Output: 0 In this case, no transaction is done, i.e. max profit = 0. 解决方案1234567891011121314151617public class Solution &#123; public int maxProfit(int[] prices) &#123; int N = prices.length; if(prices == null || N == 0) return 0; int max = 0; int temp = prices[0]; for(int i = 1; i&lt;N; i++)&#123; if(prices[i] &gt; temp) &#123; max = prices[i] - temp &gt; max ? (prices[i] - temp) : max; &#125; else &#123; temp = prices[i]; &#125; &#125; return max; &#125;&#125; 注意事项 只进行一次遍历，temp变量始终指向当前位置遍历过的元素中的最小的。 如果当前元素大于temp,则考察两者之间的差是否比max变量中的值大，如果是，更新max值（max初始值为0，这样如果遍历完成时没有更大的，直接返回即可）。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#119]","slug":"leetcode-119","date":"2016-06-03T08:29:20.000Z","updated":"2018-12-12T16:08:27.045Z","comments":true,"path":"2016/06/03/leetcode-119/","link":"","permalink":"http://www.gcidea.info/2016/06/03/leetcode-119/","excerpt":"","text":"题目 Given an index k, return the kth row of the Pascal’s triangle. Example:given k = 3,Return [1,3,3,1]. 解决方案1234567891011121314151617181920212223public class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; zero = new ArrayList&lt;&gt;(); zero.add(1); if(rowIndex == 0) return zero; List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int i = 1; i &lt;= rowIndex + 1; i++)&#123; List&lt;Integer&gt; curr = new ArrayList&lt;Integer&gt;(); curr.add(1); for(int j = 1; j &lt; (i-1); j++)&#123; curr.add(result.get(i-2).get(j-1) + result.get(i-2).get(j)); &#125; if(i &gt; 1)&#123; curr.add(1); &#125; result.add(curr); &#125; return result.get(result.size()-1); &#125;&#125; 注意事项 在118题的基础上，本题只需要构建相应层数的杨辉三角，并返回最后一层的元素数组即可。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#118]","slug":"leetcode-118","date":"2016-06-02T08:28:20.000Z","updated":"2018-12-12T16:08:27.455Z","comments":true,"path":"2016/06/02/leetcode-118/","link":"","permalink":"http://www.gcidea.info/2016/06/02/leetcode-118/","excerpt":"","text":"题目 Given numRows, generate the first numRows of Pascal’s triangle. Example:given numRows = 5,Return [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 解决方案1234567891011121314151617181920public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; if(numRows == 0) return new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int i = 1; i &lt;= numRows; i++)&#123; List&lt;Integer&gt; curr = new ArrayList&lt;Integer&gt;(); curr.add(1); for(int j = 1; j &lt; (i-1); j++)&#123; curr.add(result.get(i-2).get(j-1) + result.get(i-2).get(j)); &#125; if(i &gt; 1)&#123; curr.add(1); &#125; result.add(curr); &#125; return result; &#125;&#125; 注意事项 构建杨辉三角，当输入层数为0时特殊处理 每一层至少有第一个元素1，从第二层开始，每层至少有最后一个元素1 从第三层开始，可以使用上一层“头顶”的两个元素求和。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#1]","slug":"leetcode-1","date":"2016-06-01T12:26:39.000Z","updated":"2018-12-12T16:08:28.251Z","comments":true,"path":"2016/06/01/leetcode-1/","link":"","permalink":"http://www.gcidea.info/2016/06/01/leetcode-1/","excerpt":"","text":"题目 Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example:Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Note:The return format had been changed to zero-based indices. Please read the above updated description carefully. 解决方案12345678910111213141516171819public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int N = nums.length; if(nums == null || N == 0) return new int[0]; int[] result = new int[2]; for(int i = 0; i&lt;N;i++)&#123; for(int j = i + 1;j&lt;N;j++)&#123; if(nums[i] + nums[j] == target)&#123; result[0] = i; result[1] = j; break; &#125; &#125; &#125; return result; &#125;&#125; 注意事项 两次循环遍历找到相应元素，属于暴力解法。 更优的解法考虑使用HashMap","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"leetcode [#104]","slug":"leetcode-104","date":"2016-06-01T08:28:20.000Z","updated":"2018-12-12T16:08:27.856Z","comments":true,"path":"2016/06/01/leetcode-104/","link":"","permalink":"http://www.gcidea.info/2016/06/01/leetcode-104/","excerpt":"","text":"题目 Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 解决方案12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public int maxDepth(TreeNode root) &#123; int depth = 0; if(root == null)&#123; return depth; &#125; else &#123; int l = 0; int r = 0; if(root.left != null)&#123; l = maxDepth(root.left); &#125; if(root.right != null)&#123; r = maxDepth(root.right); &#125; depth = l &gt; r ? l : r; return depth + 1; &#125; &#125;&#125; 注意事项 思路是递归，根据二叉树的结构，某个子节点是其子树的根节点，则不断反复进行递归直到找到叶子节点，返回为零，其余不断加1，累计总长度（左右子节点均相同处理）。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.gcidea.info/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.gcidea.info/tags/leetcode/"}]},{"title":"【转】HTTPS与SSL(下篇)","slug":"https-ssl-2","date":"2016-05-31T15:34:50.000Z","updated":"2018-12-12T16:08:42.669Z","comments":true,"path":"2016/05/31/https-ssl-2/","link":"","permalink":"http://www.gcidea.info/2016/05/31/https-ssl-2/","excerpt":"","text":"原文链接：http://www.jianshu.com/p/c03f47e7b9de#感谢原作者！(学长这个系列的文章已被“开发者头条APP”收录为头条文章)","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://www.gcidea.info/categories/HTTP/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"HTTP","slug":"HTTP","permalink":"http://www.gcidea.info/tags/HTTP/"},{"name":"转载","slug":"转载","permalink":"http://www.gcidea.info/tags/转载/"}]},{"title":"【转】HTTPS与SSL(上篇)","slug":"https-ssl-1","date":"2016-05-31T15:33:48.000Z","updated":"2018-12-12T16:08:43.070Z","comments":true,"path":"2016/05/31/https-ssl-1/","link":"","permalink":"http://www.gcidea.info/2016/05/31/https-ssl-1/","excerpt":"","text":"原文链接：http://www.jianshu.com/p/eafa5f19cb0b#感谢原作者！(学长这个系列的文章已被“开发者头条APP”收录为头条文章)","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://www.gcidea.info/categories/HTTP/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"HTTP","slug":"HTTP","permalink":"http://www.gcidea.info/tags/HTTP/"},{"name":"转载","slug":"转载","permalink":"http://www.gcidea.info/tags/转载/"}]},{"title":"JavaScript数组方法对比总结","slug":"js-array-method-sum-up","date":"2016-05-29T03:28:27.000Z","updated":"2018-12-12T16:08:39.357Z","comments":true,"path":"2016/05/29/js-array-method-sum-up/","link":"","permalink":"http://www.gcidea.info/2016/05/29/js-array-method-sum-up/","excerpt":"","text":"前言 本文对JavaScript中数组类型（Array）的常用方法进行总结，主要包括其API，使用示例和是否直接操作/修改原数组的分析。文章最后会对ECMAScript5中提供的数组方法进行小结。 join()作用 将数组元素衔接为字符串。参数 array.join() array.join(separator) separator： 在返回的拼接字符串中，用以连接原来数组元素的分隔符。如果缺省，默认英文逗号”,”。返回值 一个由separator连接的字符串。说明 该方法将一个数组的元素连接在一起成为字符串，也有相反的方法-split()，而这个方法是String类型的方法，不在这里的讨论范围之内。使用示例 在chrome的控制台中做如下操作： 是否直接操作/修改原数组 在上图示例基础上，打印原数组值： 由此可得： join()方法并未修改操作的数组本身。 reverse()作用 颠倒数组中元素顺序。参数 array.reverse()返回值 元素顺序调整后的数组。使用示例 在chrome的控制台中做如下操作： 是否直接操作/修改原数组 在上图示例基础上，打印原数组值： 由此可得： reverse()方法会直接修改操作的数组本身。 sort()作用 对数组元素进行排序。参数 array.sort() array.sort(orderfunc) orderfunc： 用来指定如何排序的可选函数。返回值 元素排序后的数组。说明 1.不带参数时，默认按字母顺序（准确说是字符编码顺序）进行排序； 2.orderfunc可以自定义排序方式，该函数接受两个参数，返回一个数字，根据数字与0的大小关系确定排序方式：1234//升序，m-n小于0，n大，表明m排在n前面function orderfunc(m,n) &#123; return m - n;&#125; 1234//降序，n-m小于0，m大，表明m排在n前面function orderfunc(m,n) &#123; return n - m;&#125; 使用示例 在chrome的控制台中做如下操作： 是否直接操作/修改原数组 在上图示例基础上，打印原数组值： 由此可得： sort()方法会直接修改操作的数组本身。 concat()作用 连接数组。参数 array.concat(value1, value2, ...) value1, value2, …： 要连接到数组中的元素。返回值 连接新元素后的数组。说明 1. 如果新连接的元素中任何一个自身就是数组，那么会将其每个元素依次进行连接（而不是将该数组元素作为一个独立的元素进行连接）。 2. 但是，如果某个新元素是一个数组，且这个数组中还有某些元素是数组，那么concat()方法并不会递归进行扁平化，也就是说： var a = [1,2,3]; a.concat(4,[5,[6,7]]); //会返回 [1,2,3,4,5,[6,7]] 使用示例 在chrome的控制台中做如下操作： 是否直接操作/修改原数组 在上图示例基础上，打印原数组值： 由此可得： concat()方法并未修改操作的数组本身。 slice()作用 获取数组的一部分。参数 array.slice(start, end) start： 数组片段的开始序号，如果为负数，则表示从尾部开始计算，即：-1表示最后一个元素，以此类推。 end： 数组片段的结束序号的后一个序号。如果未指定，则一直到末尾；如果为负数，则表示从尾部开始计算。返回值 数组片段-子数组。说明 如果想要移除数组的一部分，应使用splice()方法。使用示例 在chrome的控制台中做如下操作： 是否直接操作/修改原数组 在上图示例基础上，打印原数组值： 由此可得： slice()方法并未修改操作的数组本身。 splice()作用 插入，删除或者替换数组元素。参数 array.splice(start, deleteCount, value, ...) start： 开始插入/删除数组元素的位置序号。 deleteCount： 要删除的个数，从start开始（并且包含start）。如果为0，则表明不删除，直接插入。 value, …： 将要插入的零个或多个值。返回值 如果删除个数不为零，则返回被删除元素组成的数组；否则，返回空数组[]。使用示例 在chrome的控制台中做如下操作： 是否直接操作/修改原数组 在上图示例基础上，打印原数组值： 由此可得： splice()方法会直接修改操作的数组本身。 push()作用 给数组追加元素。参数 array.push(value, ...) value, …： 将要插入的零个或多个值。返回值 新数组的长度。使用示例 在chrome的控制台中做如下操作： 是否直接操作/修改原数组 在上图示例基础上，打印原数组值： 由此可得： push()方法会直接修改操作的数组本身。 pop()作用 移除数组的最后一个元素。参数 array.pop()返回值 被移除的最后一个元素。说明 如果数组已经为空，pop()不会修改数组，直接返回undefined。使用示例 在chrome的控制台中做如下操作： 是否直接操作/修改原数组 在上图示例基础上，打印原数组值： 由此可得： pop()方法会直接修改操作的数组本身。 unshift()作用 在数组头部插入元素。参数 array.unshift(value, ...) value, …：将要插入的零个或多个值。返回值 新数组的长度。使用示例 在chrome的控制台中做如下操作： 是否直接操作/修改原数组 在上图示例基础上，打印原数组值： 由此可得： unshift()方法会直接修改操作的数组本身。 shift()作用 移除数组的第一个元素。参数 array.shift()返回值 数组原来的第一个元素。说明 如果数组已经为空，shift()不会修改数组，直接返回undefined。使用示例 在chrome的控制台中做如下操作： 是否直接操作/修改原数组 在上图示例基础上，打印原数组值： 由此可得： shift()方法会直接修改操作的数组本身。 toString()作用 将原数组转换为字符串。参数 array.toString()返回值 数组的字符串表示。说明 如果调用该方法的对象不是Array，将会抛出TypeError异常。使用示例 在chrome的控制台中做如下操作： 是否直接操作/修改原数组 在上图示例基础上，打印原数组值： 由此可得： toString()方法并未修改操作的数组本身。 toLocaleString()作用 将原数组转换为本地字符串。参数 array.toLocaleString()返回值 数组的字符串表示。说明 1.如果调用该方法的对象不是Array，将会抛出TypeError异常。 2.toLocaleString()和toString()的区别在于，toLocaleString()会根据你机器的本地环境来返回字符串,它和toString()返回的值在不同的本地环境下使用的符号会有微妙的变化。这一点在时间转换上的区别比较明显： 在本机中文环境下： 而在英文环境下则可能会有不同的时间显示格式。使用示例 在chrome的控制台中做如下操作： 是否直接操作/修改原数组 在上图示例基础上，打印原数组值： 由此可得： toLocaleString()方法并未修改操作的数组本身。 ECMAScript5中新增数组方法 说明：以下方法侧重于在数组上进行更为复杂的操作，因此是否修改原数组不能一概而论，很大程度依赖于其中自定义函数的内容。 forEach()作用 为每一个数组元素调用一个函数。参数 array.forEach(f, o) f：为每个元素调用的函数 o：调用f时的this值（作用域，上下文环境）返回值 无 map()作用 根据给定的规则将原数组中每个元素重新计算。参数 array.map(f, o) f：为每个元素调用的函数 o：调用f时的this值（作用域，上下文环境）返回值 新数组，由f计算生成。 filter()作用 筛选通过断言的数组元素。参数 array.filter(predicate, o) predicate：为每个元素调用的函数 o：调用predicate时的this值（作用域，上下文环境）返回值 新数组，由predicate计算生成。 every()作用 测试断言函数是否对每个元素均为真。参数 array.every(predicate, o) predicate：为每个元素调用的函数 o：调用predicate时的this值（作用域，上下文环境）返回值 true：每个元素经过断言函数测试均为真。 false：有任意一个或更多元素元素经过断言函数测试为假。 some()作用 测试是否有元素满足断言函数。参数 array.some(predicate, o) predicate：为每个元素调用的函数 o：调用predicate时的this值（作用域，上下文环境）返回值 true：至少有一个元素经过断言函数测试均为真。 false：全部元素经过断言函数测试为假。 reduce()作用 从数组元素中计算出一个值。参数 array.reduce(f, inital) f：合并两个值的函数 o：可选初始值。返回值 数组化简后的一个值。 reduceRight()作用 从数组元素中计算出一个值(从右到左)。参数 array.reduceRight(f, inital) f：合并两个值的函数 o：可选初始值。返回值 数组化简后的一个值。 indexOf()作用 查找数组。参数 array.indexOf(value, start) value：将要查找的值 start：开始查找的数组序号。如果省略，则为零，从最开始查找。返回值 大于等于start的最小序号值。如果不存在，返回-1。 lastIndexOf()作用 反向查找数组。参数 array.lastIndexOf(value, start) value：将要查找的值 start：开始查找的数组序号。如果省略，从最后一个元素开始查找。返回值 小于等于start的最小序号值。如果不存在，返回-1。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"Cookie相关总结","slug":"cookie","date":"2016-05-27T09:35:08.000Z","updated":"2018-12-12T16:08:51.600Z","comments":true,"path":"2016/05/27/cookie/","link":"","permalink":"http://www.gcidea.info/2016/05/27/cookie/","excerpt":"","text":"前言 本篇简单总结cookie的概念，作用，应用，实现案例等要点，关于大段的介绍，就不再重复了，网上有很多可以参考。而且cookie相关是一个很大的话题，这里只是简单小结，主要包括： 1.cookie相关介绍 2.cookie安全性问题 3.javascript对cookie的操作与使用 4.cookie与session的对比分析 5.cookie在实际开发中的使用 直观感受 cookie是一种存储在用户本地的数据。比如在windows系统中使用chrome浏览器访问网站，相应的数据将保存在如下目录： C:\\Users\\gaochang\\AppData\\Local\\Google\\Chrome\\User Data\\Default 如图所示： 我们可以用一些第三方工具查看这个文件内容，比如chrome浏览器的一款插件cookies： 我们也可以在具体访问某个网站时，点击URL左边的“纸张/锁”图标，显示当前网站的cookie信息： cookie相关介绍定义 Cookie是由服务器端生成的，当用户访问服务器后，发送给User-Agent（一般指浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端在开发过程中自己定义，通过cookie服务器可以知道该用户是否是合法用户以及是否需要重新登录等，服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。 标准 cookie的规格标准文档主要有以下4种： 1.由网景公司颁布的规格标准 网景通信公司设计开发了cookie，并制定了相关的规格标准。1994年前后，cookie正式应用在网景浏览器中。目前最为普及的cookie方式也是以此为准的。 2.RFC2109 原本是想和网景公司的标准交互应用，可惜发生了微妙的差异。该标准现在已经淡出视线。 3.RFC2965 为终结IE浏览器与Netscape Navigator的标准差异而导致的浏览器战争，该标准定义了新的HTTP首部Set-Cookie2和Cookie2。可事实上，并未投入大量使用。 4.RFC6265 将网景公司制定的标准作为业界事实标准，重新定义cookie标准后的产物。 目前使用最广泛的cookie标准并不是上述中的某一个，而是在网景公司制定的标准上进行扩展后的产物。 编码 Cookies的值中可以保存除了“;”以外的标点符号。但是不能保存汉字。否则会出现乱码。所以对于Cookies中的内容要进行统一的编码和解码。为了在浏览器端和服务器端都能够进行解码和编码，可统一使用UTF-8编码格式。 javacript提供了内置的编码和解码函数，用来将非英文的字符编码或者解码。编码函数为“escape”,使用语法如下codedString=escape(originalString);其作用为，将参数字符串“originalString”中的特殊字符(绝大多数的非英文字母、非数字的字符)替换为”%”加上该字符Unicode编码的两位十六进制字符，或者“%u”加上该字符unicode编码的4位十六进制字符(视该字符的编码而定); 函数“un escape”与“escape”相反，用于将“escape”编码后的字符串还原为原始的字符串，其语法如下：originalString=unescape(codedString); 属性cookie主要的属性有： (1)name:Cookie名称，Cookie名称必须，一般用字母及数字，不能包含特殊字符，如有特殊字符需要转码。如js操作cookie的时候可以使用escape()对名称转码。 (2)value:Cookie值，Cookie值同理Cookie的名称，可以进行转码和加密。 (3)expire:过期日期，一个GMT格式的时间，当过了这个日期之后，浏览器就会将这个Cookie删除掉，当不设置这个的时候，Cookie在浏览器关闭(会话结束)后消失。 (4)path:一个路径，在这个路径下面的页面才可以访问该Cookie，一般设为“/”，以表示同一个站点的所有页面都可以访问这个Cookie。 (5)domain:子域，指定在该子域下才可以访问Cookie，例如要让Cookie在a.test.com下可以访问，但在b.test.com下不能访问，则可将domain设置成a.test.com。 (6)secure:安全性，指定Cookie是否只能通过https协议访问，一般的Cookie使用HTTP协议即可访问，如果设置了secure，则只有当使用https协议连接时cookie才可以被页面访问。 (7)httpOnly:如果在Cookie中设置了”HttpOnly”属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息。 分类cookie主要可以分为以下两类： Session cookies - these are temporary and are erased when you close your browser at the end of your surfing session. The next time you visit that particular site it will not recognise you and will treat you as a completely new visitor as there is nothing in your browser to let the site know that you have visited before. 会话cookie—这类cookie是短暂性的，是位于客户端所在系统的内存中的，当你的会话结束，关闭浏览器时，这类cookie将会被清空。当你下一次再访问该网站时，服务端并不能识别出你而是将你当做一个全新的用户，因为你的浏览器中没有任何可以让服务端判断你之前访问过的信息。（在设置了Discard参数(该参数是指当客户端程序运行结束时丢弃这个cookie。是RFC2965中新增字段，允许浏览器在退出时，不考虑过期时间，将cookie强制销毁)，或者没有明确设置的expires或Max-Age的情况下，创建的是一个会话cookie。）主要作用：根据名字也容易看出，主要是为了配合服务端session机制对用户进行标识。 Persistent cookies - these remain on your hard drive until you erase them or they expire. How long a cookie remains on your browser depends on how long the visited website has programmed the cookie to last. 持久cookie—这类cookie将保存在客户端所在设备的硬盘上（具体位置见本文开头直观感受部分），除非你主动删除它们或者它们过期了。这类cookie能在你的浏览器中保持有效多长时间，取决于你所访问网站为之设定的有效期。主要作用：持久化cookie则主要是进行用户特征的追踪，比如记录用户最初访问时间，用户习惯等。 限制 大多数浏览器支持最大为4096字节的 Cookie。浏览器还限制站点可以在用户计算机上存储的Cookie的数量。大多数浏览器只允许每个站点存储20个Cookie；注意这里的20个是指主键值，也就是20条Cookies记录，但是每个Cookies记录还可以包含若干子键。如果试图存储更多Cookie，则最旧的Cookie便会被丢弃。有些浏览器还会对它们将接受的来自所有站点的Cookie总数作出绝对限制，通常为300个。 传输 cookie信息在浏览器（客户端）和服务器端的传递是通过http报文头部来实现的。 HTTP请求报文的首部字段有“请求首部字段”，“通用首部字段”，“实体首部字段”3种；HTTP响应报文的首部字段有“响应首部字段”，“通用首部字段”，“实体首部字段”3种。具体到这里：为cookie服务的首部字段有： 首部字段名 说明 首部类型 Set-Cookie 开始状态管理所使用的Cookie信息 响应首部字段 Cookie 服务器接收到的Cookie信息 请求首部字段 下面具体来看一下两个字段： Set-Cookie示例：响应报文中的一段 Set-Cookie字段的属性有： 属性 说明 NAME=VALUE 赋予cookie的名称和值 expires=DATE cookie的有效期（若不明确指定则默认为浏览器关闭时） path=PATH 指明服务器上的哪些文件目录作为cookie的适用对象 domain=域名 作为cookie适用对象的域名 Secure 仅在HTTPS安全通信时才会发送cookie，无具体值，直接指定“secure”即可 HttpOnly 加以限制，使cookie不能被js等脚本访问，无具体值，直接指定“HttpOnly”即可 Cookie示例：请求报文中的一段 首部字段Cookie会告知服务器，当客服端想获得HTTP状态管理支持时，就会在请求头包含从服务器接收到的cookie。 案例 下面是《HTTP权威指南》中给出的一个关于“cookie与会话跟踪”的例子： 修改 其实cookie是不存在真正意义上的修改、删除操作的。要想修改，只需要在服务端新建一个同名cookie，填入http响应报文覆盖原来的cookie即可；要想删除，则只要在服务端新建一个同名cookie，并且设置maxAge为0，填入http响应报文覆盖原来的cookie即可。 作用 cookie的作用主要在于“绑定一种状态”，其工作机制是用户识别及状态管理。比如购物网站中，一定时间内可以直接登录，免去输入用户名密码的繁琐；可以根据浏览记录精准推荐感兴趣的商品；正确记录购物车中已有商品等等。 小结简单来讲，关于cookie记住3句话： 1.首次由服务端生成，放入set-cookie字段传回给客户端； 2.客户端请求报文首部加入该cookie； 3.服务端识别该cookie，从而确定用户身份。 cookie安全性问题 cookie在提供便利的同时，确实存在安全性问题，它可能被非法使用冒充身份。Cookie记录了用户的帐户ID、密码之类的信息，通常使用MD5方法加密后在网上传递。但是，Cookie以纯文本的形式在浏览器和服务器之间传送，很容易被他人非法截获和利用。并且截获者不需要知道这些字符串的含义，只要把别人的Cookie向服务器提交，且能够通过验证，就可以冒充受害人的身份登陆网站，这种行为就叫做Cookie欺骗。 httpOnly 上述cookie属性中的httpOnly是安全性的解决方案之一。设置为true后，JavaScript是无法获取cookie的，可防止XSS（跨站脚本攻击）等。详见如下演示：1.测试程序如下： 123456789&lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller &#123; public function index()&#123; setcookie(\"sid\", \"this is a cookie test\", NULL, NULL, NULL, NULL, false); $this-&gt;display(); &#125;&#125; 根据setcookie()函数的API：此时设置httpOnly的属性为false；客户端应该可以到sid=this is a cookie test这个cookie，验证代码：1234567&lt;script&gt; $(function()&#123; $(\"#cookieBtn\").click(function()&#123; alert(document.cookie); &#125;) &#125;)&lt;/script&gt; 点击“查看cookie信息”按钮，显示结果如下：结果符合预期。 现在更改为true，开启httpOnly:123456789&lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller &#123; public function index()&#123; setcookie(\"sid\", \"this is a cookie test\", NULL, NULL, NULL, NULL, true); $this-&gt;display(); &#125;&#125; 点击“查看cookie信息”按钮，显示结果如下：可以看出此时已经无法通过JavaScript获取cookie 但是，这种方式也还是有漏洞的，具体参见这篇文章：http://netsecurity.51cto.com/art/201404/435401.htm httpOnly作用只是限制从其他非HTTP的API（如JavaScript）访问，cookie还是有可能传递的过程中被监听捕获后信息泄漏。将 HttpOnly 属性设置为 true，并不能防止对网络频道具有访问权限的攻击者直接访问该 Cookie。针对这种情况，应考虑使用安全套接字层 (SSL) 来提供帮助。secure属性是防止信息在传递的过程中被监听捕获后信息泄漏。即：setcookie(&quot;sid&quot;, &quot;this is a cookie test&quot;, NULL, NULL, NULL, true, NULL);HttpOnly属性的目的是防止程序获取cookie后进行攻击。即：setcookie(&quot;sid&quot;, &quot;this is a cookie test&quot;, NULL, NULL, NULL, NULL, true); JavaScript对cookie的操作与使用（注：以下内容主要为引用。） 应用场景 JavaScript是运行在客户端的脚本，因此一般是不能够设置Session的，因为Session是运行在服务器端的。而cookie是运行在客户端的，所以可以用JS来设置cookie。假设有这样一种情况，在某个用例流程中，由A页面跳至B页面，若在A页面中采用JS用变量temp保存了某一变量的值，在B页面的时候，同样需要使用JS来引用temp的变量值，对于JS中的全局变量或者静态变量的生命周期是有限的，当发生页面跳转或者页面关闭的时候，这些变量的值会重新载入，即没有达到保存的效果。解决这个问题的最好的方案是采用cookie(本地文件)来保存该变量的值，那么如何来设置和读取cookie呢？首先需要稍微了解一下cookie的结构，简单地说：cookie是以键值对的形式保存的，即key=value的格式。各个cookie之间一般是以“;”分隔。 JS设置cookie12345function setCookie(c_name,value,expiredays)&#123; var exdate=new Date(); exdate.setDate(exdate.getDate()+expiredays); document.cookie=c_name+ \"=\" +escape(value)+((expiredays==null) ? \"\" : \"; expires=\"+exdate.toGMTString());&#125; JS获取cookie12345678910111213141516function getCookie(c_name)&#123; if (document.cookie.length&gt;0)&#123; c_start=document.cookie.indexOf(c_name + \"=\"); if (c_start!=-1)&#123; c_start=c_start + c_name.length+1; c_end=document.cookie.indexOf(\";\",c_start); if (c_end==-1) &#123; c_end=document.cookie.length; &#125; return unescape(document.cookie.substring(c_start,c_end)); &#125; &#125; else &#123; return \"\"; &#125; &#125; JS删除cookie12345678function delCookie(name)&#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); //删除cookie即设置expires为一个过去的时间 var cval=getCookie(name); if(cval!=null)&#123; document.cookie= name + \"=\"+cval+\";expires=\"+exp.toGMTString(); &#125;&#125; JS检查cookie123456789101112function checkCookie()&#123; username=getCookie('username'); if (username!=null &amp;&amp; username!=\"\")&#123; alert('Welcome again '+username+'!'); &#125;else &#123; username=prompt('Please enter your name:',\"\"); if (username!=null &amp;&amp; username!=\"\")&#123; setCookie('username',username,365); &#125; &#125;&#125; 注：jQuery库也提供了对cookie操作的封装。具体可参见http://www.php100.com/html/program/jquery/2013/0905/6028.html cookie与session的对比分析 关于session，则又是一大块内容。具体地将在后面的文章中单独总结。这里仅把一些资料中的对比内容加以总结。 1.Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。 2.不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。 3.客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。 4.当多个客户端执行程序时，服务器会保存多个客户端的Session。获取Session的时候也不需要声明获取谁的Session。Session机制决定了当前客户只会获取到自己的Session，而不会获取到别人的Session。各客户的Session也彼此独立，互不可见。 5.cookie和session的共同之处在于：cookie和session都是用来跟踪浏览器用户身份的会话方式。 6.cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session。 7.可将登陆信息等重要信息存放为session;其他信息如果需要保留，可以放在cookie中。 8.虽然Session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为Session需要使用Cookie作为识别标志。HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名称中包含类似“SESSIONID”字样的Cookie，它的值为该Session的id（也就是HttpSession.getId()的返回值）。Session依据该Cookie来识别是否为同一用户。该Cookie为服务器自动生成的，它的maxAge属性一般为–1，表示仅当前浏览器内有效，并且各浏览器窗口间不共享，关闭浏览器就会失效。因此同一机器的两个浏览器窗口访问服务器时，会生成两个不同的Session。但是由浏览器窗口内的链接、脚本等打开的新窗口除外，这类子窗口会共享父窗口的Cookie，因此会共享一个Session。（注意：新开的浏览器窗口会生成新的Session，但子窗口除外。子窗口会共用父窗口的Session。例如，在链接上右击，在弹出的快捷菜单中选择“在新窗口中打开”时，子窗口便可以访问父窗口的Session。） 9.我们知道，客户端浏览器是可以禁用Cookie的（或者可能就不支持Cookie）那么在这种情况下，为了使用session达到相应效果，就要使用另一种技术：URL地址重写。URL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户Session的id信息重写到URL地址中。服务器能够解析重写后的URL获取Session的id。这样即使客户端不支持Cookie，也可以使用Session来记录用户状态。 参考：http://www.cnblogs.com/shiyangxt/archive/2008/10/07/1305506.htmlhttp://blog.csdn.net/axin66ok/article/details/6175522http://blog.csdn.net/fangaoxin/article/details/6952954 cookie在实际开发中的使用 根据上述cookie与session的对比分析可知，实际应用中cookie要配合session使用才能更好保证安全性。因此具体开发中的应用将在session相关总结一文中一并分析。 总结 cookie相关内容十分丰富，这里只是对目前遇到的一些问题，根据网上已有资料和一些实际经验进行的总结，其中很多点都值得单独展开深入分析。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://www.gcidea.info/categories/HTTP/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"Cookie","slug":"Cookie","permalink":"http://www.gcidea.info/tags/Cookie/"}]},{"title":"使用JavaScript实现轮播图效果(JavaScript运动框架案例)","slug":"js-carousel","date":"2016-05-23T16:40:00.000Z","updated":"2018-12-12T16:08:36.895Z","comments":true,"path":"2016/05/24/js-carousel/","link":"","permalink":"http://www.gcidea.info/2016/05/24/js-carousel/","excerpt":"","text":"前言 轮播图组件是一种网站中常见的表现形式。常用于广告位，头条新闻等重要信息的展示而且将图片和信息结合起来，引人注意。轮播图最重要的自然是“轮播”，也就是要让页面中的DOM元素“动”起来。这就自然需要先简单提一下JavaScript的运动框架。 JavaScript运动框架简介 JavaScript运动框架就是指利用js和DOM元素配合，利用js的相关函数以一定的频率操作改变DOM元素的位置，这样形成的连续效果就是DOM元素的任意运动。通过元素透明度，路径，速度，加速度，大小，颜色，字体等等方面的改变，可以形成很多很炫的效果，但是这里只展示一个最简单的例子，只为了说明问题，涉及到了元素加速度，速度，路径，大小。 先展示一下基本的效果： 涉及到的几个要点是： 1.预先设计好想要的运动效果 2.合理使用setInterval()函数实现对元素的连续操作 3.使用clearInterval()及时清理不需要的计时器，防止多个计时器叠加导致运动混乱 4.“速度”的概念是通过setInterval()函数的执行间隔和指定的单位时间移动距离共同实现的 5.“加速度”的概念是通过将“一个固定的预定值”和“当前元素位置”的变化反映到速度上实现的 上述例子的完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;move&lt;/title&gt; &lt;script src=\"jquery-1.9.1.min.js\"&gt;&lt;/script&gt; &lt;!--简单设定元素样式--&gt; &lt;style&gt; #div1 &#123; border: 1px solid darkgray; border-radius: 5px; width: 200px; height: 50px; position: absolute; background-color: deepskyblue; margin-top: 5px; font-family: \"Microsoft YaHei\"; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"wrapper\"&gt; &lt;button id=\"btn\"&gt;点击演示&lt;/button&gt; &lt;div id=\"div1\"&gt;运动框架示例&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; /*声明定时器*/ var timer = null; $(function ()&#123; $(\"#btn\").click(function () &#123; clearInterval(timer); moveFramework($(\"#div1\"), 1000, 5); &#125;) &#125;) var timer = null; function moveFramework(element, moveTarget, speed) &#123; timer = setInterval(function () &#123; var left = $(\"#div1\").offset().left; /*速度大于零，向右运动*/ if(speed &gt;= 0)&#123; $(\"#div1\").html(\"运动框架--&gt;正向运动\"); $(\"#div1\").css(\"background-color\", \"deepskyblue\"); /*达到运动边界后，改变初始值，递归调用下一次的控制函数*/ if(left &gt;= moveTarget)&#123; clearInterval(timer); moveFramework(element, 0, -5); &#125; else &#123; /*加速度设置*/ speed = Math.ceil((moveTarget - left)/50); element.css(\"left\", left + speed + \"px\"); element.height(element.height() + 1); &#125; &#125; else &#123; /*速度小于零，向左运动*/ $(\"#div1\").html(\"运动框架反向运动\"); $(\"#div1\").css(\"background-color\", \"yellow\"); /*达到运动边界后，改变初始值，递归调用下一次的控制函数*/ if(left &lt;= moveTarget)&#123; clearInterval(timer); moveFramework(element, 1000, 5); &#125; else &#123; /*加速度设置*/ speed = Math.floor((moveTarget - left)/50); element.css(\"left\", left + speed + \"px\"); element.height(element.height() - 1); &#125; &#125; &#125;, 10); &#125; &lt;/script&gt;&lt;/html&gt; JavaScript轮播图组件实现过程原理 轮播图的实现充分结合了HTML+CSS+JavaScript。实现该效果并不是每点击一次“下一个”或者“上一个”就再去请求一张图片，而是渲染时一次性加载好所有内容，只不过为了实现这种动态轮播的效果，将其他图片做了隐藏，保证每次只展现一张。实现时，将一系列图片水平排列，通过父级元素宽度和overflow的设定，保证每次只看到一张，再通过JavaScript让元素动起来，定时修改包含一系列图片的容器的位置，实现轮播效果。更多原理的描述单靠文字会比较抽象，可以直接通过代码说明。 HTML基本结构 文档结构最主要的及部分如下： 1.图片列表 2.图片下方背景层 3.图片左下角描述信息列表 4.图片右下角序号列表 完整代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;title&gt;js轮播图组件&lt;/title&gt; &lt;script src=\"./js/jquery-1.9.1.min.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./css/carousel.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 最外层包裹 --&gt; &lt;div id=\"wrapper\"&gt; &lt;!-- 轮播图组件 --&gt; &lt;div id=\"banner\"&gt; &lt;!-- 图片列表 --&gt; &lt;ul class=\"imgList\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"./img/1.jpg\" alt=\"picture 1 图片描述\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"./img/2.jpg\" alt=\"picture 2 图片描述\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"./img/3.jpg\" alt=\"picture 3 图片描述\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"./img/4.jpg\" alt=\"picture 4 图片描述\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"./img/5.jpg\" alt=\"picture 5 图片描述\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 左右选择箭头 --&gt; &lt;img src=\"./img/left_arrow.png\" width=\"21px\" height=\"33px\" id=\"prev\"&gt; &lt;img src=\"./img/right_arrow.png\" width=\"21px\" height=\"33px\" id=\"next\"&gt; &lt;!-- 图片底部背景层--&gt; &lt;div class=\"bg\"&gt;&lt;/div&gt; &lt;!-- 图片左下方信息列表 --&gt; &lt;ul class=\"infoList\"&gt; &lt;li class=\"infoOn\"&gt;picture 1 图片描述&lt;/li&gt; &lt;li&gt;picture 2 图片描述&lt;/li&gt; &lt;li&gt;picture 3 图片描述&lt;/li&gt; &lt;li&gt;picture 4 图片描述&lt;/li&gt; &lt;li&gt;picture 5 图片描述&lt;/li&gt; &lt;/ul&gt; &lt;!-- 图片右下方序号列表 --&gt; &lt;ul class=\"indexList\"&gt; &lt;li class=\"indexOn\"&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=\"./js/carousel.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; CSS设计 在轮播图的实现中，CSS的作用除了设定更美观的字体，元素边框，颜色等以外，更重要的在于将图片排列在水平一行之中，并且对多余部分进行隐藏。 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/*整体清除margin padding*/body,div,ul,li,a,img &#123; margin: 0; padding: 0;&#125;/*设置列表及元素无修饰样式-指无序列表前的小方点或小圆点*/ul,li &#123; list-style: none;&#125;/*设置轮播图片大小*/.imgList img &#123; width: 800px; height: 400px;&#125;/*设置超链接无修饰样式-指下划线等*/a &#123; text-decoration: none;&#125;/*设置轮播图最外层包裹元素样式，为相对定位（这样子元素方便以绝对定位的方式相对wrapper进行定位），margin的auto可以保证元素自适应居中*/#wrapper &#123; position: relative; margin: 30px auto; width: 800px; height: 400px;&#125;/*设置轮播图组件的容器样式，重点在于overflow: hidden;正是它保证了多余图片隐藏，只显示一张*/#banner &#123; position:relative; width: 800px; height: 400px; overflow: hidden;&#125;/*设置图片列表的样式，每张图片宽800px,共5张图片，故总宽度800*5=4000px。*/.imgList &#123; position:relative; width:4000px; height:400px; z-index: 10; overflow: hidden;&#125;/*设置图片列表中每个元素-即每张图片的样式，向左浮动保证图片显示在一行*/.imgList li &#123; float:left;&#125;/*设置“前一张”、“后一张”按钮的样式，绝对定位，相对于最近的一个relative父级元素*/#prev,#next &#123; position: absolute; top:160px; z-index: 20; cursor: pointer; opacity: 0.8;&#125;/*单独设置一下“前一张”按钮距左边的距离*/#prev &#123; left: 10px;&#125;/*单独设置一下“后一张”按钮距右边的距离*/#next &#123; right: 10px;&#125;/*设置“前一张”、“后一张”按钮的伪类hover效果*/#prev:hover,#next:hover &#123; opacity: 0.9;&#125;/*设置图片下方背景区样式，绝对定位，相对于最近的一个relative父级元素；一定要设置透明度，更加美观*/.bg &#123; position: absolute; bottom: 0; width: 100%; height: 50px; z-index:20; opacity: 0.4; font-family: \"Microsoft YaHei\"; background: whitesmoke;&#125;/*设置图片左下方文字描述列表的样式*/.infoList &#123; position: absolute; left: 10px; bottom: 15px; z-index: 30;&#125;/*设置文字描述中每一个元素的样式，注意一定要设置display: none;，不然所有图片的文字描述会一次性全显示出来。后续通过js让其逐一显示*/.infoList li &#123; display: none; font-family: \"Microsoft YaHei\";&#125;/*设置当前正展示的图片的文字描述样式*/.infoList .infoOn &#123; display: inline; color: white;&#125;/*设置图片右下方序号列表的样式*/.indexList &#123; position: absolute; right: 10px; bottom: 10px; z-index: 30;&#125;/*设置序号列表中每一个元素的样式，向左浮动保证显示在一行*/.indexList li &#123; float: left; margin-right: 5px; padding: 2px 4px; border: 1px solid white; border-radius: 3px; background: grey; cursor: pointer; font-family: \"Microsoft YaHei\";&#125;/*设置序号列表中每一个元素的hover样式*/.indexList li:hover &#123; background:deepskyblue;&#125;/*设置当前正展示的图片的序号样式*/.indexList .indexOn &#123; background: greenyellow; font-weight: bold; color: orangered;&#125; JavaScript控制逻辑 JavaScript的控制逻辑本质上和前面提到的运动框架是一样的，完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * Created by gaochang on 2016/6/3. *///当前indexvar curIndex = 0;//图片总数var imgLen = $(\".imgList li\").length;// 定时器 每两秒切换一次var autoChange = setInterval(function()&#123; if(curIndex &lt; imgLen-1)&#123; curIndex ++; &#125;else&#123; curIndex = 0; &#125; //调用变换处理函数 changeTo(curIndex);&#125;,2000);//左箭头滑入滑出事件处理$(\"#prev\").hover(function()&#123; //滑入清除定时器，接着再去等待点击事件 clearInterval(autoChange);&#125;,function()&#123; //滑出则重置定时器，接着继续自动切换 autoChangeAgain();&#125;);//左箭头点击处理$(\"#prev\").click(function()&#123; //根据curIndex进行上一个图片处理 curIndex = (curIndex &gt; 0) ? (--curIndex) : (imgLen - 1); changeTo(curIndex);&#125;);//右箭头滑入滑出事件处理$(\"#next\").hover(function()&#123; //滑入清除定时器，接着再去等待点击事件 clearInterval(autoChange);&#125;,function()&#123; //滑出则重置定时器，接着继续自动切换 autoChangeAgain();&#125;);//右箭头点击处理$(\"#next\").click(function()&#123; curIndex = (curIndex &lt; imgLen - 1) ? (++curIndex) : 0; changeTo(curIndex);&#125;);//对右下角按钮index进行事件绑定处理等$(\".indexList\").find(\"li\").each(function(item)&#123; $(this).click(function()&#123; clearInterval(autoChange); changeTo(item); curIndex = item; autoChangeAgain(); &#125;)&#125;);//清除定时器时候的重置定时器--封装function autoChangeAgain()&#123; autoChange = setInterval(function()&#123; if(curIndex &lt; imgLen-1)&#123; curIndex ++; &#125;else&#123; curIndex = 0; &#125; //调用变换处理函数 changeTo(curIndex); &#125;,2000);&#125;function changeTo(num)&#123; var goLeft = num * 800; $(\".imgList\").animate(&#123; left: \"-\" + goLeft + \"px\", &#125;,500); $(\".infoList\").find(\"li\").removeClass(\"infoOn\").eq(num).addClass(\"infoOn\"); $(\".indexList\").find(\"li\").removeClass(\"indexOn\").eq(num).addClass(\"indexOn\");&#125; 效果展示 轮播图的效果如下： 可以扩展的地方 上述过程已经实现了基本的轮播图，但是还可以对效果进行丰富，可以考虑的方面比如：1.加上立体效果，如正在展示的图片加上倒影效果，且可以看到全部图片，只不过其他图片（除了正在展示的图片）都缩小/加毛玻璃效果等；2.在轮播图组件最下方增加全部图片缩略图预览，使得不仅可以点击序号，还可以直接点击某个缩略图到达具体对应的大图；","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"实现/应用","slug":"实现-应用","permalink":"http://www.gcidea.info/tags/实现-应用/"}]},{"title":"Restful风格的API","slug":"restful-api","date":"2016-05-21T16:17:05.000Z","updated":"2018-12-12T16:00:23.336Z","comments":true,"path":"2016/05/22/restful-api/","link":"","permalink":"http://www.gcidea.info/2016/05/22/restful-api/","excerpt":"","text":"关于restful API的设计是一个很重要的问题，这里给出3篇高质量的文章以供参考。RESTful 架构风格概述 RESTful API 编写指南 阮一峰 理解RESTful架构","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://www.gcidea.info/categories/HTTP/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"RestfulAPI","slug":"RestfulAPI","permalink":"http://www.gcidea.info/tags/RestfulAPI/"}]},{"title":"Array.prototype.slice.call()的典型应用","slug":"js-array-prototype-slice-call-arguments","date":"2016-05-19T04:40:47.000Z","updated":"2018-12-12T16:08:38.918Z","comments":true,"path":"2016/05/19/js-array-prototype-slice-call-arguments/","link":"","permalink":"http://www.gcidea.info/2016/05/19/js-array-prototype-slice-call-arguments/","excerpt":"","text":"作用 一句话来讲，这是一种将类数组对象转换为真正数组的方法。很多时候我们会遇到“类数组对象”，比如在操作DOM元素的时候，查询符合某种class的DOM节点会返回一个NodeList，它就是一个类数组对象。真正数组的很多成员方法不能直接用于类数组对象，因此就需要将其转换为真正的数组。 示例123456789Function.prototype.bind = function(context)&#123; var args = Array.prototype.slice.call(arguments, 1), self = this; return function()&#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return self.apply(context,finalArgs); &#125;;&#125;; 该例子是手动实现了一个具有基本功能的bind函数。这里不需要过多关注其细节（具体细节可参考这篇：JavaScript的call()、apply()、bind()方法对比总结），只需要关注：1234//...var args = Array.prototype.slice.call(arguments, 1),//...var innerArgs = Array.prototype.slice.call(arguments); 这两句即可。解释 call的作用是在指定的一个作用域上执行某函数。 arguments是javascript中函数的一个默认具有的属性，即参数列表，是一个类数组对象，此处需要将其转换为真正数组。 slice()方法作用域获取数组某个片段。并且它是数组的内置方法，那么必然在Array.prototype上。 至于call()函数传入的第二个参数，表明的是保留arguments的哪一部分，视具体需求而定。 调用slice()方法后返回的是一个副本，而原arguments并没有发生变化。 注意事项 这种将类数组对象转换为真正数组的方法已经从ES6开始正式废止。取而代之的应该使用新提供的方法：Array.from()来达到同样的效果。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"JavaScript双向选择器的实现","slug":"js-two-way-selector","date":"2016-05-16T14:16:16.000Z","updated":"2018-12-12T16:08:29.803Z","comments":true,"path":"2016/05/16/js-two-way-selector/","link":"","permalink":"http://www.gcidea.info/2016/05/16/js-two-way-selector/","excerpt":"","text":"前言 双向选择器是网站中经常使用的一种组件，适合于要求用户输入固定的一个或多个标签内容的场景，这种格式比普通input输入框的交互方式更加友好，而且可以防止因用户输入的随意性而导致的其他多余工作（比如表单验证）甚至错误。 效果 在说具体细节之前，可以先看一下效果，下图中就实现了一个最基本的双向选择器。 注意事项1.以上组件的编写没有基于原生的CSS，而是引入了AmazeUI框架，利用了框架提供的布局等样式，以下html代码中看到的以“am-”为前缀的class均是如此，具体的含义和使用方法可以参考AmazeUI官方文档。2.实际使用中，我们往往需要左侧的待选项可以动态可变，那就不能在页面上写死，应该在双向选择器渲染生成之前向后台请求数据，获取最新的待选项即可。而如下代码中仅作为示例，固定写了几个选项。 HTML结构 主要文档结构如下： 1234567891011121314151617181920212223242526&lt;div class=\"am-g\"&gt;&lt;div class=\"am-form-group am-u-sm-4 am-margin-left-sm am-margin-right-0 am-padding-right-0\"&gt; &lt;label&gt;待选项列表&lt;/label&gt;&lt;br /&gt; &lt;select multiple id=\"for-select\" style=\"height: 300px;\"&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; &lt;option&gt;选项4&lt;/option&gt; &lt;option&gt;选项5&lt;/option&gt; &lt;/select&gt;&lt;/div&gt;&lt;div class=\"am-form-group am-u-sm-1\"&gt; &lt;div class=\"am-text-center am-text-middle\"&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;a id=\"to-right\" style=\"cursor: pointer;\"&gt;&lt;i class=\"am-icon-angle-right am-icon-md\"&gt;&lt;/i&gt;&lt;/a&gt;&lt;br /&gt;&lt;br /&gt; &lt;a id=\"to-right-double\" style=\"cursor: pointer;\"&gt;&lt;i class=\"am-icon-angle-double-right am-icon-md\"&gt;&lt;/i&gt;&lt;/a&gt;&lt;br /&gt;&lt;br /&gt; &lt;a id=\"to-left\" style=\"cursor: pointer;\"&gt;&lt;i class=\"am-icon-angle-left am-icon-md\"&gt;&lt;/i&gt;&lt;/a&gt;&lt;br /&gt;&lt;br /&gt; &lt;a id=\"to-left-double\" style=\"cursor: pointer;\"&gt;&lt;i class=\"am-icon-angle-double-left am-icon-md\"&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"am-form-group am-u-sm-4 am-u-end am-margin-horizontal-0 am-padding-horizontal-0\"&gt; &lt;label&gt;已选项列表&lt;/label&gt;&lt;br /&gt; &lt;select multiple id=\"has-selected\" style=\"height: 300px;\"&gt; &lt;/select&gt;&lt;/div&gt;&lt;/div&gt; JavaScript控制逻辑 控制逻辑完整如下，基本的思想就是监听两个列表中每一项的点击事件，当触发点击事件后，遍历另一个列表中的选项，当无重复的情况下，将其从本列表中移除，添加至另一个列表中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118$(function()&#123; var leftSel = $(\"#\" + \"for-select\"); var rightSel = $(\"#\" + \"has-selected\"); //逐个向右 $(\"#\" + \"to-right\").bind(\"click\",function()&#123; leftSel.find(\"option:selected\").each(function()&#123; var tmp = $(this).val(); var lthis = $(this); var right = rightSel.find(\"option\"); var flag = 0; for(var i=0;i&lt;right.length;i++)&#123; if(tmp !== right[i].label)&#123; flag++; &#125; &#125; if(flag == right.length)&#123; lthis.remove().appendTo(rightSel); &#125; &#125;); &#125;); //全部向右 $(\"#\" + \"to-right-double\").bind(\"click\",function()&#123; leftSel.find(\"option\").each(function()&#123; var tmp = $(this).val(); var lthis = $(this); var right = rightSel.find(\"option\"); var flag = 0; for(var i=0;i&lt;right.length;i++)&#123; if(tmp !== right[i].label)&#123; flag++; &#125; &#125; if(flag == right.length)&#123; lthis.remove().appendTo(rightSel); &#125; &#125;); &#125;); //逐个向左 $(\"#\" + \"to-left\").bind(\"click\",function()&#123; rightSel.find(\"option:selected\").each(function()&#123; var tmp = $(this).val(); var rthis = $(this); var left = leftSel.find(\"option\"); var flag = 0; for(var i=0;i&lt;left.length;i++)&#123; if(tmp !== left[i].label)&#123; flag++; &#125; &#125; if(flag == left.length)&#123; rthis.remove().appendTo(leftSel); &#125;else &#123; rthis.remove(); &#125; &#125;); &#125;); //全部向左 $(\"#\" + \"to-left-double\").bind(\"click\",function()&#123; rightSel.find(\"option\").each(function()&#123; var tmp = $(this).val(); var rthis = $(this); var left = leftSel.find(\"option\"); var flag = 0; for(var i=0;i&lt;left.length;i++)&#123; if(tmp !== left[i].label)&#123; flag++; &#125; &#125; if(flag == left.length)&#123; rthis.remove().appendTo(leftSel); &#125;else &#123; rthis.remove(); &#125; &#125;); &#125;); //左侧待选记录的双击事件 leftSel.dblclick(function()&#123; leftSel.find(\"option:selected\").each(function()&#123; var tmp = $(this).val(); var lthis = $(this); var right = rightSel.find(\"option\"); var flag = 0; for(var i=0;i&lt;right.length;i++)&#123; if(tmp !== right[i].label)&#123; flag++; &#125; &#125; if(flag == right.length)&#123; lthis.remove().appendTo(rightSel); &#125; &#125;); &#125;); //右侧已选记录的双击事件 rightSel.dblclick(function()&#123; rightSel.find(\"option:selected\").each(function()&#123; var tmp = $(this).val(); var rthis = $(this); var left = leftSel.find(\"option\"); var flag = 0; for(var i=0;i&lt;left.length;i++)&#123; if(tmp !== left[i].label)&#123; flag++; &#125; &#125; if(flag == left.length)&#123; rthis.remove().appendTo(leftSel); &#125;else &#123; rthis.remove(); &#125; &#125;); &#125;);&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"实现/应用","slug":"实现-应用","permalink":"http://www.gcidea.info/tags/实现-应用/"}]},{"title":"CSS[内容盒模型]和[边框盒模型]的对比分析","slug":"css-contentbox-borderbox","date":"2016-05-16T13:10:24.000Z","updated":"2018-12-12T16:08:49.600Z","comments":true,"path":"2016/05/16/css-contentbox-borderbox/","link":"","permalink":"http://www.gcidea.info/2016/05/16/css-contentbox-borderbox/","excerpt":"","text":"盒模型概述 盒模型是CSS中的一个重要概念和组成部分，直接决定了页面的基本布局。下图是一张网上常见的关于CSS盒模型的立体图，很好的解释了盒模型中的基本概念。 不同种类和版本的浏览器对于width, height, padding, border, margin的解析有所不同，导致同样的CSS代码在不同浏览器上有不相同的效果。本文对此进行小结。 所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。 下面的图片说明了盒子模型基本结构(Box Model)： CSS中的box-sizing属性与盒子模型密切相关：1box-sizing : content-box|border-box|inherit; 内容盒模型(标准盒模型)取值1box-sizing : content-box; 概念 盒子的width只包含内容。 总元素的宽度=内容宽度+padding-left+padding-right+border-left+border-right+margin-left+margin-right 总元素的高度=内容高度+padding-top+padding-bottom+border-top+border-bottom+margin-top+margin-bottom 示例1234567.box &#123; width: 200px; height: 200px; border: 20px solid black; padding: 50px; margin: 50px;&#125; 边框盒模型(传统盒模型)1box-sizing : border-box; 概念 设置的width值其实是除margin外的border+padding+element的总宽度。盒子的width包含border+padding+内容。即总宽度=margin+width。根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，而内容周围的 padding 和 border 值是另外计算的。不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。虽然有方法解决这个问题。但是目前最好的解决方案是回避这个问题。也就是，不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素和子元素。IE8 及更早IE版本不支持 填充的宽度和边框的宽度属性设。解决IE8及更早版本不兼容问题可以在HTML页面声明 &lt;!DOCTYPE html&gt;即可。 示例1234567.box &#123; width: 200px; height: 200px; border: 20px solid black; padding: 50px; margin: 50px;&#125;","categories":[{"name":"CSS/CSS3","slug":"CSS-CSS3","permalink":"http://www.gcidea.info/categories/CSS-CSS3/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"CSS/CSS3","slug":"CSS-CSS3","permalink":"http://www.gcidea.info/tags/CSS-CSS3/"}]},{"title":"Session相关总结","slug":"session","date":"2016-05-13T09:35:17.000Z","updated":"2018-12-12T16:00:07.496Z","comments":true,"path":"2016/05/13/session/","link":"","permalink":"http://www.gcidea.info/2016/05/13/session/","excerpt":"","text":"前言 本篇简单总结session的概念，作用，应用，实现案例等要点，关于大段的介绍，就不再重复了，网上有很多可以参考。而且session相关是一个很大的话题，这里只是简单小结，主要包括以下几个大的方面： 1.直观感受 2.session相关介绍 3.session安全性问题 4.session的不同实现方式 5.cookie与session的对比分析 6.session在PHP开发中的使用 直观感受使用session进行状态保持的常用方法是服务端生成session对象的同时，在http响应报文首部通过set-cookie字段设置一个比如叫“PHPSESSID”的cookie以此进行唯一标识(但注意这不是唯一方法)，如下图所示： 当用户再次发起请求时，http请求报文首部携带这个cookie，用于服务端验证，如下图所示： session相关介绍定义 Session 允许通过将对象存储在 Web服务器的内存中在整个用户会话过程中保持任何对象。即“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求发起时，如果该用户还没有会话，则Web服务器将自动创建一个Session对象。当会话过期或被放弃后，服务器将终止该会话。Session对象最常见的一个用法就是存储用户的首选项。注意，会话状态仅在支持cookie的浏览器中保留。（这个的原因在“cookie相关总结”一文中cookie与session的对比分析中已经提到。） 需要明确的是，与cookie相比，Session是用于保持状态的基于服务端的解决方案。Session的工作机制是：为每个访客创建一个唯一的id(UID，名称中一般有类似“SESSID”字样)，并基于这个UID来存储变量。UID或者存储在cookie中(在cookie的协助下共同完成会话状态保持)，或者通过URL进行传递(URL重写)。也就是说，session方案实现不是一定需要有cookie的协助，反之亦然，两者是独立的。这样，服务器端在接到请求时候，就会收session ID，并根据ID在内存中找到之前创建的session对象，提供给请求使用。 要求 session通常用于保存客户端的状态信息，这些信息需要保存在服务器的硬盘上，所以要求session的属性值必须是可序列化的，否则将会引发不可序列化的异常。 session的生成时间 典型的错误认识：session在客户端访问时就会被创建。 事实上是直到某服务端程序显式调用session相关操作时才会被创建，比如在Java中调用HttpServletRequest.getSession(true);，或者使用ThinkPHP框架调用封装好的函数session(array(&#39;name&#39;=&gt;&#39;session_id&#39;,&#39;expire&#39;=&gt;3600));，再或者原生PHP中调用session_start();的时候。并且，访问静态资源时是不会创建session的。 session的存储方式 以PHP为例，session的存储方式主要有3中：文件存储、内存存储、自定义存储。默认是使用文件存储。具体配置方式如下：在D:\\code\\WampServer\\wamp64\\bin\\apache\\apache2.4.17\\bin目录下有php.ini文件，打开该文件，可找到如下片段： session.save_handler = files表明使用文件存储方式;session.save_path =&quot;D:/code/WampServer/wamp64/tmp&quot;则表明session文件的存储路径 主要就是需要配置这两个变量，这里都是默认配置。 于是，访问网站登陆后生成了自己的session，在此目录下，我们就可以看到一系列前缀为”sess_”的文件，这就是不同的session创建的对应文件： 说明：关于这个php.ini文件，目前还有一些不太理解的地方：在Apache的bin目录下D:\\code\\WampServer\\wamp64\\bin\\apache\\apache2.4.17\\bin有php.ini文件，而在PHP自身的目录下D:\\code\\WampServer\\wamp64\\bin\\php\\php5.6.16也有这个php.ini文件（以及php.ini-production php.ini-development文件） 那么如果要配置一些东西，到底是在哪个文件中配置生效呢？虽然结论是可知的，通过phpinfo可以看到如下信息：说明是Apache的bin目录下D:\\code\\WampServer\\wamp64\\bin\\apache\\apache2.4.17\\bin这个文件生效，但是这个Loaded Configuration File是从哪里配置的呢？还没有搞清楚。。。只是从php.ini文件的官方注释中获取了如下一些信息–关于PHP加载时寻找该文件的优先级排序：123456789101112131415161718;;;;;;;;;;;;;;;;;;;; About php.ini ;;;;;;;;;;;;;;;;;;;;; PHP&apos;s initialization file, generally called php.ini, is responsible for; configuring many of the aspects of PHP&apos;s behavior.; PHP attempts to find and load this configuration from a number of locations.; The following is a summary of its search order:; 1. SAPI module specific location.; 2. The PHPRC environment variable. (As of PHP 5.2.0); 3. A number of predefined registry keys on Windows (As of PHP 5.2.0); 4. Current working directory (except CLI); 5. The web server&apos;s directory (for SAPI modules), or directory of PHP; (otherwise in Windows); 6. The directory from the --with-config-file-path compile time option, or the; Windows directory (C:\\windows or C:\\winnt); See the PHP docs for more specific information.; http://php.net/configuration.file 普遍的说法是在Apache下conf目录下的httpd.conf文件中配置PHPIniDir，但我看了这个文件里面根本没有PHPIniDir。。。 另外，如果是搭建LAMP环境，使用了源码编译安装PHP的方式的话，可以用以下参数指定php.ini文件的位置，也就没有这个歧义了：--with-config-file-path=/usr/local/php/etc即使用类似如下命令：# ./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc session的销毁时间 典型的错误认识：只要关闭浏览器，session就消失了。 其实不然，除非程序主动通知服务器删除一个session，否则服务器会一直保留，程序一般都是在用户做“退出当前账户”的时候发出指令去删除session。然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分session机制都使用会话cookie来保存SESSID，而这种cookie是非持久的，保存在内存中，关闭浏览器后这个SESSID就消失了，再次连接服务器时也就无法找到原来的session。如果服务器设置的cookie被保存到硬盘上，或者使用某种手段改写浏览器发出的HTTP请求头，把原来的SESSID发送给服务器，则再次打开浏览器仍然能够找到原来的session。恰恰是由于关闭浏览器不会导致session被删除，使得服务器为seesion设置了一个失效时间，当距离客户端上一次使用session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间。 具体的session删除更新机制还有些复杂，不像上面说的时间一过就删除这么简单。关于session的销毁，还有一些问题—session销毁的“可能性”及垃圾回收： 在上文提到的D:\\code\\WampServer\\wamp64\\bin\\apache\\apache2.4.17\\bin目录下的php.ini文件中，有这样两个配置项： 大致的机制是这样的：由上述内容已经知道，session是有过期时间的，过期后将会被删除。但对于大型网站来讲，访问用户量巨大，为每个用户创建session是肯定的，但在如果过期时间一到，就删除那些过期session，从概率分布角度来说，服务端一定是经常要删除新一批到期的session。这无疑大大增加了系统的IO开销。因此，过期session是以一定概率进行垃圾回收的,这一定程度上保证了系统性能。具体来说，这个概率定义了每次新session初始化时启动垃圾回收进程的可能性。计算公式就是由上图中两个量相除得到：GC启动可能性 = gc_probability/gc_divisor比如说，gc_probability = 1，gc_divisor = 100，那么每次进行有访问请求后时，就有1%的可能性启动GC进程。而这个进程一旦启动，就会扫描指定的session临时文件夹，将过期的session文件删除。 但是，这里还是有一些问题，做如下操作：1.清空tmp文件夹，清空网站cookie，准备干净的环境进行对比。2.同时打开两个浏览器，模拟不同客户端的登录行为（这里不用一个浏览器的不同窗口，因为对不同的浏览器，不同窗口是否共用session好像没有统一的结论）3.写一个最简单的页面，比如就输出“123”，我们就是为了研究session现象，排除干扰。（对应MVC中的V）4.该页面对应的C也就是controller,只做两件事：启动session，渲染页面（关闭框架配置中的session自启动等，只用原生代码手动开启session）5.修改配置文件：设置 12gc_probability = 1;gc_divisor = 1; 让两者相等，使得GC启动可能性为1，确保一定会对过期session做操作，以此来研究session的变化。 6.在后台代码配置文件中声明： 1234//session配置&apos;SESSION_OPTIONS&apos; =&gt; array( &apos;expire&apos; =&gt; 10,), 设置session过期时间为10秒，即通过ThinkPHP框架配置文件的方式覆盖php.ini文件中的session.gc_maxlifetime = 1440(也可以直接在php.ini文件中修改) 探究—PHP中session的垃圾回收（GC）机制 session的生存周期 以上描述的session创建，存储，修改，销毁以及其中各种细节，就是session完整的生命周期了。 session安全性问题 cookie与session的对比分析 这一部分在cookie相关总结中已经提过。 session在PHP开发中的使用 实际开发中使用了ThinkPHP框架，框架提供了Session管理和操作的完善支持，全部操作可以通过一个内置的session函数完成，该函数可以完成Session的设置、获取、删除和管理操作。Session初始化设置方法无需手动调用，在Think\\App类的初始化工作结束后会自动调用，通常项目只需要配置SESSION_OPTIONS参数即可，SESSION_OPTIONS参数的设置是一个数组，支持的索引名和前面的session初始化参数相同。默认情况下，初始化之后系统会自动启动session，如果不希望系统自动启动session的话，可以设置SESSION_AUTO_START为false。 具体的：1.配置文件声明2.根据开发惯例结合ThinkPHP的写法，在MVC结构中，“C”即controller层应该有一个共用的基础controller即BaseController。考虑到用户会话保持是一个在访问整个网站中任意页面都需要的功能，因此session创建相关的内容非常合适（也只应该）放在BaseController中来完成。也就是说，BaseController应该具有全局（静态）方法is_login()用来判断用户是否登录，从而相应创建session，这样如果用户直接访问网站任意的子目录，由于继承了BaseController，都会做验证，保证了安全性。 但是，有一处比较特殊要注意，用户登录鉴权方法所在的controller（比如IndexController）是无法继承BaseController的。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://www.gcidea.info/categories/HTTP/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"Session","slug":"Session","permalink":"http://www.gcidea.info/tags/Session/"}]},{"title":"胖URL(fat url)","slug":"fat-url","date":"2016-05-11T09:35:28.000Z","updated":"2018-12-12T16:08:47.136Z","comments":true,"path":"2016/05/11/fat-url/","link":"","permalink":"http://www.gcidea.info/2016/05/11/fat-url/","excerpt":"","text":"前言 HTTP本身是匿名/无状态的请求/响应协议，为了能够进行客户端识别，发展出了很多种解决方案，胖URL就是其中一种用户识别机制，它是一种在URL中嵌入识别信息的技术。 定义 服务端可以通过为每个用户生成特定版本的URL来追踪用户身份。通常的做法是在URL开始或结束的地方增加一些状态信息。用户浏览站点时，web服务器会动态生成一些超链，继续维护URL中的状态信息。这种改动后的URL就被称为胖URL（fat url）。以下是《HTTP权威指南》中给出的一个例子：其中粗体的002-1145265-8016838就是一种特定的标识码。 机制 通过胖url，可以将服务器上若干个独立的HTTP事务捆绑成一个“会话”或者“访问”。用户首次访问时，会生成一个唯一的id，用服务器可以识别的方式将这个id添加到url中，然后服务器就会将浏览器重定向至这个新的url，不管什么时候，只要服务端接收到了对该胖URL的请求，就可以去查找那个用户相关的状态。 场景 服务器通常用重定向方式来重写URL，用于嵌入上下文，当客户端请求到达时，服务器会生成一个新的包含了嵌入式状态信息的URL，并将用户重定向到这个新的URL上去。客户端会跟随这个重定向信息访问新的URL，这次访问会带上经过增强的信息，这是在事务间维护状态的一种有效方式。这种经过增强的URL有时就可以称为“胖URL”。 缺点1.丑陋的URL 一串冗长的标识码破坏了url的基本结构。2.无法共享URL 胖URL中包含了用户相关的信息，因此如果将URL共享给别人，就有可能泄露个人信息。3.破坏缓存 为每个用户生成特定版本的URL意味着不再有可供公共访问的URL需要缓存了。4.额外的服务器负荷 主要指重写URL的负荷。5.逃逸口 当用户访问一个其他站点时，就很容易在无意之中“逃离”胖URL会话。只有用户严格追随预先修改过的链接时，胖URL才会工作。6.在会话期间非持久 除非用户收藏了特定胖URL，否则用户退出登录时，所有信息将会丢失。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://www.gcidea.info/categories/HTTP/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"HTTP","slug":"HTTP","permalink":"http://www.gcidea.info/tags/HTTP/"}]},{"title":"JavaScript中attribute(特性)和property(属性)的对比分析","slug":"js-attribute-property","date":"2016-05-10T13:04:38.000Z","updated":"2018-12-12T16:08:38.098Z","comments":true,"path":"2016/05/10/js-attribute-property/","link":"","permalink":"http://www.gcidea.info/2016/05/10/js-attribute-property/","excerpt":"","text":"前言 这是javascript对象中两个十分重要的概念。对象包含了多个属性（property）。每个属性有若干个特性（attribute）。具体而言，有数据属性和访问器属性两种。 数据属性 访问器属性","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"《JavaScript权威指南》中文版P204纠错","slug":"js-definitive-guide-error-p-204","date":"2016-05-10T05:30:03.000Z","updated":"2018-12-12T16:08:34.250Z","comments":true,"path":"2016/05/10/js-definitive-guide-error-p-204/","link":"","permalink":"http://www.gcidea.info/2016/05/10/js-definitive-guide-error-p-204/","excerpt":"","text":"中文版《JavaScript权威指南》第六版P204中，讲到使用构造函数定义类时，提到“Range()构造函数是通过new关键字调用的(在示例代码的末尾)”，如下图： 找了半天没看出来示例代码中到底是怎么通过new关键字调用的，于是，查看了一下原书第六版，如下图： 好吧，原来中文版这里出现了一点小错误，直接将前一页P203示例代码“用原型对象定义方法”中的代码粘贴过来了，怪不得找不到，= =。 从概念上讲，这是有很大不同的。是否使用new关键字创建实例对象，是工厂模式和构造函数模式创建对象的重要区别之一，详细可以参考《JavaScript高级程序设计(第3版)》P145。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"JavaScript的null和undefined对比总结","slug":"js-null-undefined","date":"2016-05-09T03:27:10.000Z","updated":"2018-12-12T16:08:31.795Z","comments":true,"path":"2016/05/09/js-null-undefined/","link":"","permalink":"http://www.gcidea.info/2016/05/09/js-null-undefined/","excerpt":"","text":"前言 说到这两个类型，首先应该从整体上明确一下JavaScript中提供的数据类型。 JavaScript中的数据类型分为两类：原始类型和对象类型。 其中，原始类型又可以细分为如下5类：数字，字符串，布尔值，null，undefined。 null和undefined都表示一种“空缺”的意思，但具体还有很多细节不同。 null类型检测对null使用typeof检测，可得： 说明 由以上结果可以看出，可以认为null是一种特殊的对象，表明了“非对象”这种概念。 undefined类型检测对undefined使用typeof检测，可得： 说明 undefined表明变量没有初始化。有以下几种常见情况的返回值是undefined： 如果一个元素不存在，那么在查询这个元素时会返回undefined。 如果一个函数没有返回值，那么默认返回的是undefined。 如果引用一个函数的某个形参值，但是这个形参却没有被赋予一个实参，那么会返回undefined。 综合分析 相等运算符认为二者是一样的： 严格相等运算符才能看出二者不同： 这两个类型是没有属性或者方法的（它们是基本类型，但没有对应的包装类型）：","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"《JavaScript 权威指南》P147的一处分析","slug":"js-definitive-guide-p-147","date":"2016-05-07T11:41:01.000Z","updated":"2018-12-12T16:08:33.797Z","comments":true,"path":"2016/05/07/js-definitive-guide-p-147/","link":"","permalink":"http://www.gcidea.info/2016/05/07/js-definitive-guide-p-147/","excerpt":"","text":"情景 在《JavaScript权威指南 第六版 中文版》P147，讲到稀疏数组时，书中给出如下的分析和例子： 读完后感觉第一个红框和第二个红框中的表述不是很清楚，有些矛盾。于是在chrome浏览器的控制台进行测试，结果如下： 第一个红框对应结果 第二个红框对应结果 第三个红框对应结果也就是说实测结果与书中第一个红框中的蓝色小框表述相反：0 in a1输出的值是false。 分析 以下是《JavaScript: The Definitive Guide》原书第六版对应地方的原文：由此可以看出，原书中只有中文版截图中的第一个红框中的内容，而中文版在翻译时译者加上了后面两段话。猜测可能译者在浏览器中得到的结果也与原书不同，因而补上了两段话加以说明。 结论 中文版截图中，第二个红框中的运行结果是译者在新版浏览器环境中测试得出的。即对于最新的情况：当省略数组直接量中的值时，得到的数组也是稀疏数组，并且省略掉的值是不存在的。 中文版截图中，第三个红框中的说明表明：经译者测试，在旧版本浏览器中，[1,,3]和[1,undefined,3]是一样的，且对于省略的值，认为其是存在的（为undefined），因而作者写作时候用的是旧版浏览器，测试得出的结果是true。 只记这个结论：省略数组直接量中的值（写连续的逗号）与显式写明undefined是不同的—前者认为在该索引处没有元素，后者认为在该索引处有一个undefined元素。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"CSS相关单位(pt,px,PPI,DPI,em,rem)","slug":"conventional-unit","date":"2016-05-03T03:27:43.000Z","updated":"2018-12-12T16:08:52.003Z","comments":true,"path":"2016/05/03/conventional-unit/","link":"","permalink":"http://www.gcidea.info/2016/05/03/conventional-unit/","excerpt":"","text":"单位介绍 pt:磅（point），绝对单位，印刷行业常用，等于1/72英寸(即0.03526厘米，1英寸 = 2.54厘米)。 px:像素（pixel），相对长度单位，相对于显示器屏幕分辨率而言。 PPI:像素密度（Pixel Per Inch），每英寸所拥有的像素数量。因此PPI数值越高，即代表显示屏能够以越高的密度显示图像。当然，显示的密度越高，拟真度就越高。 DPI:点数密度（Dots Per Inch）,每英寸所拥有的点数。是打印机、鼠标等设备分辨率的单位。这是衡量打印机打印精度的主要参数之一，一般来说，该值越大，表明打印机的打印精度越高。比如戴尔显示器U2515的像素间距为0.216毫米，即DPI=117。（2.54/0.0216）但是在本文讨论中，只考虑在显示设备上的情况，不再区分PPI,DPI。 em:相对长度单位。相对于当前对象（父级）内文本的字体尺寸而言。它的值不是固定的，会继承父级元素的字体大小。任意浏览器的默认字体是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，常在css中的body选择器中声明font-size: 62.5%;，这就使1em变为 16px&times;62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将原来的px数值除以10，然后换上em作为单位即可。 rem:根元素大小（font size of the root element）。“em”是相对于其父元素来设置字体大小的，这样就会存在一个问题，进行任何元素设置，都有可能需要知道父元素的大小，在多次使用时，就会带来无法预知的连锁反应错误风险。而rem是相对于根元素，这样就意味着，我们只需要在根元素确定一个参考值。比如： 123html &#123;font-size: 62.5%;/*10 ÷ 16 × 100% = 62.5%*/&#125;body &#123;font-size: 1.4rem;/*1.4 × 10px = 14px */&#125;h1 &#123; font-size: 2.4rem;/*2.4 × 10px = 24px*/&#125; 换算关系 1pt = (DPI / 72)px DPI = PPI PPI = 屏幕对角线上的像素点数/对角线长度 = (√(屏幕横向像素点^2 + 屏幕纵向像素点^2))/对角线长度 1em = 16px(默认)","categories":[{"name":"CSS/CSS3","slug":"CSS-CSS3","permalink":"http://www.gcidea.info/categories/CSS-CSS3/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"CSS/CSS3","slug":"CSS-CSS3","permalink":"http://www.gcidea.info/tags/CSS-CSS3/"}]},{"title":"通用的HTML文档DOM树遍历函数","slug":"common-document-ergodic-function","date":"2016-05-01T06:13:51.000Z","updated":"2018-12-12T16:08:52.397Z","comments":true,"path":"2016/05/01/common-document-ergodic-function/","link":"","permalink":"http://www.gcidea.info/2016/05/01/common-document-ergodic-function/","excerpt":"","text":"前言 本篇记录《JavaScript权威指南》中提供的通用性的DOM结构遍历函数，这是十分常用的场景，可以获取除了Text节点以外的全部文档节点。 实现parent函数 返回元素e的第n层祖先元素，如果不存在则返回null 如果n===0；返回e本身；n===1，返回父节点，以此类推123456function parent(e, n) &#123; if (n === undefined) n = 1; while(n-- &amp;&amp; e) e = e.parentNode; if (!e || e.nodeType !== 1) return null; return e;&#125; sibling函数 返回元素e的第n个兄弟元素 n&gt;0,返回后续元素 n&lt;0,返回x先前元素123456789101112131415161718192021function sibling(e,n) &#123; while(e &amp;&amp; n !== 0) &#123; // If e is not defined we just return it if (n &gt; 0) &#123; // Find next element sibling if (e.nextElementSibling) e = e.nextElementSibling; else &#123; for(e=e.nextSibling; e &amp;&amp; e.nodeType !== 1; e=e.nextSibling) /* empty loop */ ; &#125; n--; &#125; else &#123; // Find the previous element sibling if (e.previousElementSibing) e = e.previousElementSibling; else &#123; for(e=e.previousSibling; e&amp;&amp;e.nodeType!==1; e=e.previousSibling) /* empty loop */ ; &#125; n++; &#125; &#125; return e;&#125; child函数 返回元素e的第n个子元素，如果不存在则返回null 如果n===0；返回第一个子元素；n===-1，返回最后一个子元素，-2表示倒数第二个，以此类推123456789101112131415161718192021222324252627function child(e, n) &#123; if (e.children) &#123; // If children array exists if (n &lt; 0) n += e.children.length; // Convert negative n to array index if (n &lt; 0) return null; // If still negative, no child return e.children[n]; // Return specified child &#125; // If e does not have a children array, find the first child and count // forward or find the last child and count backwards from there. if (n &gt;= 0) &#123; // n is non-negative: count forward from the first child // Find the first child element of e if (e.firstElementChild) e = e.firstElementChild; else &#123; for(e = e.firstChild; e &amp;&amp; e.nodeType !== 1; e = e.nextSibling) /* empty */; &#125; return sibling(e, n); // Return the nth sibling of the first child &#125; else &#123; // n is negative, so count backwards from the end if (e.lastElementChild) e = e.lastElementChild; else &#123; for(e = e.lastChild; e &amp;&amp; e.nodeType !== 1; e=e.previousSibling) /* empty */; &#125; return sibling(e, n+1); // +1 to convert child -1 to sib 0 of last &#125;&#125;","categories":[{"name":"HTML/HTML5","slug":"HTML-HTML5","permalink":"http://www.gcidea.info/categories/HTML-HTML5/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"实现/应用","slug":"实现-应用","permalink":"http://www.gcidea.info/tags/实现-应用/"},{"name":"HTML/HTML5","slug":"HTML-HTML5","permalink":"http://www.gcidea.info/tags/HTML-HTML5/"}]},{"title":"JavaScript的闭包案例---2","slug":"js-closure-2","date":"2016-04-26T14:29:34.000Z","updated":"2018-12-12T16:08:36.469Z","comments":true,"path":"2016/04/26/js-closure-2/","link":"","permalink":"http://www.gcidea.info/2016/04/26/js-closure-2/","excerpt":"","text":"前言 接续之前的一篇JavaScript的闭包案例—1，加深对《JavaScript权威指南》P187的理解。 描述 使用闭包，可以实现共享私有状态，实现私有存取器属性。本质上就是在同一个作用域链上定义了两个或多个闭包，来共享同样的私有变量。这是十分重要的一种应用，但是要十分小心因为这种做法将那些本不希望共享的变量共享给了其他闭包，这会造成严重的错误并让我们不解。 假设有这样的需求：需要一个函数对象数组（数组每一项是一个函数），对于某个确定的数组元素，调用之可以返回数组下标。 “看似正确”的做法如下：1234567var funcs = [];for(var i=0;i&lt;10;i++)&#123; funcs[i] = function()&#123;return i;&#125;;&#125;console.log(funcs[5]()); //10 正如注释所写，很奇怪的，将打印输出10而并不是5。原因就在于：在循环中，定义了10个函数（对应有自己的作用域链），也就形成了10个闭包，这些闭包都是在同一个函数调用中定义的，因此共享作用域，共享变量i。for循环结束的条件是i&gt;=10。也就是说，当代码执行完成跳出for循环时，i的值是10。而这10个闭包的return i;所使用的正是这个共享的变量i，也就是10。因此，funcs[0]();~funcs[9]();执行的结果都是10。 对此，引用书上一句话进行总结： 关联到闭包的作用域链都是活动的，记住这一点非常重要。嵌套的函数不会将作用域内的私有成员复制一份，也不会对所绑定的变量生成静态快照（static snapshot）—而是共享了作用域变量。 对于上述需求，可采用以下两种方式解决： 123456789101112131415/** * Created by gaochang on 2016/5/30. */var funcs = [];for(var i=0;i&lt;10;i++)&#123; funcs[i] = (function(v)&#123; return function ()&#123; return v; &#125; &#125;(i));&#125;console.log(funcs[5]()); //5 以上方法用到了JavaScript中的“立即执行函数”的概念。注意这里funcs[i] = (function(v){这行的function左边的(括号是非常重要的。如果不写这个左圆括号，JavaScript解释器会尝试将关键字function解析为函数声明语句。只有用了左圆括号，才会正确将其解析为函数定义表达式，这在区分概念上很重要（注：试了一下，其实不写圆括号，结果也是对的，，但是尽管有时候没有必要也不应省略，这是习惯用法。）而一旦正确解析为函数定义表达式，也就相当于创建了新的闭包。匿名函数内的v外界不可访问，是独立的作用域，此时写为立即执行函数（传入i并执行），返回值就是正确无误的i,而不会是上述的10。 或者 1234567891011121314151617/** * Created by gaochang on 2016/5/30. */function constfunc(v)&#123; return function ()&#123; return v; &#125;&#125;var funcs = [];for(var i=0;i&lt;10;i++)&#123; funcs[i] = constfunc(i);&#125;console.log(funcs[5]()); 这种写法中，将对数组每个元素进行赋值的函数抽离出来，结构清晰的同时，也实现了函数作用域的转化（不在for循环内），也就是闭包范围的变化。这样，每次调用函数时，就创建了一个新的作用域链和新的私有变量，互相不会影响。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"闭包","slug":"闭包","permalink":"http://www.gcidea.info/tags/闭包/"}]},{"title":"setTimeout与setInterval的对比与互相实现","slug":"settimeout-setinterval","date":"2016-04-16T07:28:47.000Z","updated":"2018-12-12T16:00:25.728Z","comments":true,"path":"2016/04/16/settimeout-setinterval/","link":"","permalink":"http://www.gcidea.info/2016/04/16/settimeout-setinterval/","excerpt":"","text":"案例 setTimeout和setInterval对比 另外，根据网上一张关于此问题比较流行的图：1234567function click() &#123; // code block1... setInterval(function() &#123; // process ... &#125;, 200); // code block2 &#125; setInterval可能会存在的问题是：假设onclick回调函数一共要300ms执行完, block1代码执行完花了5ms, 在5ms时执行setInterval, 以此为一个时间点, 在205ms时插入process代码。当onclick回调函数顺利结束, process代码开始执行(即图中的timer code), 然而process代码也执行了一个比较长的时间, 超过了接下来一个插入时间点405ms, 这样代码队列后又插入了一份process代码, process继续执行着, 而且超过了605ms这个插入时间点，下面问题来了，可能你还会认为代码队列后面又会继续插入一份process代码，但真实的情况是,由于代码队列中已经有了一份未执行的process代码(405ms的), 所以605ms这个插入时间点将会被跳过, 因为js引擎只允许有一份未执行的process代码。 互相实现利用setTimeout实现setInterval 这个本文刚开始的案例就是一个例子，下面再给出一个：12345function f()&#123; console.log('setTimeout模拟setInterval，每秒钟打印一次'); setTimeout(f, 1000);&#125;setTimeout(f, 1000); 可以看到控制台每秒钟打印一次： 利用setInterval实现setTimeout12345function f()&#123; console.log('setInterval模拟setTimeout，只会打印一次，清除timer后停止'); clearInterval(timer);&#125;var timer = setInterval(f, 1000); 可以看到控制台只打印一次：","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"JavaScript的闭包案例---1","slug":"JavaScript-closure","date":"2016-04-16T06:05:10.000Z","updated":"2018-12-12T16:08:41.412Z","comments":true,"path":"2016/04/16/JavaScript-closure/","link":"","permalink":"http://www.gcidea.info/2016/04/16/JavaScript-closure/","excerpt":"背景 闭包是JavaScript中的一个重要概念。 JavaScript采用词法作用域，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这就是闭包的特性。","text":"背景 闭包是JavaScript中的一个重要概念。 JavaScript采用词法作用域，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这就是闭包的特性。 实际场景 在完成一个小demo时，正巧遇到了这个问题。先说一下这个demo要实现的基本功能吧。要求能让用户输入城市名称和对应的空气质量指数（输入的名称和指数都要做表单验证），输入完成后点击确定，将合法的数据显示在本页的列表中，可以增加多条记录。并且已添加的数据可以逐条删除。这里仅从功能展示，没有使用css美化页面： 在做删除功能时，按着想法先写了一遍，进行实际测试时候发现一个问题：对于最后一列的删除按钮，无论点击哪一个，都是列表中最后一条数据被删除了。 开始代码是这样写的：123456789101112131415161718192021222324252627282930313233343536373839/** * 渲染aqi-table表格 */function renderAqiList() &#123; var aqiTable = document.getElementById(\"aqi-table\"); aqiTable.innerHTML = \"\"; var t_row = document.createElement(\"tr\"); var t_city = document.createElement(\"td\"); var t_score = document.createElement(\"td\"); var t_oper = document.createElement(\"td\"); t_city.innerHTML = \"城市\"; t_score.innerHTML = \"空气质量\"; t_oper.innerHTML = \"操作\"; t_row.appendChild(t_city); t_row.appendChild(t_score); t_row.appendChild(t_oper); aqiTable.appendChild(t_row); //遍历对象中所有属性渲染表格 for (var name in aqiData)&#123; var newLi = document.createElement(\"tr\"); var cityName = document.createElement(\"td\"); var score = document.createElement(\"td\"); var oper = document.createElement(\"td\"); var delBtn = document.createElement(\"button\"); cityName.innerHTML = name; score.innerHTML = aqiData[name]; delBtn.innerHTML = \"删除\"; delBtn.setAttribute(\"city\", name); delBtn.onclick = function ()&#123; delBtnHandle(name); &#125;; oper.appendChild(delBtn); newLi.appendChild(cityName); newLi.appendChild(score); newLi.appendChild(oper); aqiTable.appendChild(newLi); &#125; return;&#125; 其中最关键的是给删除按钮绑定事件： 123delBtn.onclick = function ()&#123; delBtnHandle(name);&#125;; 这种做法想当然的认为，只要发生click事件时候，调用delBtnHandle()函数，并把要删除城市对应的name参数传递过去就好了，但在js中并不是这么执行的，这就要考虑到闭包的概念了。换做如下写法，问题就得到了解决。 1234567/*难点：js闭包的运用，防止出现以下错误：for循环时动态绑定，使得onclick 事件需要的name只能取到最后一个值而不是每一次遍历*/delBtn.onclick = function (asd) &#123; return function ()&#123; delBtnHandle(asd); &#125;&#125;(name);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"闭包","slug":"闭包","permalink":"http://www.gcidea.info/tags/闭包/"}]},{"title":"使用JavaScript实现数组去重的4种方法及性能比较","slug":"js-array-duplicate-removal","date":"2016-04-13T03:19:54.000Z","updated":"2018-12-12T16:08:39.790Z","comments":true,"path":"2016/04/13/js-array-duplicate-removal/","link":"","permalink":"http://www.gcidea.info/2016/04/13/js-array-duplicate-removal/","excerpt":"","text":"方法一思路：创建一个新的结果数组，遍历原数组，利用数组indexOf()方法，判断原数组当前值是否在结果数组中存在，如果存在则跳过，否则压入结果数组。12345678910 function removeDuplicatedItem(ar) &#123; var ret = []; for (var i = 0, j = ar.length; i &lt; j; i++) &#123; if (ret.indexOf(ar[i]) === -1) &#123; ret.push(ar[i]); &#125; &#125; return ret;&#125; 方法二利用数组下标判断。遍历该数组，使用indexOf()方法判断当前遍历的元素在整个数组中的下标是否等于当前下标。（因为indexOf()方法的原理是返回匹配中的第一个元素的下标，如果这个下标等于当前下标，说明这个元素在整个数组中第一次出现，就可以将其压入结果数组，否则说明是重复的，跳过。）1234567891011function removeDuplicatedItem(ar) &#123; var ret = []; ar.forEach(function(e, i, ar) &#123; if (ar.indexOf(e) === i) &#123; ret.push(e); &#125; &#125;); return ret;&#125; 方法三数组排序，并设置标记变量，用来标记当前结果数组中的最后一个元素。第一个元素没有重复的可能，压入结果数组，从第二个元素开始，遍历原数组，如果遍历的当前元素不等于标记变量，则将其压入结果数组。12345678910111213141516function removeDuplicatedItem(ar) &#123; var ret = [], end; ar.sort(); end = ar[0]; ret.push(ar[0]); for (var i = 1; i &lt; ar.length; i++) &#123; if (ar[i] != end) &#123; ret.push(ar[i]); end = ar[i]; &#125; &#125; return ret;&#125; 方法四构造一个新的结果数组，一个空对象。把数组元素作为对象属性，利用对象属性存在性来判断。如果对象中不存在该属性，则将该属性存入对象，同时将该元素压入结果数组，否则跳过。123456789101112function removeDuplicatedItem(ar) &#123; var tmp = &#123;&#125;, ret = []; for (var i = 0, j = ar.length; i &lt; j; i++) &#123; if (!tmp[ar[i]]) &#123; tmp[ar[i]] = 1; ret.push(ar[i]); &#125; &#125; return ret;&#125; 说明 以上四种方法的效率，第一、第二种方法效率接近且较低，均使用了indexOf()方法。第三种由js引擎内部将数组排序，优于前两种。最后一种效率最高，增加了hash对象用来存储数组元素，是空间换时间。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"jQuery的ajax()方法详细分析","slug":"ajax-param","date":"2016-04-11T09:23:24.000Z","updated":"2018-12-12T16:08:58.317Z","comments":true,"path":"2016/04/11/ajax-param/","link":"","permalink":"http://www.gcidea.info/2016/04/11/ajax-param/","excerpt":"","text":"前言 ajax，即“Asynchronous Javascript And XML”（异步JavaScript和XML），是一种异步加载数据的Web交互方法，在网页开发中使用十分普遍，实现局部刷新以达到更好的交互效果是ajax的典型应用。 核心 $.ajax(即jQuery.ajax),是jQuery库进行的一次封装。其核心实现是利用了JavaScript中的XMLHttpRequest对象。通过以下jQuery源码片段可以看出(jquery-2.2.0)： 12345jQuery.ajaxSettings.xhr = function() &#123; try &#123; return new window.XMLHttpRequest(); &#125; catch ( e ) &#123;&#125;&#125;; 关于XMLHttpRequest的更多属性、方法和演示，可以参考W3School XML DOM - XMLHttpRequest 对象。 分类 其实，$.ajax只是jQuery对异步加载封装的函数之一。jQuery对Ajax相关内容分为了4类： 全局Ajax事件处理函数（Global Ajax Event Handlers） 说明：这些函数定义了页面上任何特定ajax事件（比如初始化或完成）触发时将会被调用的处理程序。有： .ajaxComplete() 当ajax请求执行完成时触发，与.ajaxSuccess()不同，通过ajaxComplete()方法规定的函数会在请求完成时运行，即使请求并未成功。 .ajaxError() 当ajax请求执行错误时触发。 .ajaxSend() 当ajax请求将要发送时触发。 .ajaxStart() 当ajax请求将要发送时，jQuery将会检查此时是否有其他ajax请求正在进行。如果进程中没有，那么jQuery将会触发.ajaxStart()事件。 .ajaxStop() 当一个ajax请求执行完成时，jQuery将会检查此时是否还有其他ajax请求。如果没有了，jQuery将会触发.ajaxStop()事件。另外，如果上一个ajax请求的beforeSend()回调函数的返回值为false，也会触发.ajaxStop()事件。 .ajaxSuccess() 当ajax请求成功完成（无论何时）触发。此时，由.ajaxSuccess()方法定义的任何函数都会被执行。 注：jQuery ajax中各个事件执行顺序如下：1.ajaxStart(全局事件)2.beforeSend3.ajaxSend(全局事件)4.success5.ajaxSuccess(全局事件)6.error7.ajaxError (全局事件)8.complete9.ajaxComplete(全局事件)10.ajaxStop(全局事件) 辅助函数（Helper Functions） 说明：这些函数在执行ajax任务时起到辅助作用，对参数变量等进行一些转化处理。 .param() 这个函数是内部用来将表单元素值转换为序列化字符串表达式的。使用该函数将会把一个数组，空对象或者jQuery对象序列化成适合于URL查询或者ajax请求的形式。（键值对形式） .serialize() 使用该方法将会得到标准URL编码格式的字符串，可作用于已选择（或填写）确定值的jQuery对象。 .serializeArray() 该方法会返回JavaScript对象数组，可用于编码成JSON字符串，可作用于jQuery表单对象集合。 基础接口（Low-Level Interface） 说明：这些方法可用于编写任意的ajax请求。 .ajax() 使用该方法可发起一个异步HTTP请求。具体内容是本文重点，稍后单独描述。 .ajaxPrefilter() 该函数在请求被发出及执行$.ajax过程前，可定制ajax请求的选项或修改已有选项。 .ajaxSetup() 该函数用于定制后续将要使用的ajax请求的参数的默认值。该方法目前已不推荐使用。 .ajaxTransport() 该函数用于创建实际承载ajax数据传输的对象。 速写函数（Shorthand Methods） 说明：这些函数将更加常用的ajax请求抽出来，从而可以使用更简短的名字调用更明确的方法。 .get() 使用HTTP的GET请求从服务器获取数据。 .getJSON() 使用HTTP的GET请求从服务器获取JSON格式编码的数据。 .getScript() 使用HTTP的GET请求从服务器获取一个JavaScript文件，然后执行之。 .post() 使用HTTP的POST请求从服务器获取数据。 .load() 从服务器获取数据并且将返回的HTML代码放在匹配的元素中。 $.ajax()详细介绍描述：使用该方法可发起一个异步HTTP请求。version1.5 格式：jQuery.ajax( url [, settings ] )url 类型：String 该字符串所代表的URL即请求将要发送到的地方。settings 类型：PlainObject（PlainObject是一种包含0个或多个键值对的JavaScript对象，换句话说，就是“对象的对象”。之所以被称为“PlainObject”，是为了和其他类型的JavaScript对象作区分：比如说，null，用户自定义数组，或者宿主对象-document/window。这些对象使用typeof方法都会得到“Object”返回值。而对于PlainObject，则可以使用jQuery.isPlainObject()来判断是否成立。） settings中一系列的键值对集合配置了一个ajax请求。所有设置都是可选的。默认设置可以使用之前提到的.ajaxSetup()。下面的内容则针对所有的setting选项给出了详细解释。 version1.0 格式：jQuery.ajax( [ settings ] )settings的所有可选项：1.accepts(缺省：取决于DataType) 类型：PlainObject 是键值对的集合，将一种给定的dataType转化为对应的MIME type(MIME类型就是设定某种扩展名的文件用一种应用程序来打开的方式类型)。它将会在请求头中发送。这个头告诉服务器它需要什么类型的返回值。比如说，下面就定义了一种自定义类型：12345678910111213141516$.ajax(&#123; accepts: &#123; mycustomtype: 'application/x-some-custom-type' &#125;, // Instructions for how to deserialize a `mycustomtype` converters: &#123; 'text mycustomtype': function(result) &#123; // Do Stuff return newresult; &#125; &#125;, // Expect a `mycustomtype` back from server dataType: 'mycustomtype'&#125;); 注意：为了让accepts正常工作，必须配套声明converters。 2.async(缺省：true) 类型：Boolean 默认情况下，所有请求都是异步传送的，如果想要一个同步的请求，可以把该参数设置为false。跨域请求以及dataType为“jsonp”的请求不支持同步选项。值得注意的是，同步请求可能造成浏览器短时的“锁定”，在请求执行期间无法做出任何其他响应。在jQuery1.8版本中，对jqXHR使用async: false会引起过时声明；并且，你不能使用jqXHR的jqXHR.done()或者jqXHR.success()方法，相应的要使用success/error/complete回调参数选项才行。 3.beforeSend 类型：Function( jqXHR jqXHR, PlainObject settings ) 这是一个请求前回调函数，可以用来在请求发送之前修改jqXHR(在jQuery1.4.x版本中是XMLHTTPRequest对象)。如果返回值为false，将会取消该次请求。在jQuery1.5中，无论什么请求类型，beforeSend函数都会被调用。 4.cache(缺省：true，但当dataType为“script”或者“jsonp”时候，缺省值是false) 类型：Boolean 如果设置为false，将会强制浏览器不缓存请求的页面。注意：设置为false时，只在HEAD或者GET请求下能正确工作。它的工作方式是在GET请求参数后面拼接上“_={timestamp}”。 5.complete 类型：Function( jqXHR jqXHR, String textStatus ) 当一个请求完成后将会调用该函数（特别注意：是当success或者error回调函数执行完成后才调用该函数）。参数中的textStatus有”success”, “notmodified”, “nocontent”, “error”, “timeout”, “abort”, “parsererror” 这些种类。在jQuery1.5版本中，该选项还可以接收函数数组，其中的各个函数将会按顺序调用。 6.contents 类型：PlainObject 这个对象是“字符串/正则表达式”这样的键值对的集合，这决定了jQuery如何解析返回值，一般是鉴定content type。 7.contentType(缺省：’application/x-www-form-urlencoded; charset=UTF-8’) 类型：String 当给服务器发送数据时会使用这个参数指定的类型。默认值能很好地适用于大多数情况。如果你在$.ajax()中显示地写明了该参数，那么即使没有数据，也会给服务器发送数据。在jQuery1.6中，可以通过设置为false来告诉jQuery不要设置http请求头中的content type参数。注意：W3C的XMLHttpRequest规范规定，字符集总是UTF-8。因此指定其他字符集不会让浏览器强制转换编码方式。还要注意：对于跨域请求，如果contentType设置的不是application/x-www-form-urlencoded, multipart/form-data, or text/plain这三个中的一个，将会触发浏览器向服务器发送一个含有预检功能HTTP-OPTIONS方法的请求，用以判断实际发送的请求是否安全。 8.context 类型：PlainObject 这个参数指定的对象是ajax相关的所有回调函数的作用域。默认情况下，是一个代表着在调用中使用的ajax配置项的对象。比如，指定一个DOM元素作为context将会使得它（这个元素）成为complete这个回调函数的上下文环境（作用域），如下代码：123456$.ajax(&#123; url: \"test.html\", context: document.body&#125;).done(function() &#123; $( this ).addClass( \"done\" );&#125;); 9.converters(缺省：{“* text”: window.String, “text html”: true, “text json”: jQuery.parseJSON, “text xml”: jQuery.parseXML}) 类型：PlainObject 这是一个数据类型到数据类型转换的配置项，每个值都是一个函数，它返回响应值转换好的值。以上默认值表示： “* text”: window.String—调用String方法将任意内容转换为字符串。 “text html”: true—文本转换为HTML（true表示不需要转换，直接返回）。 “text json”: jQuery.parseJSON—调用jQuery.parseJSON方法将文本转换为JSON。 “text xml”: jQuery.parseXML—调用jQuery.parseXML方法将文本转换为XML。 10.crossDomain(缺省：同域请求为false，跨域请求为true) 类型：Boolean 设置为true后将允许服务端重定向至另一个域名。 11.data 类型：PlainObject 或 String 或 Array 这里设置的是将要发送给服务端的数据。如果不是一个字符串，将会被转换成查询字符串的形式。对于GET请求，它将会被添加在url尾部。可以参考“processData”这个选项来阻止这个自动的过程。给data设置的值必须是键值对形式。如果data的类型是array，那么如果序列化同键多值的元素，将取决于“traditional”这个配置项（下面将会讲述）。 12.dataFilter 类型：Function( String data, String type ) =&gt; Anything 这个是用来处理XMLHttpRequest原生响应数据的函数。有预处理净化响应的功能。你应该返回净化后的数据。函数接收两个参数，一个是服务器返回的原生数据，另一个是dataType参数指定的内容。 13.dataType(缺省：Intelligent Guess (xml, json, script, or html)) 类型：String 该参数指定你想要从服务器获取的数据类型。如果你没有指定，那么jQuery会尝试根据响应的MIME类型来推断。 (XML MIME type 将会输出XML, 在jQuery1.4中JSON将会输出一个JavaScript对象, script将会执行一段脚本, 其他任何类型将会作为字符串返回)，可选项（同时也是下面将要提到的success回调函数的第一个参数）有： “xml”:返回一个jQuery能够处理的XML文档。 “html”:将HTML作为纯文本返回，其中包含的标签将会在插入DOM元素时起作用。 “script”:将响应结果视为js代码执行，并且返回纯文本。默认情况下会通过在URL中附加查询字符串“_=[TIMESTAMP]”的方式来禁用缓存结果，除非显式设置了cache参数为true。注意: 在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。 “json”:将响应结果视为JSON进行解析，并且返回一个JavaScript对象。除非在请求参数中显式声明jsonp: false，否则跨域时写为“json”都会被转化为“jsonp”。JSON数据将会以严格方式进行解析，任何格式有误的JSON都会被拒绝并抛出错误。另外，在jQuery1.9中，空的返回值也是不被允许的，取而代之地，服务端必须返回一个null或者{} “jsonp”:以 JSONP 的方式载入 JSON 数据块。会自动在所请求的URL最后添加”?callback=?”。默认情况下会通过在URL中附加查询字符串“_=[TIMESTAMP]”的方式来禁用缓存结果，除非显式设置了cache参数为true。使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。 “text”: 指定返回纯文本字符串。 注：一种“多样，以空格分隔”的写法—在jQuery1.5中，jQuery可以对dataType进行转化，从请求头中Content-Type转化成你需要的形式。比如，如果你想让一个text响应被视作XML进行处理，那么dataType这个参数就可以写为”text xml”。再有，你也可以让一个返回JSONP类型数据的请求的响应被视为text进行接收，并且视为XML进行解析：”jsonp text xml”。类似的，可以使用”jsonp xml”简写,首先会尝试从jsonp到xml的转换，如果转换失败，就先将jsonp转换成text, 然后再由 text转换成xml。 14.error 类型：Function( jqXHR jqXHR, String textStatus, String errorThrown ) 如果请求失败将会调用此函数。该函数接收3个参数：第一个是jqXHR（jQuery1.4.x版本中是XMLHttpRequest）对象；第二个是描述错误类型的字符串；第三个是可选的异常对象。其中，第二个参数除了“null”以外的可能值有“timeout”，“error”，“abort”，“parsererror”。当发生一个HTTP错误时，第三个参数将会接收HTTP响应状态的文本部分，比如“Not Found”或“Internal Server Error”。在jQuery1.5版本中，该选项还可以接收函数数组，其中的各个函数将会按顺序调用。注意：该参数不会被跨域脚本或者跨域JSONP请求调用。 15.global(缺省：true) 类型：Boolean 该参数决定是否触发上文中分类里提到的第一类函数—全局Ajax事件处理函数（Global Ajax Event Handlers）。此参数可用来控制不同的ajax事件。 16.headers(缺省：{}) 类型：PlainObject 该参数附加的键值对将随使用XMLHttpRequest传输的请求一起发送。X-Requested-With: XMLHttpRequest总是会被添加上，但是它的默认值XMLHttpRequest在此可以改变。此处设置的值可以被beforeSend中的设置覆盖。 17.ifModified(缺省：false) 类型：Boolean 该参数将设置只有当上次请求的响应改变时，请求才能成功。这是通过检查HTTP响应报文中的Last-Modified字段实现的。默认值是false，忽略HTTP头信息。在jQuery1.4中，也会检查服务器指定的’etag’属性来确定数据没有被修改过。 18.isLocal(缺省：取决于当前的位置协议) 类型：Boolean 允许当前环境被认定为“本地”，（如文件系统），即使jQuery默认情况下不会这么做。以下协议目前公认为本地：file, *-extension和 widget。如果isLocal设置需要修改，建议在$.ajaxSetup()方法中这样做一次。 19.jsonp 类型：String 通过该参数可以在一个jsonp跨域请求中重写回调函数的名字。这个值用来替代在”callback=?”这种GET或POST请求中URL参数里的”callback”部分，比如说，{jsonp:&#39;onJSONPLoad&#39;}的结果就是传给服务器的该部分参数将会变成&#39;onJSONPLoad=?&#39;。在jQuery1.5版本中，设置jsonp为false将阻止jQuery向请求URL中添加 “?callback”或试图使用”=?”转换。在这种情况下，你还应该明确设置jsonpCallback参数。例如, { jsonp: false, jsonpCallback: “callbackName” }。如果你不信任ajax请求的接收服务器，那么考虑到安全因素应该将jsonp设置为false。 20.jsonpCallback 类型：String 或 Function() 为一个JSONP请求指明回调函数的名字。这个值将用来取代jQuery自动生成的随机函数名。这主要用来让jQuery生成一个独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。当你想让浏览器缓存GET请求时，可能会需要指明回调函数。在jQuery1.5中，还可以将此参数的值设置为一个函数，在这种情况下函数的返回值就是jsonpCallback的值。 21.method(缺省：“GET”) 类型：String 该参数指明HTTP请求将要使用的方法（比如“GET”,“POST”,“PUT”）。 22.mimeType 类型：String 该参数用来覆盖XHR的MIME类型。 23.password 类型：String 用于响应HTTP访问认证请求的密码。 24.processData(缺省：true) 类型：Boolean 默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型 “application/x-www-form-urlencoded”。如果要发送DOM文档信息或其它不希望转换的信息，请设置为false。 25.scriptCharset 类型：String 仅适用于当”script”传输使用时（例如，跨域的”jsonp”或 dataType选项为”script” 和 “GET”类型）。请求中使用在script标签上设置charset 属性。通常只在本地和远程的内容编码不同时使用。 26.statusCode(缺省：{}) 类型：PlainObject 一组数值的HTTP代码和函数对象，当响应中有对应的状态码时，相应的函数将会被调用。例如，如果响应状态是404，将触发以下警报： 1234567 $.ajax(&#123; statusCode: &#123; 404: function() &#123; alert( \"page not found\" ); &#125; &#125;&#125;); 如果请求成功，则状态码函数将会获得与success回调函数相同的参数；如果返回了错误（包括3XX重定向），则会获得与error回调函数相同的参数。 27.success 类型：Function( Anything data, String textStatus, jqXHR jqXHR ) 请求成功将会调用该函数，该函数有3个函数：第一个是data，如果请求中指明了dataType参数或者dataFilter回调函数，返回数据将会按照指定格式进行格式化；第二个是描述状态的字符串；第三个是jqXHR（jQuery1.4.x版本中是XMLHttpRequest）对象。在jQuery1.5版本中，该选项还可以接收函数数组，其中的各个函数将会按顺序调用。 28.timeout 类型：Number 设置请求超时时间（毫秒为单位）。此设置将覆盖$.ajaxSetup() 里的全局设置。超时时间的计算是根据$.ajax成功调用的时间，如果有其他请求正在进行并且浏览器没有可用连接，那么有可能一个请求在发送之前就已经超时了。在 jQuery 1.4.x 及更低版本中, 如果请求超时，XMLHttpRequest对象是处于无效状态;访问任何对象的成员可能会抛出一个异常。只有在 Firefox 3.0+,script 和 JSONP请求不会因超时而取消;即使是超时后到达的脚本也将运行。 29.traditional 类型：Boolean 如果你想要用传统的方式来序列化数据，那么就设置为true。 30.type(缺省：’GET’) 类型：String 是method的别名，如果使用jQuery1.9.0之前的版本，应使用type。 31.url(缺省：当前页URL) 类型：String 请求将要送达的地址。 32.username 类型：String 用于响应HTTP访问认证请求的用户名。 33.xhr(缺省：ActiveXObject (IE), XMLHttpRequest (其他)) 类型：Function() 用于重写或者提供一个增强的XMLHttpRequest 对象。 34.xhrFields 类型：PlainObject “文件名-文件值”对构成的对象，用于设定原生的 XHR对象。例如，如果需要的话，在进行跨域请求时，你可以用它来设置withCredentials为true。 123456$.ajax(&#123; url: a_cross_domain_url, xhrFields: &#123; withCredentials: true &#125; &#125;); 在 jQuery 1.5中， withCredentials属性不会传递给原生的XHR,从而对于需要使用此属性的CORS请求，则只能忽略这个属性。出于这个原因，应使用jQuery1.5.1以上版本。 注意事项 $.ajax()方法是jQuery中所有和ajax（异步请求）相关内容的基础。有时候我们不需要非得直接调用这个函数，因为有其他更高层一些的可选函数比如$.get()、.load()可供我们使用并且更易用。但是，如果有一些生僻的参数需要指定，还是$.ajax()更加灵活。$.ajax()是更加全面的，这也是为什么要深入讨论其每一个参数的目的。 在最简单的情况下，$.ajax()可以无参数使用：$.ajax();。注意：上述使用方式是无参的，默认参数的设定可以通过$.ajaxSetup()函数来指定。另外，这种无参的使用方法，对加载当前页面的内容，并且对这个内容没有任何操作。如果想使用这个结果，则可以自己写一个回调函数。 jqXHR对象 在jQuery1.5及以上版本中，由$.ajax()返回的jQuery XMLHttpRequest (jqXHR)是浏览器原生XMLHttpRequest的一个超集。比如说，它具有responseText、responseXML属性以及getResponseHeader()方法。当传输机制不是是XMLHttpRequest时（例如，一个JSONP请求脚本，返回一个 时），jqXHR对象尽可能的模拟原生的XHR功能。 在jQuery1.5.1及以上版本中，jqXHR对象还包含了overrideMimeType方法 (它在jQuery 1.4.x中是有效的，但是在jQuery 1.5中暂时的被移除)。.overrideMimeType()方法可用在beforeSend()的回调函数中，例如，修改响应的Content-Type信息头： 1234567891011 $.ajax(&#123; url: \"http://fiddle.jshell.net/favicon.png\", beforeSend: function( xhr ) &#123; xhr.overrideMimeType( \"text/plain; charset=x-user-defined\" ); &#125;&#125;) .done(function( data ) &#123; if ( console &amp;&amp; console.log ) &#123; console.log( \"Sample of data:\", data.slice( 0, 100 ) ); &#125; &#125;); 从 jQuery1.5开始，$.ajax()返回的jqXHR对象实现了Promise接口, 使它拥有了Promise的所有属性，方法和行为。当$.ajax()请求结束后，这些方法将有一个或多个函数作为参数传入。通常对于一个请求允许对多个回调函数进行赋值，甚至允许你在请求已经完成后，对回调函数进行赋值(如果该请求已经完成，则回调函数会被立刻调用)。 jqXHR.done(function( data, textStatus, jqXHR ) {}); 一个可供选择的 success 回调选项的构造函数，.done()方法取代了的过时的jqXHR.success()方法。 jqXHR.fail(function( jqXHR, textStatus, errorThrown ) {}); 一种可供选择的 error 回调选项的构造函数，.fail()方法取代了的过时的.error()方法。 jqXHR.always(function( data|jqXHR, textStatus, jqXHR|errorThrown ) { }); 一种可供选择的 complete 回调选项的构造函数，.always()方法取代了的过时的.complete()方法。 在响应一个成功的请求后，该函数的参数和.done()的参数是相同的：data, textStatus, 和 jqXHR 对象.对于失败的请求，参数和.fail()的参数是相同的：jqXHR 对象, textStatus, 和 errorThrown。 jqXHR.then(function( data, textStatus, jqXHR ) {}, function( jqXHR, textStatus, errorThrown ) {}); 包含了 .done() 和 .fail()方法的功能，（从 jQuery 1.8 开始）允许底层被操纵。 弃用注意：jqXHR.success(), jqXHR.error(), 和 jqXHR.complete()回调从jQuery 1.8开始被弃用。它们将最终被取消，应做好准备使用jqXHR.done(), jqXHR.fail(), 和 jqXHR.always() 代替。 12345678910111213141516171819// Assign handlers immediately after making the request,// and remember the jqXHR object for this requestvar jqxhr = $.ajax( \"example.php\" ) .done(function() &#123; alert( \"success\" ); &#125;) .fail(function() &#123; alert( \"error\" ); &#125;) .always(function() &#123; alert( \"complete\" ); &#125;); // Perform other work here ... // Set another completion function for the request abovejqxhr.always(function() &#123; alert( \"second complete\" );&#125;); this在所有的回调中所指向的引用，是上文提到的参数之一-context所指定的内容；如果没有指定context这个参数，那么this所引用的是Ajax配置项本身。 为了向后兼容XMLHttpRequest ，jqXHR对象暴露了下列属性和方法： readyState status statusText responseXML 和/或 responseText：视底层响应是xml还是text而不同。 setRequestHeader(name, value)：从标准出发，将旧值替换为新值，而不是将旧值和新值联系起来。 getAllResponseHeaders() getResponseHeader() statusCode() abort() 这里并没有提供onreadystatechange属性，因为所有可以想到的需求都可以通过done, fail, always, 和 statusCode来实现。 回调函数队列（Callback Function Queues） beforeSend, error, dataFilter, success 和 complete都可以接收（多个）适时调用的回调函数。从jQuery1.5开始， fail ， done ，和从jQuery 1.6开始的always回调钩子（hooks）采用先入先出队列管理。这意味着你可以为每个挂钩分配多个回调。 $.ajax()提供的回调hooks如下： beforeSend 在发送请求之前调用，它接收jqXHR对象和settings作为参数对象。 error 在请求出错时调用。它们接受jqXHR ，字符串表示的错误类型，以及异常对象（如果有的话）。一些内置的错误会将 “abort”, “timeout”, “No Transport” 等字符串作为异常对象。 dataFilter 在请求成功之后调用。传入返回的数据以及dataType参数的值。并且必须返回新的数据（可能是处理过的）传递给success回调函数。 success 当请求成功并接收到返回数据之后调用。传入返回后的数据，以及包含成功代码的字符串和jqXHR对象。 Promise callbacks—.done(), .fail(), .always(), 和 .then()，按注册顺序依次调用。 error 请求完成时，无论是在失败或成功，它们按顺序依次执行回调。他们收到jqXHR对象，以及一个包含成功或错误代码。 数据类型（Data Types） 不同类型的$.ajax()调用返回值在传递给success处理之前会交付给不同的预处理过程。至于交给哪种过程，默认是根据响应的Content-Type属性，但是也可以通过dataType属性显式声明。 可接受的类型有： text, html, xml, json, jsonp, 和 script. 如果指明了text或者html，将不会有预处理过程。数据只是简单地传递给了success处理程序，并且通过jqXHR对象的responseText属性也可以访问到。 如果指明了xml，那么在交付success处理之前，会先由jQuery.parseXML进行处理得到一个XMLDocument再传递。同时，这个XML文档通过jqXHR对象的responseXML属性也可以访问到。 如果指明了json，那么在交付success处理之前，会先由jQuery.parseJSON进行处理得到一个对象再传递。同时，这个XML文档通过jqXHR对象的responseJSON属性也可以访问到。 如果指明了script，那么在交付success处理之前，$.ajax()会直接执行从服务器接收到的脚本。 如果指明了jsonp，那么在交付success处理之前，$.ajax()会自动在URL后面拼接查询字符串callback=?。此时，$.ajax()的jsonp和jsonpCallback参数可以分别用于指明查询参数的名字和JSONP回调函数的名字。服务器应该返回合法的JavaScript传递给JSON响应回调函数。在将包含JSON对象的响应交付给success处理之前，$.ajax()会执行返回的JavaScript，并调用回调函数。 向服务器发送数据（Sending Data to the Server） 默认情况下，ajax方法使用HTTP的GET发送，如果需要POST，可以通过type参数指明。这个选项决定了data参数中的内容将以何种形式发送给服务器。由w3c标准可知，使用POST方法时，数据总是以UTF-8编码进行传送。 data参数的内容，既可以使用key1=value1&amp;key2=value2这种形式，也可以使用{key1: &#39;value1&#39;, key2: &#39;value2&#39;}这种形式。如果使用了后者，那么数据在发送之前将会使用jQuery.param()方法将之转化为查询字符串。如果想避免这种转化过程，可以将processData设置为false。如果想要给服务器发送XML对象，那么这种转化过程可能会出问题，这时候，最好把contentType=”application/x-www-form-urlencoded”换为其他更合适的MIME类型。 高级选项（Advanced Options） global选项用于阻止响应注册的回调函数，比如.ajaxSend(), .ajaxError()，以及类似的方法。这在有些时候很有用，比如发送的请求非常频繁且简短的时候，就可以在.ajaxSend()里禁用这个。跨域脚本和JSONP请求，全局选项自动设置为false。 如果服务器需要HTTP认证，可以使用用户名和密码可以通过 username 和 password 选项来设置。 Ajax请求是限时的，所以错误警告被捕获并处理后，可以用来提升用户体验。请求超时这个参数通常就保留其默认值，要不就通过$.ajaxSetup()来全局设定，很少为特定的请求重新设置timeout选项。 默认情况下，请求总会被发出去，但浏览器有可能从他的缓存中调取数据。要禁止使用缓存的结果，可以设置cache参数为false。如果希望判断数据自从上次请求后没有更改过就报告出错的话，可以设置ifModified为true。 scriptCharset允许给标签的请求设定一个特定的字符集，用于script 或者 jsonp类似的数据。当脚本和页面字符集不同时，这特别好用。 Ajax中的第一个字母“A”是指“asynchronous”，意味着操作是并行完成的且完成的顺序没有先后关系。$.ajax()方法的async参数默认是true，表明请求发送出去后代码还可以继续执行。将该参数设置为false是强烈不建议的，因为这可能在成浏览器无响应。 $.ajax()函数返回它创建的XMLHttpRequest对象。通常jQuery只在内部处理并创建这个对象，但用户也可以通过xhr选项来传递一个自己创建的xhr对象。返回的对象通常已经被丢弃了，但依然提供一个底层接口来观察和操控请求。比如说，调用对象上的.abort()可以在请求完成前挂起请求。 可扩展的Ajax（Extending Ajax） 对于jQuery1.5及以上版本，jQuery的ajax实现包含了prefilters, transports, 和 converters，这为你扩展ajax提供了极大地灵活性。 使用转换器（Using Converters） $.ajax()的转换器支持的数据类型映射到其它数据类型。但是，如果你想把自定义数据类型映射到一个已知的类型（json等）,必须通过contents选项在响应的Content-Type属性和实际的数据类型之间的添加一个相关的转换函数： 1234567891011 $.ajaxSetup(&#123; contents: &#123; mycustomtype: /mycustomtype/ &#125;, converters: &#123; \"mycustomtype json\": function( result ) &#123; // Do stuff return newresult; &#125; &#125;&#125;); 这个额外的对象是必要的 ，因为响应中的Content-Types和实际数据类型之间从未有过严格的一对一对应关系。 转换一个支持的类型（例如text, json）成自定义数据类型，然后再转换成另一个支持的类型，使用直通转换器：123456789101112$.ajaxSetup(&#123; contents: &#123; mycustomtype: /mycustomtype/ &#125;, converters: &#123; \"text mycustomtype\": true, \"mycustomtype json\": function( result ) &#123; // Do stuff return newresult; &#125; &#125;&#125;); 附加提醒 考虑到浏览器安全限制，大多数ajax请求遵循同源策略。请求不能成功从其他域名，子域名，端口或者协议获取数据。 script和JSONP请求不受同源策略限制。 总结 本篇详细总结了$.ajax()方法相关的方方面面。平时只是使用到了一种很少一部分参数，其实$.ajax()考虑到了这么多细节。本篇主要参考了jQuery官网的API文档，现在也有一些中文文档，但是其中有的翻译很晦涩。于是结合原文和这些中文翻译进行了重新整理，其中肯定有一些不清楚的或者错误的地方，还需要进一步发现。","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://www.gcidea.info/categories/jQuery/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://www.gcidea.info/tags/jQuery/"}]},{"title":"使用JavaScript实现非法输入字符实时过滤","slug":"invalid-char-filter","date":"2016-04-11T05:54:23.000Z","updated":"2018-12-12T16:08:41.837Z","comments":true,"path":"2016/04/11/invalid-char-filter/","link":"","permalink":"http://www.gcidea.info/2016/04/11/invalid-char-filter/","excerpt":"","text":"前言 表单提交是一项常见操作，对于输入内容的合法性必须在前后端都做验证才能保证可靠性。表单验证有很重要的意义，除了防止注入攻击之类的安全问题外，有时如果不能正确的进行验证，可能会使合法的页面渲染受到影响。比如在实际开发中遇到的一种问题，jsp页面使用JSTL库自定义标签渲染后台传来的数据时，需要将这组数据作为参数传入相应点击事件的回调函数，如果参数中一旦也有双引号”，就会导致解析错误—onclick属性值未能正常闭合。如下图所示： 解决 一般前端表单验证有以下几种方式： html5自带表单验证，如maxLength、min、max等 jQuery第三方验证库：jquery.validate.js 自定义正则表达式进行验证 一般的交互提示形式有以下几种： 随着输入结束表单元素（如输入框）失去焦点，旁边提示tip 点击确定提交表单时，弹出模态框提示有误 实时监测输入内容，对于非法输入直接过滤（即无法向输入框中输入这些非法字符） 本文采用： 自定义正则表达式 + 实时监测输入内容，对于非法输入直接过滤 html文件：1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script src=\"test.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;非法字符过滤&lt;/h1&gt;&lt;span&gt;请勿输入非法字符：~！!@#$^￥%…&amp;*()—+&#123;&#125;“”《》?？&lt;&gt;'\"&lt;/span&gt;&lt;input id=\"ind_name\" type=\"text\" placeholder=\"请输入指标名称\"/&gt;&lt;/body&gt;&lt;/html&gt; js文件：123456789/** * Created by gaochang on 2016/10/11. */$(function()&#123; $(\"#ind_name\").on(\"input propertychange\", function()&#123; var reg = /\\~|\\！|\\!|\\@|\\#|\\$|\\^|\\￥|\\%|\\…|\\&amp;|\\*|\\(|\\)|\\—|\\+|\\&#123;|\\&#125;|\\“|\\”|\\《|\\》|\\?|\\？|\\&lt;|\\&gt;|\\'|\\\"/g; $(\"#ind_name\").val($(this).val().replace(reg, \"\")); &#125;)&#125;) 说明 以上js代码中,使用了监听输入框值变化的标准方法oninput。oninput事件在IE9以下版本不支持，需要使用IE特有的onpropertychange事件替代。由于使用了jQuery，因此在输入框上直接绑定这两个事件即可。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"实现/应用","slug":"实现-应用","permalink":"http://www.gcidea.info/tags/实现-应用/"}]},{"title":"使用JavaScript实现短信重发倒计时","slug":"js-countdown","date":"2016-04-05T03:27:10.000Z","updated":"2018-12-12T16:08:34.691Z","comments":true,"path":"2016/04/05/js-countdown/","link":"","permalink":"http://www.gcidea.info/2016/04/05/js-countdown/","excerpt":"","text":"主要html结构以下html片段表示了重发倒计时组件的文档结构，依赖Amaze UI样式框架。 onclick=”btnSendMsgAgain();return false;”中的return false作用：验证码是位于form表单中的，点击该按钮的作用是发送验证码，而不是提交表单，return false为了彻底阻止元素的默认事件。 123&lt;div class=\"am-u-sm-4 am-margin-left-0 am-padding-left-0\"&gt; &lt;button id=\"getVerifyCodeAgain\" type=\"button\" class=\"am-btn am-margin-left-0\" onclick=\"btnSendMsgAgain();return false;\"&gt;发送验证码&lt;/button&gt;&lt;/div&gt; 效果 主要逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//短信重置密码-发送短信验证码function btnSendMsg()&#123; $.ajax(&#123; url: \"&#123;:U('forgetPasswordBySMS')&#125;\", type: \"GET\", async: true, data: &#123;username: $(\"#hiddenUsername-readyToSendMsg\").val()&#125;, dataType: \"json\", timeout: 10000, success: function(data)&#123; if(data.status=='success')&#123; $(\"#readyToSendMsg\").modal('close'); $(\"#hiddenUsername-resetPasswordBySMSbtn\").attr('value',data.username); $(\"#phone-resetPasswordBySMSbtn\").html(data.phone); $(\"#resetPasswordBySMSbtn\").modal(&#123; width: 500, height:400, closeViaDimmer: 0 &#125;) $(\"#resetPasswordBySMSbtn\").modal('open'); timeCountDown(); &#125; else &#123; alert(data.message); &#125; &#125;, error: function(XMLHttpRequest, textStatus, errorThrown) &#123; if(textStatus==\"timeout\")&#123; alert(\"请求超时，请检查网络连接设置\"); &#125; &#125; &#125;)&#125;function btnSendMsgAgain()&#123; timeCountDown(); $.ajax(&#123; url: \"&#123;:U('forgetPasswordBySMS')&#125;\", type: \"GET\", async: true, data: &#123;username: $(\"#hiddenUsername-readyToSendMsg\").val()&#125;, dataType: \"json\", timeout: 10000, success: function(data)&#123; if(data.status=='success')&#123; &#125; else &#123; alert(data.message); &#125; &#125;, error: function(XMLHttpRequest, textStatus, errorThrown) &#123; if(textStatus==\"timeout\")&#123; alert(\"请求超时，请检查网络连接设置\"); &#125; &#125; &#125;)&#125;var wait=60;function timeCountDown()&#123; if (wait == 0) &#123; $(\"#getVerifyCodeAgain\").removeAttr(\"disabled\"); $(\"#getVerifyCodeAgain\").html(\"发送验证码\"); wait = 60; &#125; else &#123; $(\"#getVerifyCodeAgain\").attr(\"disabled\", true); $(\"#getVerifyCodeAgain\").html(\"重新发送(\" + wait + \")\"); wait--; setTimeout(function() &#123; timeCountDown(); &#125;,1000) &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"实现/应用","slug":"实现-应用","permalink":"http://www.gcidea.info/tags/实现-应用/"}]},{"title":"使用JavaScript实现金额格式化转换","slug":"js-amount-format","date":"2016-04-05T03:27:10.000Z","updated":"2018-12-12T16:08:40.205Z","comments":true,"path":"2016/04/05/js-amount-format/","link":"","permalink":"http://www.gcidea.info/2016/04/05/js-amount-format/","excerpt":"","text":"前言 实现金额数字的每三位打”,”，便于识别金额大小。 实现12345678910111213//s: 希望转换的金额数字；n：希望保留的小数位数function formatMoney(s, n) &#123; n = n &gt; 0 &amp;&amp; n &lt;= 20 ? n : 2; //正则/[^\\d\\.-]/g表示去除传入字符串中非数字，非小数点，非负号以外的在金额中不应该出现的字符 s = parseFloat((s + \"\").replace(/[^\\d\\.-]/g, \"\")).toFixed(n) + \"\"; var l = s.split(\".\")[0].split(\"\").reverse(); var r = s.split(\".\")[1]; var t = \"\"; for(i = 0; i &lt; l.length; i ++ ) &#123; t += l[i] + ((i + 1) % 3 == 0 &amp;&amp; (i + 1) != l.length ? \",\" : \"\"); &#125; return t.split(\"\").reverse().join(\"\") + \".\" + r; &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"实现/应用","slug":"实现-应用","permalink":"http://www.gcidea.info/tags/实现-应用/"}]},{"title":"Javascript获取页面事件对象的getEvent函数兼容性写法","slug":"js-getevent","date":"2016-04-03T14:40:47.000Z","updated":"2018-12-12T16:08:32.874Z","comments":true,"path":"2016/04/03/js-getevent/","link":"","permalink":"http://www.gcidea.info/2016/04/03/js-getevent/","excerpt":"","text":"实践123456789101112131415161718function getEvent() &#123; if (document.all) &#123; var iEevent = window.event; iEevent.target = window.event.srcElement; return iEevent; &#125; var func = getEvent.caller; while (func != null) &#123; var arg0 = func.arguments[0]; if (arg0) &#123; if ((arg0.constructor == Event || arg0.constructor == MouseEvent) || (typeof(arg0) == \"object\" &amp;&amp; arg0.preventDefault &amp;&amp; arg0.stopPropagation)) &#123; return arg0; &#125; &#125; func = func.caller; &#125; return null;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"兼容性","slug":"兼容性","permalink":"http://www.gcidea.info/tags/兼容性/"}]},{"title":"HTML转义字符","slug":"html-character-entity","date":"2016-03-28T05:29:59.000Z","updated":"2018-12-12T16:08:44.337Z","comments":true,"path":"2016/03/28/html-character-entity/","link":"","permalink":"http://www.gcidea.info/2016/03/28/html-character-entity/","excerpt":"背景 HTML转义字符又称字符实体。一些字符在HTML中有特殊的含义，比如小于号”&lt;”已经用于定义HTML标签的开始。而这些标签在渲染出的html页面是不会显示出来的，如果我们希望浏览器正确地显示这些字符，我们必须在HTML源码中插入字符实体。 字符实体有三部分,而且有两种写法：","text":"背景 HTML转义字符又称字符实体。一些字符在HTML中有特殊的含义，比如小于号”&lt;”已经用于定义HTML标签的开始。而这些标签在渲染出的html页面是不会显示出来的，如果我们希望浏览器正确地显示这些字符，我们必须在HTML源码中插入字符实体。 字符实体有三部分,而且有两种写法： 一个和号(&amp;) + 一个实体名称 + 一个分号(;) 一个和号与一个井号(&amp;#) + 一个实体编号 + 一个分号(;) 比如，要在HTML文档中显示小于号，需要这样写：&amp;lt; 或者 &amp;#60; 使用实体名称的好处：名称相对来说更容易记忆。使用实体名称的坏处：并不是所有的浏览器都支持最新的实体名称，然而几乎所有的浏览器对实体编号的支持都很好。注意：实体对大小写敏感。 最常用的字符实体 显示 说明 实体名称 实体编号 半方大的空白 &amp;ensp; &amp;#8194; 全方大的空白 &amp;emsp; &amp;#8195; 不断行的空白格 &amp;nbsp; &amp;#160; &lt; 小于 &amp;lt; &amp;#60; &gt; 大于 &amp;gt; &amp;#62; &amp; &amp;符号 &amp;amp; &amp;#38; “ 双引号 &amp;quot; &amp;#34; © 版权 &amp;copy; &amp;#169; ® 已注册商标 &amp;reg; &amp;#174; ™ 商标（美国） &amp;trade; &amp;#8482; × 乘号 &amp;times; &amp;#215; ÷ 除号 &amp;divide; &amp;#247; / 正斜线 &amp;#47;","categories":[{"name":"HTML/HTML5","slug":"HTML-HTML5","permalink":"http://www.gcidea.info/categories/HTML-HTML5/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"HTML/HTML5","slug":"HTML-HTML5","permalink":"http://www.gcidea.info/tags/HTML-HTML5/"}]},{"title":"【转·译】编写不唐突的JavaScript(unobtrusive-javascript)的七条准则","slug":"seven-rules-of-unobtrusive-javascript","date":"2016-03-27T09:09:38.000Z","updated":"2018-12-12T16:00:31.246Z","comments":true,"path":"2016/03/27/seven-rules-of-unobtrusive-javascript/","link":"","permalink":"http://www.gcidea.info/2016/03/27/seven-rules-of-unobtrusive-javascript/","excerpt":"","text":"前言 “unobtrusive javascript—不唐突的JavaScript”最早是从《JavaScript权威指南》中看到，13.2节最先出现了这个概念。我认为也可以描述成“优雅的JavaScript”，指的是那些拥有良好的编码规范，易于维护的JavaScript写法和注意事项。进而在网上看到了这篇“编写不唐突的JavaScript(unobtrusive-javascript)的七条准则”，做以记录和分享。 原文内容不要做任何假设（JavaScript是一个不可靠的助手） 不要假设JavaScript是可用的，你最好认为它很有可能是不可用的，而不是直接依赖于它。 在你经过测试确认一些方法和属性可以使用之前，不要假设浏览器支持它们。 不要假设HTML代码如你想象的那样正确，每次都要进行检查，并且当其不可用的时候就什么也不要做。 让JavaScript的功能独立于输入设备。 要记住其他的脚本可能会影响你的JavaScript的功能，所以要保证你的脚本的作用域尽可能地安全。 在开始设计你的脚本之前，要考虑的第一件事情就是检查一下你要为其编写脚本的HTML代码，看看有什么东西可以帮助你达到目的。 找出钩子和节点关系（HTML是脚本的基石） 在开始编写脚本之前，要先看一下你要为之编写JavaScript的HTML。如果HTML是未经组织的或者未知的，那么你几乎不可能有一个好的脚本编写方案——很可能就会出现下面的情况：要么是会用JavaScript创建太多标记，要么就是应用太依赖于JavaScript。 在HTML中有一些东西需要考虑，那就是钩子和节点关系。(1) HTML 钩子 HTML最初的和最重要的钩子就是ID，而且ID可以通过最快的DOM方法——getElementById访问到。如果在一个有效的HTML文档中所有的ID都是独一无二的话（在IE中关于name和ID有一个bug，不过有些好的类库解决了这个问题），使用ID就是安全可靠的，并且易于测试，而且如果直接用name来作为对象进行操作，在FF下是无效的，会报此对象未定义的错误。 其他一些钩子就是是HTML元素和CSS类，HTML元素可以通过getElementsByTagName方法访问，而在多数浏览器中都还不能通过原生的DOM方法来访问CSS类。不过，有很多外部类库提供了可以访问CSS类名（类似于 getElementsByClassName） 的方法。 (2) HTML 节点关系 关于HTML的另外比较有意思的一点就是标记之间的关系，思考下面的问题： 要怎样才可以最容易地、通过最少的DOM遍历来到达目标节点？ 通过修改什么标记，可以尽可能多地访问到需要修改的子节点？ 一个给定的元素有什么属性或信息可以用来到达另外一个元素？ 遍历DOM很耗资源而且速度很慢，这就是为什么要尽量使用浏览器中已经在使用的技术来做这件事情。 把遍历交给专家来做 （CSS，更快地遍历DOM） 有关DOM的脚本和使用方法或属性（getElementsByTagName, nextSibling, previousSibling,parentNode以及其它）来遍历DOM似乎迷惑了很多人，这点很有意思。而有趣的是，我们其实早已经通过另外一种技术—CSS—做了这些事情。 CSS是这样一种技术，它使用CSS选择器，通过遍历DOM来访问目标元素并改变它们的视觉属性。一段复杂的使用DOM的JavaScript可以用一个CSS选择器取代：1234567891011121314151617var n = document.getElementById('nav'); if(n)&#123; var as = n.getElementsByTagName('a'); if(as.length &gt; 0)&#123; for(var i=0;as[i];i++)&#123; as[i].style.color = '#369'; as[i].style.textDecoration = 'none'; &#125; &#125; &#125; /* 下面的代码与上面功能一样 */ #nav a&#123; color:#369; text-decoration:none; &#125; 这是一个可以好好利用的很强大的技巧。你可以通过动态为DOM中高层的元素添加class或者更改元素ID来实现这一点。如果你使用DOM为文档的body添加了一个CSS类，那么设计师就很可以容易地定义文档的静态版本和动态版本。如下所示：12345678910111213141516171819JavaScript: var dynamicClass = 'js'; var b = document.body; b.className = b.className ? b.className + ' js' : 'js'; CSS: /* 静态版本 */ #nav &#123; ...&#125; /* 动态版本 */ body.js #nav &#123; ...&#125; 理解浏览器和用户（在既有的使用模式上创建你所需要的东西） 理解浏览器是如何工作的（尤其是浏览器是如何崩溃的）以及用户期望的是什么。不考虑浏览器你也可以很容易地使用JavaScript创建一个完全不同的界面。拖拽界面，折叠区域，滚动条和滑动块都可以使用JavaScript创建，但是这个问题并不是个简单的技术问题，你需要思考下面的问题： 这个新界面可以独立于输入设备么？如果不能，那么可以依赖哪些东西？ 我创建的这个新界面是否遵循了浏览器或者其它富界面的准则（你可以通过鼠标在多级菜单中直接切换吗？还是需要使用tab键？） 我需要提供什么功能但是这个功能是依赖于JavaScript的? 最后一个问题其实不是问题，因为如果需要你就可以使用DOM来凭空创建HTML。关于这点的一个例子就是“打印”链接，由于浏览器没有提供一个非JavaScript的打印文档功能，所以你需要使用DOM来创建这类链接。同样地，一个实现了展开和收缩内容模块的、可以点击的标题栏也属于这种情况。标题栏不能被键盘激活，但是链接可以。所以为了创建一个可以点击的标题栏你需要使用JavaScript将链接加入进去，然后所有使用键盘的用户就可以收缩和展开内容模块了。解决这类问题的极好的资源就是设计模式库。至于要知道浏览器中的哪些东西是独立于输入设备的，那就要靠经验的积累了。首先你要理解的就是事件处理机制。 理解事件（事件处理会引起改变） 事件处理是走向不唐突的JavaScript的第二步。重点不是让所有的东西都变得可以拖拽、可以点击或者为它们添加内联处理，而是理解事件处理是一个可以完全分离出来的东西。我们已经将HTML，CSS和JavaScript分离开来，但是在事件处理的分离方面却没有走得很远。 事件处理器会监听发生在文档中元素上的变化，如果有事件发生，处理器就会找到一个很奇妙的对象（一般会是一个名为e的参数），这个对象会告诉元素发生了什么以及可以用它做什么。 对于大多数事件处理来说，真正有趣的是它不止发生在你想要访问的元素上，还会在DOM中较高层级的所有元素上发生（即事件冒泡，但是并不是所有的事件都是这样，focus和blur事件是例外）。举例来说，利用这个特性你可以为一个导航列表只添加一个事件处理器，并且使用事件处理器的方法来获取真正触发事件的元素。这种技术叫做事件委托，它有几点好处： 你只需要检查一个元素是否存在，而不需要检查每个元素 你可以动态地添加或者删除子节点而并不需要删除相应的事件处理器 你可以在不同的元素上对相同的事件做出响应 需要记住的另一件事是，在事件向父元素传播的时候你可以停止它而且你可以覆写掉HTML元素（比如链接）的缺省行为。不过，有时候这并不是个好主意，因为浏览器赋予HTML元素那些行为是有原因的。举个例子，链接可能会指向页面内的某个目标，不去修改它们能确保用户可以将页面当前的脚本状态也加入书签。 为他人着想（命名空间，作用域和模式） 你的代码几乎从来不会是文档中的唯一的脚本代码。所以保证你的代码里没有其它脚本可以覆盖的全局函数或者全局变量就显得尤为重要。有一些可用的模式可以来避免这个问题，最基础的一点就是要使用var关键字来初始化所有的变量。假设我们编写了下面的脚本：12345678910111213var nav = document.getElementById('nav'); function init()&#123; show(); if(nav.className === 'show')&#123; reset(); &#125;&#125; function show()&#123; // do stuff &#125; function reset()&#123; // do stuff &#125; 上面的代码中包含了一个叫做nav的全局变量和名字分别为 init,show 和 reset 的三个函数。这些函数都可以访问到nav这个变量并且可以通过函数名互相访问:123456789101112131415var nav = document.getElementById('nav'); function init()&#123; show(); if(nav.className === 'show')&#123; reset(); &#125; // do stuff &#125; function show()&#123; var c = nav.className; // do stuff &#125; function reset()&#123; // do stuff &#125; 你可以将代码封装到一个对象中来避免上面的那种全局式编码，这样就可以将函数变成对象中的方法，将全局变量变成对象中的属性。你需要使用“名字+冒号”的方式来定义方法和属性，并且需要在每个属性或方法后面加上逗号作为分割符。如下所示：123456789101112var myScript = &#123; nav: document.getElementById('nav'), init: function()&#123; // do stuff &#125;, show: function()&#123; // do stuff &#125;, reset: function()&#123; // do stuff &#125; &#125; 所有的方法和属性都可以通过使用“类名+点操作符”的方式从外部和内部访问到。1234567891011121314151617var myScript = &#123; nav: document.getElementById('nav'), init: function()&#123; myScript.show(); if(myScript.nav.className === 'show')&#123; myScript.reset(); &#125; // do stuff &#125;, show:function()&#123; var c = myScript.nav.className; // do stuff &#125;, reset:function()&#123; // do stuff &#125; &#125; 这种模式的缺点就是，你每次从一个方法中访问其它方法或属性都必须在前面加上对象的名字，而且对象中的所有东西都是可以从外部访问的。如果你只是想要部分代码可以被文档中的其他脚本访问，可以考虑下面的模块（module）模式：123456789101112131415161718192021var myScript = function()&#123; //这些都是私有方法和属性 var nav = document.getElementById('nav'); function init()&#123; // do stuff &#125; function show()&#123; // do stuff &#125; function reset()&#123; // do stuff &#125; //公有的方法和属性被使用对象语法包装在return 语句里面 return &#123; public:function()&#123; &#125;, foo:'bar' &#125;&#125;(); 你可以使用和前面的代码同样的方式访问返回的公有的属性和方法，在本示例中可以这么访问：myScript.public() 和 myScript.foo 。但是这里还有一点让人觉得不舒服：当你想要从外部或者从内部的一个私有方法中访问公有方法的时候，还是要写一个冗长的名字（对象的名字可以非常长）。为了避免这一点，你需要将它们定义为私有的并且在return语句中只返回一个别名：12345678910111213141516171819202122var myScript = function()&#123; // 这些都是私有方法和属性 var nav = document.getElementById('nav'); function init()&#123; // do stuff &#125; function show()&#123; // do stuff &#125; function reset()&#123; // do stuff &#125; var foo = 'bar'; function public()&#123; &#125; //只返回指向那些你想要访问的私有方法和属性的指针 return &#123; public:public, foo:foo &#125; &#125;(); 这就保证了代码风格一致性，并且你可以使用短一点的别名来访问其中的方法或属性。 如果你不想对外部暴露任何的方法或属性，你可以将所有的代码封装到一个匿名方法中，并在它的定义结束后立刻执行它：1234567891011121314(function()&#123; // these are all private methods and properties var nav = document.getElementById('nav'); function init()&#123; // do stuff show(); // 这里不需要类名前缀 &#125; function show()&#123; // do stuff &#125; function reset()&#123; // do stuff &#125; &#125;)(); 对于那些只执行一次并且对其它函数没有依赖的代码模块来说，这种模式非常好。 通过遵循上面的那些规则，你的代码更好地为用户工作，也可以使你的代码在机器上更好地运行并与其他开发者的代码和睦相处。不过，还有一个群体需要考虑到。 为接手的开发者考虑（使维护更加容易）使你的脚本真正地unobtrusive的最后一步是在编写完代码之后仔细检查一遍，并且要照顾到一旦脚本上线之后要接手你的代码的开发者。考虑下面的问题： 所有的变量和函数名字是否合理并且易于理解？ 代码是否经过了合理的组织？从头到尾都很流畅吗？ 所有的依赖都显而易见吗？ 在那些可能引起混淆的地方都添加了注释吗？ 最重要的一点是：要认识到文档中的HTML和CSS代码相对于JavaScript来说更有可能被改变（因为它们负责视觉效果）。所以不要在脚本代码中包含任何可以让终端用户看到的class和ID，而是要将它们分离出来放到一个保存配置信息的对象中:123456789101112131415161718192021myscript = function()&#123; var config = &#123; navigationID:'nav', visibleClass:'show' &#125;; var nav = document.getElementById(config.navigationID); function init()&#123; show(); if(nav.className === config.visibleClass)&#123; reset(); &#125;; // do stuff &#125;; function show()&#123; var c = nav.className; // do stuff &#125;; function reset()&#123; // do stuff &#125;; &#125;(); 这样维护者就知道去哪里修改这些属性，而不需要改动其他代码，这一点对于大量版本迭代维护十分重要。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"},{"name":"转载","slug":"转载","permalink":"http://www.gcidea.info/tags/转载/"}]},{"title":"JavaScript中二维数组声明时漏写一个逗号所产生现象的探究","slug":"2d-array-miss-a-comma","date":"2016-03-19T03:32:20.000Z","updated":"2018-12-12T16:08:58.732Z","comments":true,"path":"2016/03/19/2d-array-miss-a-comma/","link":"","permalink":"http://www.gcidea.info/2016/03/19/2d-array-miss-a-comma/","excerpt":"","text":"场景与现象 具体业务逻辑：在组件进行初始化时需要赋值一个二维数组（4 * 12），如下所示：123456$scope.data = [ [-1, 1, 3, 7, 13, 16, 18, 16, 15, 9, 4, 2] [0, 1, 4, 7, 12, 15, 16, 15, 15, 10, 6, 5], [4, 4, 5, 10, 16, 22, 25, 24, 20, 14, 9, 3], [7, 6, 8, 14, 17, 22, 25, 27, 24, 17, 14, 10]]; 应该能够发现，数组声明时漏写了一个逗号。这就导致在使用该数组对其他对象进行赋值时出现了奇怪的现象： 其中后三列是好解释的：第二列和第三列分别对应了原二维数组中的[4, 4, 5, 10, 16, 22, 25, 24, 20, 14, 9, 3]和[7, 6, 8, 14, 17, 22, 25, 27, 24, 17, 14, 10]，由此第四列必然取不到值了，是undefined。但是，为什么第一列的取值是一个数字16? 解释这个现象涉及到了javascript的如下知识点： 与java等语言不同，javascript中数组的各个元素可以是不同数据类型。比如一个数组中有字符串，有数字，有布尔值。 在javascript中，数组也是对象，且可以通过方括号[下标]的形式取出某个元素，比如”[0,4,2][1]”的值是4，即数组[0,4,2]中下标为1的元素。 逗号“,”在javascript中是“逗号运算符”，解析时，js引擎会先计算逗号左边的值，再计算逗号右边的值，但只返回逗号右边的值。比如：var a = (1+1, 2+2, 3+3);结果a会为6。4 根据以上几点，可以清楚解释上面的现象“16”：漏写了一个逗号，违背了我们的本意（4个数组），但js引擎并不认为这是错误的，而认为是想在[-1, 1, 3, 7, 13, 16, 18, 16, 15, 9, 4, 2]中取值，取值方括号中本来只应该放一个下标（如上面解释第二点所说），这里却放了由逗号连接的很多个值[0, 1, 4, 7, 12, 15, 16, 15, 15, 10, 6, 5]，js引擎也不会认为这是错误的，因为实质上在进行“逗号运算”，运算结果是最后一个逗号右边的值，即5。也就是说：[-1, 1, 3, 7, 13, 16, 18, 16, 15, 9, 4, 2][0, 1, 4, 7, 12, 15, 16, 15, 15, 10, 6, 5]相当于[-1, 1, 3, 7, 13, 16, 18, 16, 15, 9, 4, 2][5]也就是取下标为5的元素，即16。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/categories/JavaScript/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.gcidea.info/tags/学习笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.gcidea.info/tags/JavaScript/"}]},{"title":"【首篇】记录本博客www.gcidea.info的搭建过程","slug":"2016-03-16-my-first-blog","date":"2016-03-16T07:49:41.000Z","updated":"2018-12-12T16:08:59.115Z","comments":true,"path":"2016/03/16/2016-03-16-my-first-blog/","link":"","permalink":"http://www.gcidea.info/2016/03/16/2016-03-16-my-first-blog/","excerpt":"前言 在探索各类技术的道路上，我从无数博客中学到了很多东西。这些博文中往往都是大家在实践过程中遇到的各类问题最真实的反映和汇总，因此有很强的参考性。 但同时，由于环境、版本、配置等等方面的不同，一些问题在每个人面前又有着不同的具体表现，让人摸不着头脑。因此，我也十分乐意分享出一些自己的经验，让大家在遇到问题时多一些尝试办法。当然，能做到这一点自然是最好了，更多的，我是想借用这样一个平台记录自己在技术学习过程中的点点滴滴，是一种总结，也是一种约束。 平台的选择考虑过CSDN，博客园等，可以有更多的人交流。但反而一想，搭建博客本身就是一次探索尝试的过程，因此我选择最终选择了“自己动手”，同时，在一个相对安静的环境中，也好“修炼”自己。","text":"前言 在探索各类技术的道路上，我从无数博客中学到了很多东西。这些博文中往往都是大家在实践过程中遇到的各类问题最真实的反映和汇总，因此有很强的参考性。 但同时，由于环境、版本、配置等等方面的不同，一些问题在每个人面前又有着不同的具体表现，让人摸不着头脑。因此，我也十分乐意分享出一些自己的经验，让大家在遇到问题时多一些尝试办法。当然，能做到这一点自然是最好了，更多的，我是想借用这样一个平台记录自己在技术学习过程中的点点滴滴，是一种总结，也是一种约束。 平台的选择考虑过CSDN，博客园等，可以有更多的人交流。但反而一想，搭建博客本身就是一次探索尝试的过程，因此我选择最终选择了“自己动手”，同时，在一个相对安静的环境中，也好“修炼”自己。 关键词 github | git | node.js | hexo | 域名 托管服务器 要搭建一个在公网可访问的博客，必须具备稳定可靠的服务器，现在有阿里云之类的不少选择，而我最终选择了使用github提供的Github Pages，这也符合github推出该项服务的宗旨。 选择Github Pages，自然要先有一个github账号，关于账号注册相关的内容，网上有大量资源供大家参考。这里就说明几个要点： 在自己的账号下新建的Github Pages仓库，其仓库名一定要和github账号一致。比如，用户名为：1qaz，则仓库命名为： 1qaz.github.io 如下图所示： 建立好该仓库后，选择Settings，按默认设置即可，选择“Launch automatic page generator”,按照自己的需求填写Tagline,Body等内容，选择“continue to layouts”,再在页面上方选择一个自己喜欢的主题即可（这里可以随便选一个主题，我们还使用hexo提供的更为丰富的主题，后续会说明），这时候点击“Publish page”,一个最基本的个人页面就生成了。 Git的安装与使用 关于Git与Github的关系，是一个老生常谈的问题了，不必多说。 我是在Windows上完成这个过程的，推荐使用msysgit，它是Windows版的Git，从http://msysgit.github.io/下载，然后按默认选项安装即可。安装成功后，可以在桌面右键选择“Git Bash Here”，打开一个类似于cmd的窗口如下图。通过以下命令配置一下自己的git账户。例如用户名为：1qaz 邮箱为1qaz@example.com，则配置如下：git config --global user.name &quot;1qaz&quot;git config --global user.email &quot;1qaz@example.com&quot;想更多了解以上过程，推荐参考廖雪峰的官方网站-git教程 建立本地与服务器之间的ssh连接 写博客的过程自然是在本地完成内容后，将其推动到github的仓库中（不要担心，这个完整的过程是重头戏，稍候会详细说明）。这个推送的过程，每次都会弹窗提示你输入github账户的用户名和密码，很不方便。对此，github为我们提供了SSH KEYS服务，我们只要将本地的公钥手动添加到github账户的“Personal settings-SSH keys”中即可。 怎么生成这个公钥呢？ 打开刚刚我们安装提到的“Git Bash”，输入以下命令：ssh-keygen -t rsa -C &quot;1qaz@example.com&quot;对于之后的提示全按回车即可。之后，进入系统盘用户(user)目录下找到.ssh目录，其中有id_rsa和id_rsa.pub两个文件，这就是SSH Keys秘钥对，id_rsa是私钥，id_rsa.pub是公钥。我们打开公钥这个文件，将其中的内容全部复制，粘贴到github账户的“Personal settings-SSH keys”中即可。这样，对于之后所有的推送请求，github账户能够识别出“你是谁”，从而有相应权限，不必每次输入用户名和密码。 安装Node.js 为何需要安装这个环境呢？ 因为我们后面需要用到博客框架Hexo，而这是一个基于node.js技术开发的一个纯静态博客系统，因此自然需要Node.js的运行环境。 安装起来并不费力。直接从官网或者国内镜像下载安装包安装即可。在Windows下安装时务必勾选全部组件。一步步next安装完成之后，测试一下，在cmd窗口输入node -v，若提示相应版本号,则说明安装成功。 顺便提一下，npm是Node.js的一个包管理工具，我们在后面安装Hexo时候会用到，不过这个工具已经在安装Node环境时安装好了，我们只要测试一下能用即可。 输入npm -v，若提示相应版本号,则说明安装成功。 博客框架Hexo的安装、部署、配置、使用、更换主题 经过之前的过程，我们已经做好了各项准备工作，有了一个博客的首页，同时为后续更新博文做好了准备。但之前也提到过，github提供的主题是有限的，同时，博客是一个我们用来记录自己思考学习的地方，就这一点来讲，我们应该将精力集中在博客内容本身上。因此，我们需要有一套机制来帮助我们简化博文更新维护，博客页面样式美化等操作，这就是我使用Hexo的原因。 安装 从github上的Hexo首页https://github.com/hexojs/hexo我们可以看到Hexo的相关介绍。 在Windows平台上安装方法如下： 打开cmd窗口，使用以下命令： npm install hexo-cli -g 即可完成安装（该过程可能较慢，需要稍等待一段时间）。 部署 部署也很简单，选择一个合适的位置，新建一个文件夹Hexo,在该文件夹中右键“Git Bash Here”，使用以下命令： hexo init 就会在该文件夹中创建所需的全部文件。如下图： 配置 Hexo的使用还是很简单的，首先我们要进行相关配置，打开上图中的_config.yml文件，对其中主要的配置说明如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 ## Docs: https://hexo.io/docs/configuration.html 【hexo的文档】## Source: https://github.com/hexojs/hexo/ 【hexo的资源地址】 # Sitetitle: &quot;GCidea&apos;s blog&quot; 【博客首页的一级标题】subtitle: &quot;gaochang | BUPT&quot; 【博客首页的二级标题】description: &quot;gaochang | BUPT&quot; 【博客的描述内容】author: &quot;Gao Chang&quot; 【作者】language: zh-CN 【语言支持】email: gaochang@ebupt.com 【联系邮箱】timezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: / 【根目录】permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Archives## 2: Enable pagination## 1: Disable pagination## 0: Fully Disablearchive: 1 【设置为1是全部展示，不折叠】category: 1tag: 1# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map: tag_map: # Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: jacman 【所选的Hexo主题，默认的是landscape，这里我换成了jacman，稍后会说明】# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git 【部署类型】 repository: https://github.com/gcidea/gcidea.github.io.git 【自己所建立的github page仓库地址】 branch: master 【部署到master分支】 以上修改中要特别注意：修改_config.yml文件，其中type需要指明为git 而不是github修改之后，直接hexo generate–hexo deploy是会报错的，提示的错误是depolyer:git not found这时需要在git bash中输入以下命令来明确保存depolyer:npm install hexo-deployer-git --save 使用经过以上过程，我们就有了一个写博客的环境了~在hexo的文件夹下，输入以下命令：hexo new &#39;a_new_blog&#39;就会在_posts目录下创建一个.md的博客文件。说到这里，自然要提到markdown了，hexo很好地支持markdown语言，而且由于markdown简单的语法，使用起来十分方便，关于markdown语法的介绍网上有很多，这里就不赘述了。 更换主题 默认的主题是landscape，插件或者页面效果不是那么丰富，hexo提供了很多主题https://hexo.io/themes/供大家选择，我这里选用了jacman主题，是经过优化的pacman主题。 主题更换方法：在hexo文件夹的themes文件夹下新建jacman文件夹，在jacman文件夹中右键选择“Git Bash Here”，输入以下命令：git clone https://github.com/wuchong/jacman.git就完成了主题文件的下载；其次，在上文提到的_config.yml文件中，将“theme”一项配置为“jacman”即可。通过以上过程，我们就可以顺利地进行日常博客的写作了。 Jacman主题的配置 Jacman提供了丰富的插件，在该主题文件夹下的_config.yml中进行配置，有github名片、友情链接、知乎、新浪微博、微博秀等等，配置的方法都很简单，基本上就是去相应网站登录自己的账户，将自己的用户ID之类的标识配置在该文件中即可。 域名绑定 这个可以说是一个可选择的步骤，我们经过上面一大堆工作建立的github pages本身已经可以通过http://gcidea.github.io访问了，设定域名是一个个性化的过程。 域名注册商的选择，国内国外都有，本来在GoDaddy（狗爹）上购买，无奈不知怎的支付宝支付始终不成功，就这样，我使用了阿里旗下的万网，效果也很不错。域名注册后，域名解析的过程在阿里云的用户中心中有很详细的说明，参照这个操作就好了。主要要搞清A记录还有CNAME记录的区别和作用。 A类地址指向的IP其实是github pages的一个公共IP，而域名之所以能明确地和你个人的主页对应起来，还需要在github pages仓库下做一下配置： 新建一个名称为CNAME的文件，在其中只写一行：gcidea.info，这样当域名解析至github pages的IP时，github就可以通过你的域名和索引的全部用户的CNAME文件进行匹配，从而找到你的主页。 结语说了这么多，基本上就是博客搭建的整个过程了。这其中遇到了很多问题，也在网上参考了很多别人的经验，在此表示感谢。其中还有很多一笔带过的地方，每个地方展开说可能都是一篇文章，都值得我们仔细思考。","categories":[{"name":"搭建部署","slug":"搭建部署","permalink":"http://www.gcidea.info/categories/搭建部署/"},{"name":"工程","slug":"搭建部署/工程","permalink":"http://www.gcidea.info/categories/搭建部署/工程/"}],"tags":[{"name":"搭建部署","slug":"搭建部署","permalink":"http://www.gcidea.info/tags/搭建部署/"}]}]}